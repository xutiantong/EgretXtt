// -----------------------------------// AnimationData// -----------------------------------// -----------------------------------// Instance// -----------------------------------import Matrix2D from "./Matrix2D";class Instance {    public element;    public libraryID;    public frame;    public transform;    public alpha;    constructor(libraryID, frame, transform, alpha) {        this.element = null;        // Optional identifiers        this.libraryID = libraryID || null; // unique symbol identifier (aka actionscript linkage)        // this.instanceName = instanceName; // unique instance identifier        this.frame = frame;        this.transform = transform;        this.alpha = alpha;    }    linkElement = function (library) {        this.element = library[this.libraryID]    }}// -----------------------------------// Sprite// -----------------------------------class Bounds {    public x: number;    public y: number;    public w: number;    public h: number;    constructor(boundsData) {        this.x = -boundsData.x;        this.y = -boundsData.y;        this.w = boundsData.w;        this.h = boundsData.h;    }}class Sprite {    public image;    public bounds;    private spriteFrame: cc.SpriteFrame    private sprite: cc.Sprite    constructor(image, spriteData) {        this.image = image;        this.bounds = new Bounds(spriteData);        this.spriteFrame = new cc.SpriteFrame(image, new cc.Rect(this.bounds.x, this.bounds.y, this.bounds.w, this.bounds.h))        this.sprite = new cc.Sprite();    }    _wrapRender(ctx, transform: Matrix2D, alpha) {        if (this.image) {            ctx.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);            ctx.globalAlpha = alpha;            var bounds = this.bounds;            this.image.renderShort(ctx, bounds.x, bounds.y, bounds.w, bounds.h);        }    }    _expandBoundingBox(boundingBox, elementID, transform) {        if (elementID !== null) {            return;        }        var left = this.bounds.x;        var right = this.bounds.x + this.bounds.w;        var top = this.bounds.y;        var bottom = this.bounds.y + this.bounds.h;        var a = transform.a;        var b = transform.b;        var c = transform.c;        var d = transform.d;        var tx = transform.tx;        var ty = transform.ty;        var x0 = left * a + top * c + tx;        var y0 = left * b + top * d + ty;        var x1 = right * a + top * c + tx;        var y1 = right * b + top * d + ty;        var x2 = left * a + bottom * c + tx;        var y2 = left * b + bottom * d + ty;        var x3 = right * a + bottom * c + tx;        var y3 = right * b + bottom * d + ty;        boundingBox.left = Math.min(boundingBox.left, x0, x1, x2, x3);        boundingBox.top = Math.min(boundingBox.top, y0, y1, y2, y3);        boundingBox.right = Math.max(boundingBox.right, x0, x1, x2, x3);        boundingBox.bottom = Math.max(boundingBox.bottom, y0, y1, y2, y3);    }}// -----------------------------------// Symbol// -----------------------------------class Symbol {    public timeline;    public duration;    public transform;    constructor(timeline) {        this.timeline = timeline;        this.duration = timeline.length;        this.transform = new Matrix2D();    }    _wrapRender(ctx, parentTransform, parentAlpha, frame, elapsedFrames, substitutes) {        var children = this.timeline[frame];        for (var i = 0; i < children.length; i++) {            var child = children[i];            var alpha = parentAlpha * child.alpha;            var transform = this.transform;            transform.copy(parentTransform);            transform.transform(child.transform);            // Lookup in the substitutes map is slow, trying to avoid it            var libraryID = child.libraryID;            var element = libraryID ? (substitutes[libraryID] || child.element) : child.element;            var childFrame = elapsedFrames;            var frameCount = element.frameCount;            if (childFrame >= frameCount) {                childFrame = childFrame % frameCount;            }            // n.b element can be of 3 different types: Symbol, Sprite or MovieClip            // therefore this method cannot be perfectly optimized by optimizer-compilers            element._wrapRender(ctx, transform, alpha, childFrame, elapsedFrames, substitutes);        }    }    _expandBoundingBox(boundingBox, elementID, parentTransform, frame, elapsedFrames, substitutes) {        var children = this.timeline[frame];        for (var i = 0; i < children.length; i++) {            var child = children[i];            if (child.alpha === 0) {                // No need to expand bounds to include invisible elements                continue;            }            var transform = this.transform;            transform.copy(parentTransform);            transform.transform(child.transform);            var libraryID = child.libraryID;            var element = libraryID ? (substitutes[libraryID] || child.element) : child.element;            var childFrame = elapsedFrames;            var frameCount = element.frameCount;            if (childFrame >= frameCount) {                childFrame = childFrame % frameCount;            }            var searchedElementID = (elementID === libraryID) ? null : elementID;            element._expandBoundingBox(boundingBox, searchedElementID, transform, childFrame, elapsedFrames, substitutes);        }    }}export default class AnimationData {    public static EMPTY_SYMBOL = new Symbol([[]]);    public url: string;    public frameRate;    public symbolList;    public library;    public animations;    public animationList;    constructor(data, url, images) {        data = {            frameRate: 24,            animations: {                //symbolID:[transId,unknow,libId,frame,alpha]                _animationclips: [[[0, 0, 0, 0, 1]]]            },            skins: {},            transforms: [1, 0, 0, 1, 0, 0],            textureOffsets: {                child_0: {                    x: -10,                    y: -10,                    width: 118,                    height: 118,                    url: "child_0.png"                }            },            ids: ["__none","child_0"]        }        this.url = url;        this.frameRate = data.frameRate;        // Pool of transformation and color matrices        var transformArrays = data.transforms || [];        var le = transformArrays.length / 6        var transforms = new Array(le);        for (var t = 0; t < le; t += 1) {            var f = 6 * t;            var transform = new Matrix2D();            transform.a = transformArrays[f];            transform.b = transformArrays[f + 1];            transform.c = transformArrays[f + 2];            transform.d = transformArrays[f + 3];            transform.tx = transformArrays[f + 4];            transform.ty = transformArrays[f + 5];            transforms[t] = transform;        }        var symbols = data.animations;        this.symbolList = Object.keys(symbols);        // Exposed symbols can either be substituted or used as substitutes        this.library = {};        // TODO: make these properties private        this.animations = this.library;        this.animationList = this.symbolList;        var timelines = []        var ids = data.ids;        //animation key        for (var v = 0; v < this.symbolList.length; v += 1) {            //processSymbol            var symbolID = this.symbolList[v];            //[[[0,0,0,0,1]]]            var symbolData = symbols[symbolID];            var timeline = [];            for (var x = 0; x < symbolData.length; x += 1) {                var elements = symbolData [x]                timeline[x] = [];                for (var E = 0; E < elements.length; E += 1) {                    var element = elements[E]                    var trans = transforms[element[0]]                    var libraryID = ids[element [2]]                    var frame = element [3]                    var alpha = element [4]                    //libraryID frame transform alpha                    var instance = new Instance(libraryID, frame, trans, alpha);                    timeline[x].push(instance)                    timelines.push(instance)                }            }            this.library[symbolID] = new Symbol(timeline)        }        this.library.__none = new Symbol([[]]);        var textures = data.textureOffsets;        for (var spriteID  in textures) {            var spriteData = textures[spriteID]            this.library[spriteID] = new Sprite(spriteData.url, spriteData)        }        for (var i = 0; i < timelines.length; i += 1) {            timelines[i].linkElement(this.library)        }    }}