import {bgHeight, MonsterEntity} from "./MonsterEntity";import {Timer} from "./Entity";import {gameModel} from "./GameModel";var bossBaseCfg = {    distance: 2.5 * bgHeight,    distanceForRaids: 1.5 * bgHeight,    //health    healthMultiplierBase: 1.625,    healthMultiplierMax: 30,    healthMultiplierMaxForRaids: 1e5,    //speed    speedMultiplierMax: 16,    speedMultiplierMaxForRaids: 30,    //special    specialMultiplierMax: 16,    specialMultiplierMaxForRaids: 30,    playerSpeed: -.2,    width: 512,    height: 512}export class BossEntity extends MonsterEntity {    private healthMult = 1;    private speedMult = 1;    private specialMult = 1;    private speed = 1;    private special = 1;    private fpsMin = 24;    private fpsMax = 60;    private fpsPerSpeedPt = .5;    private isReady = !1;    public action = "";    public actionTimer = new Timer();    public config = null;    private initialOffsetY = 0;    private numHitsFromPlayer = 0;    // i._scale = 1；    constructor() {        super();        this.isBoss = !0;        this.width = bossBaseCfg.width        this.height = bossBaseCfg.height    }    private updateSpeed() {        var bossLevel = gameModel.bossLevel;        var speedModifier = gameModel.speedModifier;        //冷冻        this.speedMult = this.calculateSpeedMult(speedModifier, bossLevel);        this.speed = this.calculateSpeed(speedModifier, bossLevel);        this.fpsMin = this.config.fpsMin,            this.fpsMax = this.config.fpsMax,            this.fpsPerSpeedPt = this.config.fpsPerSpeedPt    }    get fps() {        var enemyFreezeMult = 1;        return this.fpsNormal * enemyFreezeMult    }    get fpsNormal() {        return Math.min(this.fpsMax, Math.floor(this.fpsMin + this.fpsPerSpeedPt * this.speed))    }    //SpeedModifier level    private calculateSpeedMult(speedModifier, level) {        return Math.min(bossBaseCfg.speedMultiplierMax, level * speedModifier)    }    //SpeedModifier level isRaid    private calculateSpeed(speedModifier, level) {        return this.calculateSpeedMult(speedModifier, level) * this.config.speed    }    private calculateSpecialMult(specialModifier, bossLevel: number) {        return Math.min(bossBaseCfg.specialMultiplierMax, specialModifier * bossLevel)    };    //id specialModifier level isRaid    private calculateSpecial(specialModifier, bossLevel: number) {        return this.calculateSpecialMult(specialModifier, bossLevel) * this.config.special    }    private calculateHealthMult(e, t) {        var n = Math.pow(this.config.healthMultiplierBase, t - 1);        return Math.min(this.config.healthMultiplierMax, n * e)    }    //healthModifier level    private calculateHealth(healthModifier: number, bossLevel: number) {        return Math.floor(this.calculateHealthMult(healthModifier, bossLevel) * this.config.health)    }    protected resetStats() {        var bossLevel = gameModel.bossLevel;        var healthModifier = gameModel.healthModifier;        var speedModifier = gameModel.speedModifier;        var specialModifier = gameModel.specialModifier;        this.healthMult = this.calculateHealthMult(healthModifier, bossLevel);        this.health = this.calculateHealth(healthModifier, bossLevel);        this.healthMax = this.health;        this.element = this.config.element || "";        this.speedMult = this.calculateSpeedMult(speedModifier, bossLevel);        this.speed = this.calculateSpeed(speedModifier, bossLevel);        this.fpsMin = this.config.fpsMin,            this.fpsMax = this.config.fpsMax,            this.fpsPerSpeedPt = this.config.fpsPerSpeedPt;        this.specialMult = this.calculateSpecialMult(specialModifier, bossLevel);        this.special = this.calculateSpecial(specialModifier, bossLevel)    }    protected resetBehavior() {        this.isReady = !1;        this.action = "";        this.actionTimer.reset(0);    }    public step(t: number) {        if (gameModel.isBossPaused || gameModel.isBossLoading) {            this.y = -2 * bgHeight + this.initialOffsetY        } else {            gameModel.bossesTimeSpent += t            super.step(t)        }    }    protected move(t: number) {        var oldX = this.x;        super.move(t);        this.updateMovementEffects(t);        if (!this.isReady) {            this.x = oldX        }        //冰冻状态检测        // this.isChilled && (this.chillTimer.active || (this.isChilled = !1, this.updateSpeed()))    }    protected updateMovementEffects(t: number) {    }    protected validatePosition() {        var vy = gameModel.playerSpeedInBattle;        if (!this.isReady) {            //验证边界            if (this.vy >= 0 && this.y - this.height / 2 < gameModel.y) return !1;            if (0 === this.vy) {                this.y = gameModel.y + this.height / 2,                    this.vy = vy                this.isReady = !0            }        }        return super.validatePosition()    }    protected updateBehavior(e) {        if (this.view) {            this.view.sprite.fps = this.fps        }        if (this.isReady && !gameModel.isBossPaused) {            this.actionTimer.step(e),            this.actionTimer.active || this.runNextAction()        }    }    protected runNextAction() {    }    //e=bulletname    //t=x i=y    //n=speed o=angle a=scale    protected fireBullet(bullet: string, x: number, y: number, speed: number, angle: number, scale: number) {        //计算加速度        var vx = Math.cos(angle) * speed;        var vy = Math.sin(angle) * speed + gameModel.playerSpeedInBattle;        //创建子弹        // var l = this.gameModel.enemyBullets.obtainModel();        // l.reset(bullet);        // l.x = x,        // l.y = y,        // l.vx = vx,        // l.vy = vy,        // l.scale = scale;        // return l        return null    }    protected applyStatusEffects(e) {        // if (this.isReady && !gameModel.isBossPaused && e.skillPowers) {        //     var i = e.skillPowers.ice,        //         n = e.skillPowers.poison;        //     i && this.onChill(i),        //     n && e.damage && this.onPoison(n * e.damage)        // }    }    protected applyDamage(tgt, damage?: number, t?: number, isPlayer?: boolean) {        if (this.isReady && !gameModel.isBossPaused) {            if (tgt && !tgt.isSidekick || isPlayer) {                this.numHitsFromPlayer++            }            return super.applyDamage(tgt, damage);        }        return 0;    }    protected getDamageMultiplier(target) {        return super.getDamageMultiplier(target);    }    protected getHealthMechanicMultiplier() {        return 1    }}