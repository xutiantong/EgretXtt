import {Entity} from "./Entity";"./Entity";var monsterCfg = [];export var bgWidth = 750;//cc.director.getWinSize().widthexport var bgHeight = 1124;//cc.director.getWinSize().heightexport class MonsterEntity extends Entity {    public health = 0;    public healthMax = 0;    public element = "";    public wave = 0; //波数    public isBoss: boolean = !1;    constructor() {        super()    }    public reset(id: string) {        super.reset(id);        this.id = id;        this.resetStats();        this.resetBehavior();        this.resetStatusEffects()    }    protected resetStats() {        var e = monsterCfg[this.id];        this.health = e.health;        this.healthMax = this.health;        this.element = e.element || "";    }    protected resetBehavior() {    }    protected resetStatusEffects() {    }    public step(t: number) {        this.move(t);        this.updateMovementEffects(t);        this.updateStatusEffects(t);        if (this.validateHealth() && this.validatePosition()) {            this.updateBehavior(t);        }    }    protected updateMovementEffects(e) {    }    protected updateStatusEffects(t: number) {    }    protected validateHealth() {        return !(this.health <= 0) || (this.kill(), !1)    }    protected validatePosition() {        if (this.x < 0) {            this.x = 0;            this.vx *= -1        } else if (this.x > bgWidth) {            this.x = bgWidth;            this.vx *= -1;        }        if (this.y < -bgHeight - this.height / 2) {            this.release();            return false        }        return true;    }    protected updateBehavior(t: number) {    }    //伤害    // time    public onDamage(target, t: number) {        this.applyStatusEffects(target);        this.applyDamage(target, 0, t, !1);        this.validateHealth();    }    //上状态效果    protected applyStatusEffects(target) {        if (target.skillPowers) {            var charm = target.skillPowers.charm;            var ice = target.skillPowers.ice;            var poison = target.skillPowers.poison;            charm && this.onCharm(charm);            ice && this.onChill(ice);            if (poison && target.damage) {                this.onPoison(poison * target.damage);            }        }    }    //伤害减血    protected applyDamage(bullet, damage?: number, t?: number, isPlayer?: boolean) {        damage = damage || 0;        if (bullet) {            damage += this.getDamageMultiplier(bullet) * bullet.damage        }        this.health -= damage;        if (this.health < 0) {            damage += this.health;            this.health = 0;        }        return damage;    }    //针对目标获取伤害倍率    protected getDamageMultiplier(target) {        var t = 1;        if (this.isWeakAgainst(target.element)) {            t = 1.5;        }        if (!this.isBoss) {            var i = target.skillPowers ? target.skillPowers.monsterKiller : 0;            i && (t *= 1 + i)        }        return t    }    //被克制    private isWeakAgainst = function (e) {        var t = this.getWeakness();        return !!t && (e === t || "prismatic" === e)    };    private getWeakness(): string {        var e = "";        switch (this.element) {            case"fire":            case"metal":                e = "water";                break;            case"ice":            case"nature":                e = "fire";                break;            case"water":            case"toxic":                e = "nature";                break;            case"shadow":                e = "light";                break;            case"light":            case"normal":                e = "shadow"        }        return e    }    //魅惑    private onCharm(charmPower: number) {    }    //冷冻    private onChill(chillPower: number) {    }    //中毒    private onPoison(poisonPower: number) {    }    //激光    private onLaser = function (e) {    };    //爆炸    public scheduleDoom(t: number, callback) {    }    public kill() {        this._collection.killModel(this)    }    public release() {        this._collection.releaseModel(this)    }}