(function outer(modules, cache, entry) {
  var previousRequire = "function" == typeof require && require;
  function newRequire(name, jumped) {
    var module = cache[name];
    if (!module) {
      var moduleData = modules[name];
      if (!moduleData) {
        var currentRequire = "function" == typeof require && require;
        if (!jumped && currentRequire) return currentRequire(name, true);
        if (previousRequire) return previousRequire(name, true);
        var err = new Error("Cannot find module '" + name + "'");
        err.code = "MODULE_NOT_FOUND";
        throw err;
      }
      var exports = {};
      module = cache[name] = {
        exports: exports
      };
      moduleData[0]((function(x) {
        return newRequire(moduleData[1][x] || x);
      }), module, exports);
    }
    return module.exports;
  }
  for (var i = 0; i < entry.length; i++) newRequire(entry[i]);
  return newRequire;
})({
  1: [ (function(require, module, exports) {
    cc._renderContext = null;
    cc._supportRender = false;
    cc._canvas = null;
    cc.container = null;
    cc._gameDiv = null;
    require("./cocos2d/core/utils");
    require("./cocos2d/core/platform/CCSys");
    var _engineInitCalled = false, _engineLoadedCallback = null;
    cc._engineLoaded = false;
    function _determineRenderType(config) {
      var CONFIG_KEY = cc.game.CONFIG_KEY, userRenderMode = parseInt(config[CONFIG_KEY.renderMode]) || 0;
      (isNaN(userRenderMode) || userRenderMode > 2 || userRenderMode < 0) && (config[CONFIG_KEY.renderMode] = 0);
      cc._renderType = cc.game.RENDER_TYPE_CANVAS;
      cc._supportRender = false;
      if (0 === userRenderMode) {
        if (cc.sys.capabilities["opengl"]) {
          cc._renderType = cc.game.RENDER_TYPE_WEBGL;
          cc._supportRender = true;
        } else if (cc.sys.capabilities["canvas"]) {
          cc._renderType = cc.game.RENDER_TYPE_CANVAS;
          cc._supportRender = true;
        }
      } else if (1 === userRenderMode && cc.sys.capabilities["canvas"]) {
        cc._renderType = cc.game.RENDER_TYPE_CANVAS;
        cc._supportRender = true;
      } else if (2 === userRenderMode && cc.sys.capabilities["opengl"]) {
        cc._renderType = cc.game.RENDER_TYPE_WEBGL;
        cc._supportRender = true;
      }
    }
    function _afterEngineLoaded() {
      cc._engineLoaded = true;
      console.log("Cocos Creator v" + cc.ENGINE_VERSION);
      _engineLoadedCallback && _engineLoadedCallback();
    }
    function _windowLoaded() {
      window.removeEventListener("load", _windowLoaded, false);
      _afterEngineLoaded();
    }
    cc.initEngine = function(config, cb) {
      if (_engineInitCalled) {
        var previousCallback = _engineLoadedCallback;
        _engineLoadedCallback = function() {
          previousCallback && previousCallback();
          cb && cb();
        };
        return;
      }
      _engineLoadedCallback = cb;
      !cc.game.config && config ? cc.game.config = config : cc.game.config || cc.game._loadConfig();
      config = cc.game.config;
      _determineRenderType(config);
      document.body ? _afterEngineLoaded() : window.addEventListener("load", _windowLoaded, false);
      _engineInitCalled = true;
    };
  }), {
    "./cocos2d/core/platform/CCSys": 97,
    "./cocos2d/core/utils": 136
  } ],
  2: [ (function(require, module, exports) {
    var Enum = require("./cocos2d/core/platform/CCEnum");
    var logList;
    cc.DebugMode = Enum({
      NONE: 0,
      INFO: 1,
      WARN: 2,
      ERROR: 3,
      INFO_FOR_WEB_PAGE: 4,
      WARN_FOR_WEB_PAGE: 5,
      ERROR_FOR_WEB_PAGE: 6
    });
    cc._initDebugSetting = function(mode) {
      cc.log = cc.warn = cc.error = cc.assert = function() {};
      if (mode === cc.DebugMode.NONE) return;
      if (true, mode > cc.DebugMode.ERROR) (function() {
        function logToWebPage(msg) {
          if (!cc._canvas) return;
          if (!logList) {
            var logDiv = document.createElement("Div");
            logDiv.setAttribute("id", "logInfoDiv");
            logDiv.setAttribute("width", "200");
            logDiv.setAttribute("height", cc._canvas.height);
            var logDivStyle = logDiv.style;
            logDivStyle.zIndex = "99999";
            logDivStyle.position = "absolute";
            logDivStyle.top = logDivStyle.left = "0";
            logList = document.createElement("textarea");
            logList.setAttribute("rows", "20");
            logList.setAttribute("cols", "30");
            logList.setAttribute("disabled", "true");
            var logListStyle = logList.style;
            logListStyle.backgroundColor = "transparent";
            logListStyle.borderBottom = "1px solid #cccccc";
            logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = "0px";
            logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = "none";
            logListStyle.padding = "0px";
            logListStyle.margin = 0;
            logDiv.appendChild(logList);
            cc._canvas.parentNode.appendChild(logDiv);
          }
          logList.value = logList.value + msg + "\r\n";
          logList.scrollTop = logList.scrollHeight;
        }
        cc.error = function() {
          logToWebPage("ERROR :  " + cc.js.formatStr.apply(null, arguments));
        };
        cc.assert = function(cond, msg) {
          "use strict";
          if (!cond && msg) {
            msg = cc.js.formatStr.apply(null, cc.js.shiftArguments.apply(null, arguments));
            logToWebPage("ASSERT: " + msg);
          }
        };
        mode !== cc.DebugMode.ERROR_FOR_WEB_PAGE && (cc.warn = function() {
          logToWebPage("WARN :  " + cc.js.formatStr.apply(null, arguments));
        });
        mode === cc.DebugMode.INFO_FOR_WEB_PAGE && (cc.log = cc.info = function() {
          logToWebPage(cc.js.formatStr.apply(null, arguments));
        });
      })(); else if (console && console.log.apply) {
        console.error || (console.error = console.log);
        console.warn || (console.warn = console.log);
        false;
        console.error.bind ? cc.error = console.error.bind(console) : cc.error = function() {
          return console.error.apply(console, arguments);
        };
        cc.assert = function(cond, msg) {
          if (!cond) {
            msg && (msg = cc.js.formatStr.apply(null, cc.js.shiftArguments.apply(null, arguments)));
            false;
            false;
            throw new Error(msg);
          }
        };
      }
      if (mode !== cc.DebugMode.ERROR) {
        false;
        console.warn.bind ? cc.warn = console.warn.bind(console) : cc.warn = function() {
          return console.warn.apply(console, arguments);
        };
      }
      false;
      if (mode === cc.DebugMode.INFO) {
        false;
        console.log.bind ? cc.log = console.log.bind(console) : cc.log = function() {
          return console.log.apply(console, arguments);
        };
        false;
        cc.info = function() {
          (console.info || console.log).apply(console, arguments);
        };
      }
    };
    cc._throw = function(error) {
      var stack = error.stack;
      stack ? cc.error(stack) : cc.error(error);
    };
    var debugInfos = require("./DebugInfos") || {};
    var ERROR_MAP_URL = "https://github.com/cocos-creator/engine/blob/master/EngineErrorMap.md";
    function getTypedFormatter(type) {
      return function() {
        var id = arguments[0];
        var msg = debugInfos[id] || "unknown id";
        if (1 === arguments.length) return msg;
        if (2 === arguments.length) return cc.js.formatStr(msg, arguments[1]);
        var argsArray = cc.js.shiftArguments.apply(null, arguments);
        return cc.js.formatStr.apply(null, [ msg ].concat(argsArray));
      };
    }
    var logFormatter = getTypedFormatter("Log");
    cc.logID = function() {
      cc.log(logFormatter.apply(null, arguments));
    };
    var warnFormatter = getTypedFormatter("Warning");
    cc.warnID = function() {
      cc.warn(warnFormatter.apply(null, arguments));
    };
    var errorFormatter = getTypedFormatter("Error");
    cc.errorID = function() {
      cc.error(errorFormatter.apply(null, arguments));
    };
    var assertFormatter = getTypedFormatter("Assert");
    cc.assertID = function(cond) {
      "use strict";
      if (cond) return;
      cc.assert(false, assertFormatter.apply(null, cc.js.shiftArguments.apply(null, arguments)));
    };
    cc._getError = getTypedFormatter("ERROR");
    cc._initDebugSetting(cc.DebugMode.INFO);
  }), {
    "./DebugInfos": 3,
    "./cocos2d/core/platform/CCEnum": 91
  } ],
  3: [ (function(require, module, exports) {
    module.exports = {
      "1001": "cocos2d: removeAction: Target not found",
      "1002": "cc.ActionManager.removeActionByTag(): an invalid tag",
      "1003": "cc.ActionManager.removeActionByTag(): target must be non-null",
      "1004": "cc.ActionManager.getActionByTag(): an invalid tag",
      "1005": "cocos2d : getActionByTag(tag = %s): Action not found",
      "1006": "[Action step]. override me",
      "1007": "[Action update]. override me",
      "1008": "cocos2d: FiniteTimeAction#reverse: Implement me",
      "1009": "cc.EaseElastic.reverse(): it should be overridden in subclass.",
      "1010": "cc.IntervalAction: reverse not implemented.",
      "1011": "cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.",
      "1012": "cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.",
      "1013": "The speed parameter error",
      "1014": "The repeat parameter error",
      "1015": "parameters should not be ending with null in Javascript",
      "1016": "cc.RotateTo.reverse(): it should be overridden in subclass.",
      "1019": "Failed to construct, Sequence construction needs two or more actions.",
      "1020": "Failed to construct, Spawn construction needs two or more actions.",
      "1021": "cc.Speed.initWithAction(): action must be non nil",
      "1022": "cc.Follow.initWithAction(): followedNode must be non nil",
      "1023": "cc.ActionEase.initWithAction(): action must be non nil",
      "1024": "Invalid configuration. It must at least have one control point",
      "1025": "cc.Sequence.initWithTwoActions(): arguments must all be non nil",
      "1026": "cc.RepeatForever.initWithAction(): action must be non null",
      "1027": "cc.Spawn.initWithTwoActions(): arguments must all be non null",
      "1028": "cc.ReverseTime.initWithAction(): action must be non null",
      "1029": "cc.ReverseTime.initWithAction(): the action was already passed in.",
      "1030": "cc.Animate.initWithAnimation(): animation must be non-NULL",
      "1100": "Expected 'data' dict, but not found. Config file: %s",
      "1101": "Please load the resource first : %s",
      "1200": "cocos2d: Director: Error in gettimeofday",
      "1201": "cocos2d: Director: unrecognized projection",
      "1203": "cocos2d: Director: Error in gettimeofday",
      "1204": "running scene should not null",
      "1205": "the scene should not null",
      "1206": "loadScene: The scene index to load (%s) is out of range.",
      "1207": "loadScene: Unknown name type to load: '%s'",
      "1208": "loadScene: Failed to load scene '%s' because '%s' is already loading",
      "1209": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      "1210": "Failed to preload '%s', %s",
      "1211": "loadScene: The scene index to load (%s) is out of range.",
      "1212": "loadScene: Unknown name type to load: '%s'",
      "1213": "loadScene: Failed to load scene '%s' because '%s' is already loading",
      "1214": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      "1215": "Failed to preload '%s', %s",
      "1300": "element type is wrong!",
      "1400": "'%s' is deprecated, please use '%s' instead.",
      "1401": "The first argument should be the destination object",
      "1402": "The 'visible' property of %s is deprecated, use 'enabled' instead please.",
      "1403": "Sorry, cc.audioEngine.willPlayMusic is removed.",
      "1404": "cc.spriteFrameCache is removed, please use cc.loader to load and cache sprite frames of atlas format.",
      "1405": "The '%s' will be removed in v2.0, please use '%s' instead. \ud83d\ude25",
      "1502": "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
      "1503": "cc.Scheduler.pauseTarget():target should be non-null",
      "1504": "cc.Scheduler.resumeTarget():target should be non-null",
      "1505": "cc.Scheduler.isTargetPaused():target should be non-null",
      "1506": "warning: you CANNOT change update priority in scheduled function",
      "1507": "CCScheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f",
      "1508": "Argument callback must not be empty",
      "1509": "Argument target must be non-nullptr",
      "1510": "cc.Scheduler: Illegal target which doesn't have uuid or instanceId.",
      "1511": "cc.Scheduler: pause state of the scheduled task doesn't match the element pause state in Scheduler, the given paused state will be ignored.",
      "1512": "cc.Scheduler: updateFunc parameter is deprecated in scheduleUpdate function, and will be removed in v2.0",
      "1600": "getZOrder is deprecated. Please use getLocalZOrder instead.",
      "1601": "setZOrder is deprecated. Please use setLocalZOrder instead.",
      "1602": "RotationX != RotationY. Don't know which one to return",
      "1603": "ScaleX != ScaleY. Don't know which one to return",
      "1605": "child already added. It can't be added again",
      "1606": "child must be non-null",
      "1607": "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
      "1608": "boundingBox is deprecated. Use getBoundingBox instead",
      "1609": "argument tag is an invalid tag",
      "1610": "cocos2d: removeChildByTag(tag = %s): child not found!",
      "1612": "cc.Node.stopActionBy(): argument tag an invalid tag",
      "1613": "cc.Node.getActionByTag(): argument tag is an invalid tag",
      "1614": "resumeSchedulerAndActions is deprecated, please use resume instead.",
      "1615": "pauseSchedulerAndActions is deprecated, please use pause instead.",
      "1617": "child must be non-null",
      "1618": "cc.Node.runAction(): action must be non-null",
      "1619": "callback function must be non-null",
      "1620": "interval must be positive",
      "1622": "_ccsg.Node._requestDirtyFlag: failed to satisfy the request, key (%s) for flag have already been taken",
      "1623": "Set '%s' to normal node (not persist root node).",
      "1624": "Replacing with the same sgNode",
      "1625": "The replacement sgNode should not contain any child.",
      "1626": "Should not set alpha via 'color', set 'opacity' please.",
      "1627": "Not support for asynchronous creating node in SG",
      "1628": "Renderer error: Size of the cc._RendererInSG._sgNode must be zero",
      "1629": "The node '%s' has a component inherited from 'cc._RendererInSG'",
      "1630": "JSB environment is not support invoke node.runAction before the 'cc._RendererInSG' component enabled.",
      "1631": "Please use runAction in the method 'start' instead.",
      "1632": "Node name can not include '/'.",
      "1633": "Internal error, should not remove unknown node from parent.",
      "1634": "addChild: The child to add must be instance of cc.Node, not %s.",
      "1635": "reorderChild: this child is not in children list.",
      "1800": "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
      "1801": "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
      "1802": "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
      "1803": "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
      "1900": "Invalid parameter.",
      "2000": "Don't call this method if the event is for touch.",
      "2200": "Resolution not valid",
      "2201": "should set resolutionPolicy",
      "2300": "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
      "2400": "WebGL error %s",
      "2602": "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
      "2603": "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
      "2604": "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
      "2606": "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
      "2607": "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
      "2608": "%s is null, please check.",
      "2609": "cc.Sprite.initWithFile(): filename should be non-null",
      "2610": "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
      "2614": "cc.Sprite.addChild(): child should be non-null",
      "2616": "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
      "2617": "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
      "2618": "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
      "2619": "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
      "2623": "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
      "2625": "too many tiles, only 16384 tiles will be show",
      "2626": "Unrecognized fill type in bar fill",
      "2627": "Can not generate quad",
      "2628": "%s does not exist",
      "2710": "Sprite.initWithTexture(): Argument must be non-nil",
      "2712": "Invalid spriteFrameName",
      "3002": "textureForKey is deprecated. Please use getTextureForKey instead.",
      "3005": "cocos2d: '%s' id=%s %s x %s",
      "3006": "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
      "3007": "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
      "3103": "cc.Texture.addImage(): path should be non-null",
      "3112": "cc.Texture.addImage(): path should be non-null",
      "3113": "NSInternalInconsistencyException",
      "3116": "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures",
      "3117": "Mimpap texture only works in POT textures",
      "3118": "contentSize parameter is deprecated and ignored for cc.Texture2D initWithData function.",
      "3300": "Rect width exceeds maximum margin: %s",
      "3400": "Rect height exceeds maximum margin: %s",
      "3500": "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
      "3501": "Invalid listener type!",
      "3502": "Can't set fixed priority with scene graph based listener.",
      "3503": "Invalid parameters.",
      "3504": "listener must be a cc.EventListener object when adding a fixed priority listener",
      "3505": "The listener has been registered, please don't register it again.",
      "3506": "Unsupported listener target.",
      "3507": "Invalid scene graph priority!",
      "3508": "If program goes here, there should be event in dispatch.",
      "3509": "_inDispatch should be 1 here.",
      "3510": "%s's scene graph node not contains in the parent's children",
      "3511": "event is undefined",
      "3600": "cc.Class will automatically call super constructor of %s, you should not call it manually.",
      "3601": "The editor property 'playOnFocus' should be used with 'executeInEditMode' in class '%s'",
      "3602": "Unknown editor property '%s' in class '%s'.",
      "3603": "Use 'cc.Float' or 'cc.Integer' instead of 'cc.Number' please. \ud83d\ude02",
      "3604": "Can only indicate one type attribute for %s.",
      "3605": "The default value of %s is not instance of %s.",
      "3606": "No needs to indicate the '%s' attribute for %s, which its default value is type of %s.",
      "3607": "The default value of %s must be an empty string.",
      "3608": "The type of %s must be cc.String, not String.",
      "3609": "The type of %s must be cc.Boolean, not Boolean.",
      "3610": "The type of %s must be cc.Float or cc.Integer, not Number.",
      "3611": "Can not indicate the '%s' attribute for %s, which its default value is type of %s.",
      "3612": "%s Just set the default value to 'new %s()' and it will be handled properly.",
      "3613": "'No need to use 'serializable: false' or 'editorOnly: true' for the getter of '%s.%s', every getter is actually non-serialized.",
      "3614": "Should not define constructor for cc.Component %s.",
      "3615": "Each script can have at most one Component.",
      "3616": "Should not specify class name %s for Component which defines in project.",
      "3617": "Can not instantiate CCClass '%s' with arguments.",
      "3618": "ctor of '%s' can not be another CCClass",
      "3619": "ctor of '%s' must be function type",
      "3620": "this._super declared in '%s.%s' but no super method defined",
      "3621": "Unknown type of %s.%s, maybe you want is '%s'.",
      "3622": "Unknown type of %s.%s, property should be defined in 'properties' or 'ctor'",
      "3623": "Can not use 'editor' attribute, '%s' not inherits from Components.",
      "3624": "'%s' overrided '%s' but '%s' is defined as 'false' so the super method will not be called. You can set '%s' to null to disable this warning.",
      "3625": "[isChildClassOf] superclass should be function type, not",
      "3626": "Can't remove '%s' because '%s' depends on it.",
      "3627": "Should not add renderer component (%s) to a Canvas node.",
      "3628": "Should not add %s to a node which size is already used by its other component.",
      "3629": "attribute must be type object",
      "3633": "Properties function of '%s' should return an object!",
      "3634": "Disallow to use '.' in property name",
      "3635": "Default array must be empty, set default value of %s.%s to [], and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = [...];')",
      "3636": "Do not set default value to non-empty object, unless the object defines its own 'clone' function. Set default value of %s.%s to null or {}, and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = {foo: bar};')",
      "3637": "Can not declare %s.%s, it is already defined in the prototype of %s",
      "3638": "'%s': the getter of '%s' is already defined!",
      "3639": "Can not apply the specified attribute to the getter of '%s.%s', attribute index: %s",
      "3640": "'%s': the setter of '%s' is already defined!",
      "3641": "Can not construct %s because it contains object property.",
      "3642": "Cannot define %s.%s because static member name can not be '%s'.",
      "3643": "Can not define a member called 'constructor' in the class '%s', please use 'ctor' instead.",
      "3644": "Please define 'type' parameter of %s.%s as the actual constructor.",
      "3645": "Please define 'type' parameter of %s.%s as the constructor of %s.",
      "3646": "Unknown 'type' parameter of %s.%s\uff1a%s",
      "3647": "The length of range array must be equal or greater than 2",
      "3648": "Can not declare %s.%s method, it is already defined in the properties of %s.",
      "3649": "CCClass %s have conflict between its ctor and __ctor__.",
      "3651": 'Can not call `_super` or `prototype.ctor` in ES6 Classes "%s", use `super` instead please.',
      "3652": 'Failed to construct a dummy instance of the "%s" class using `new` behind the scenes. This is for getting default values declared in TypeScript. Please ensure the class will be able to construct during script\'s initialization. %s.',
      "3653": 'Please do not specifiy "default" attribute in decorator of "%s" property in "%s" class.  \nDefault value must be initialized at their declaration: \ud83d\ude30\n \n// Before:\n@property({\n  type: cc.Integer\n  default: 0  // <--\n})\nvalue;\n// After:\n@property({\n  type: cc.Integer\n})\nvalue = 0;    // <--',
      "3654": 'Please specifiy a default value for "%s" property at its declaration: \ud83d\ude30\n \n// Before:\n@property(...)\nvalue; \n// After:\n@property(...)\nvalue = 0',
      "3655": 'Can not specifiy "get" or "set"  attribute in decorator for "%s" property in "%s" class.  \nPlease use:\n \n@property(...)\nget %s () {\n    ...\n}\n@property\nset %s (value) {\n    ...\n}',
      "3656": "The default value of %s.%s must be an empty string. (changed since 1.8)",
      "3657": "The value assigned to %s should be Texture2D object, not url string. Since 1.8,  \nyou can declare a texture object directly in properties by using:  \n \n{\n    default: null,\n    type: cc.Texture2D  // use 'type:' instead of 'url:'\n}",
      "3658": "browser does not support getters",
      "3700": "internal error: _prefab is undefined",
      "3701": "Failed to load prefab asset for node '%s'",
      "3800": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
      "3801": "The node can not be made persist because it's not under root node.",
      "3802": "The node can not be made persist because it's not in current scene.",
      "3803": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
      "3804": "getComponent: Type must be non-nil",
      "3805": "Can't add component '%s' because %s already contains the same component.",
      "3806": "Can't add component '%s' to %s because it conflicts with the existing '%s' derived component.",
      "3807": "addComponent: Failed to get class '%s'",
      "3808": "addComponent: Should not add component ('%s') when the scripts are still loading.",
      "3809": "addComponent: The component to add must be a constructor",
      "3810": "addComponent: The component to add must be child class of cc.Component",
      "3811": "_addComponentAt: The component to add must be a constructor",
      "3812": "_addComponentAt: Index out of range",
      "3813": "removeComponent: Component must be non-nil",
      "3814": "Argument must be non-nil",
      "3815": "Component not owned by this entity",
      "3816": "Node '%s' is already activating",
      "3817": "Sorry, the component of '%s' which with an index of %s is corrupted! It has been removed.",
      "3818": "Failed to read or parse project.json",
      "3819": "Warning: target element is not a DIV or CANVAS",
      "3820": "The renderer doesn't support the renderMode %s",
      "3821": "Cannot change hierarchy while activating or deactivating the parent.",
      "3900": "Invalid clip to add",
      "3901": "Invalid clip to remove",
      "3902": "clip is defaultClip, set force to true to force remove clip and animation state",
      "3903": "animation state is playing, set force to true to force stop and remove clip and animation state",
      "3904": "motion path of target [%s] in prop [%s] frame [%s] is not valid",
      "3905": "sprite frames must be an Array.",
      "3906": "Can't find easing type [%s]",
      "3907": "animator not added or already removed",
      "3908": "animation not added or already removed",
      "3912": "already-playing",
      "4000": "Sorry, the cc.Font has been modified from Raw Asset to Asset. Please load the font asset before using.",
      "4002": "_ccsg.Label._initBMFontWithString(): re-init is no longer supported",
      "4003": "Label font size can't be shirnked less than 0!",
      "4004": "force notify all fonts loaded!",
      "4011": "Property spriteFrame of Font '%s' is invalid. Using system font instead.",
      "4012": "The texture of Font '%s' must be already loaded on JSB. Using system font instead.",
      "4013": "Sorry, lineHeight of system font not supported on JSB.",
      "4100": "Property padding is deprecated, please use paddingLeft, paddingRight, paddingTop and paddingBottom instead",
      "4200": "MaskType: IMAGE_STENCIL only support WebGL mode.",
      "4201": "The alphaThreshold invalid in Canvas Mode.",
      "4202": "The inverted invalid in Canvas Mode.",
      "4300": "can not found the %s page.",
      "4400": "Invalid RichText img tag! The sprite frame name can't be found in the ImageAtlas!",
      "4600": "Script attached to '%s' is missing or invalid.",
      "4700": "The dom control is not created!",
      "4800": "unknown asset type",
      "4901": "loadRes: should not specify the extname in %s %s",
      "4902": "No need to release non-cached asset.",
      "4903": "Can not get class '%s'",
      "4914": "Resources url '%s' does not exist.",
      "4915": "Pack indices and data do not match in size",
      "4916": "Failed to download package for %s",
      "4920": "Sorry, you shouldn't use id as item identity any more, please use url or uuid instead, the current id is being set as url: (%s)",
      "4921": "Invalid pipe or invalid index provided!",
      "4922": "The pipe to be inserted is already in the pipeline!",
      "4923": "Uuid Loader: Parse asset [ %s ] failed : %s",
      "4924": "JSON Loader: Input item doesn't contain string content",
      "4925": "Uuid Loader: Deserialize asset [ %s ] failed : %s",
      "4926": "Audio Downloader: no web audio context.",
      "4927": "Audio Downloader: audio not supported on this browser!",
      "4928": "Load %s failed!",
      "4929": "Load Webp ( %s ) failed",
      "4930": "Load image ( %s ) failed",
      "4931": "Download Uuid: can not find type of raw asset[ %s ]: %s",
      "4932": 'Since v1.10, for any atlas ("%s") in the "resources" directory, it is not possible to find the contained SpriteFrames via `loadRes`, `getRes` or `releaseRes`. Load the SpriteAtlas first and then use `spriteAtlas.getSpriteFrame(name)` instead please.',
      "5000": "object already destroyed",
      "5001": "object not yet destroyed",
      "5100": "Not a plist file!",
      "5200": "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
      "5201": "browser don't support web audio",
      "5202": "This feature supports WebGL render mode only.",
      "5300": "Type of target to deserialize not matched with data: target is %s, data is %s",
      "5301": "Can not find script '%s'",
      "5302": "Can not find class '%s'",
      "5400": "'%s' is deprecated, use '%s' instead please.",
      "5401": "'%s' is deprecated, use '%s' instead please.",
      "5402": "cc.js.addon called on non-object:",
      "5403": "cc.js.mixin: arguments must be type object:",
      "5404": "The base class to extend from must be non-nil",
      "5405": "The class to extend must be non-nil",
      "5406": "Class should be extended before assigning any prototype members.",
      "5500": "'notify' can't work with 'get/set' !",
      "5501": "'notify' must work with 'default' !",
      "5502": "Invalid url of %s.%s",
      "5503": "The 'url' attribute of '%s.%s' is undefined when loading script.",
      "5504": "The 'url' type of '%s.%s' must be child class of cc.RawAsset.",
      "5505": "The 'url' type of '%s.%s' must not be child class of cc.Asset, otherwise you should use 'type: %s' instead.",
      "5506": "Can not specify 'type' attribute for '%s.%s', because its 'url' is already defined.",
      "5507": "The 'default' attribute of '%s.%s' must be an array",
      "5508": "Invalid type of %s.%s",
      "5510": "The 'type' attribute of '%s.%s' can not be 'Number', use 'Float' or 'Integer' instead please.",
      "5511": "The 'type' attribute of '%s.%s' is undefined when loading script",
      "5512": "Can not serialize '%s.%s' because the specified type is anonymous, please provide a class name or set the 'serializable' attribute of '%s.%s' to 'false'.",
      "5513": "The 'default' value of '%s.%s' should not be used with a 'get' function.",
      "5514": "The 'default' value of '%s.%s' should not be used with a 'set' function.",
      "5515": "The 'default' value of '%s.%s' can not be an constructor. Set default to null please.",
      "5516": "Property '%s.%s' must define at least one of 'default', 'get' or 'set'.",
      "5517": "'%s.%s' hides inherited property '%s.%s'. To make the current property override that implementation, add the `override: true` attribute please.",
      "5600": "Argument must be non-nil",
      "5601": "Can not get current scene.",
      "5602": "Scene is destroyed",
      "5603": "reference node is destroyed",
      "5700": "no %s or %s on %s",
      "5800": "%s.lerp not yet implemented.",
      "5801": "%s.clone not yet implemented.",
      "5802": "%s.equals not yet implemented.",
      "5900": "MotionStreak only support WebGL mode.",
      "5901": "cc.MotionStreak.getOpacity has not been supported.",
      "5902": "cc.MotionStreak.setOpacity has not been supported.",
      "6000": "Custom should not be false if file is not specified.",
      "6001": "The new %s must not be NaN",
      "6008": "_ccsg.ParticleSystem.initWithFile(): Particles: file not found",
      "6009": "_ccsg.ParticleSystem.initWithDictionary(): Invalid emitterType in config file",
      "6010": "_ccsg.ParticleSystem: error decoding or ungzipping textureImageData",
      "6011": "_ccsg.ParticleSystem: unknown image format with Data",
      "6012": "_ccsg.ParticleSystem.initWithDictionary() : error loading the texture",
      "6013": "Particle system: not enough memory",
      "6015": "_ccsg.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets",
      "6017": "Incomplete or corrupt PNG file",
      "6018": "Invalid filter algorithm: %s",
      "6019": "Invalid byte order value.",
      "6020": "You forgot your towel!",
      "6021": "Unknown Field Tag: %s",
      "6022": "Too many bits requested",
      "6023": "No bits requested",
      "6024": "Cannot recover from missing StripByteCounts",
      "6025": "Cannot handle sub-byte bits per sample",
      "6026": "Cannot handle sub-byte bits per pixel",
      "6027": "Palette image missing color map",
      "6028": "Unknown Photometric Interpretation: %s",
      "6029": "Unkown error",
      "6200": "Canvas doesn't support mesh slot!",
      "6300": "only cc.DrawNode is accepted as stencil",
      "6301": "Stencil buffer is not enabled.",
      "6302": "Nesting more than %d stencils is not supported. Everything will be drawn without stencil for this node and its children.",
      "6400": "asset.url is not usable in core process",
      "6401": "asset.urls is not usable in core process",
      "6402": "AssetLibrary has already been initialized!",
      "6500": "Widget target must be one of the parent nodes of it",
      "6600": "collider not added or already removed",
      "6601": "Can't find testFunc for (%s, $s).",
      "6700": "Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time",
      "6701": "Should not add Canvas to a node which already contains a renderer component (%s).",
      "6702": "Should not add Canvas to a node which size is already used by its other component.",
      "6703": "Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext",
      "6704": "Polygon's point must greater than 2",
      "6705": "Argument must be non-nil",
      "6800": "Callback of event must be non-nil",
      "6801": "The message must be provided",
      "6900": "The thing you want to instantiate must be an object",
      "6901": "The thing you want to instantiate is nil",
      "6902": "The thing you want to instantiate is destroyed",
      "6903": "The instantiate method for given asset do not implemented",
      "6904": "Can not instantiate array",
      "6905": "Can not instantiate DOM element",
      "7000": "Failed to init asset's raw path.",
      "7001": "Should not load '%s' from script dynamically, unless it is placed in the 'resources' folder.",
      "7002": "Sorry can not load '%s' because it is not placed in the 'resources' folder.",
      "7003": "Failed to init builtin asset's raw path.",
      "7100": "%s already defined in Enum.",
      "7101": "Sorry, 'cc.Enum' not available on this platform, please report this error here: https://github.com/cocos-creator/engine/issues/new",
      "7200": "Method 'initWithTMXFile' is no effect now, please set property 'tmxAsset' instead.",
      "7201": "Method 'initWithXML' is no effect now, please set property 'tmxAsset' instead.",
      "7202": "Add component TiledLayer into node failed.",
      "7203": "Property 'mapLoaded' is unused now. Please write the logic to the callback 'start'.",
      "7204": "_ccsg.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released",
      "7205": "_ccsg.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released",
      "7206": "_ccsg.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released",
      "7207": "_ccsg.TMXLayer.setTileGID(): invalid gid: %s",
      "7208": "_ccsg.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released",
      "7209": "_ccsg.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released",
      "7210": "TMX Hexa zOrder not supported",
      "7211": "TMX invalid value",
      "7212": "_ccsg.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename.",
      "7213": "_ccsg.TMXTiledMap.initWithXML(): Map not found. Please check the filename.",
      "7214": "propertiesForGID is deprecated. Please use getPropertiesForGID instead.",
      "7215": "cocos2d: Warning: TMX Layer %s has no tiles",
      "7216": "cocos2d: TMXFormat: Unsupported TMX version: %s",
      "7217": "cocos2d: TMXFomat: Unsupported orientation: %s",
      "7218": "cc.TMXMapInfo.parseXMLFile(): unsupported compression method",
      "7219": "cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported",
      "7221": "cc.TMXMapInfo.parseXMLFile(): Texture '%s' not found.",
      "7222": "Parse %s failed.",
      "7223": "_ccsg.TMXLayer.setTileGID(): pos should be non-null",
      "7224": "_ccsg.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.",
      "7225": "_ccsg.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.",
      "7226": "_ccsg.TMXLayer.getTileAt(): pos should be non-null",
      "7227": "_ccsg.TMXLayer.getTileAt(): invalid position",
      "7228": "_ccsg.TMXLayer.getTileGIDAt(): pos should be non-null",
      "7229": "_ccsg.TMXLayer.getTileGIDAt(): invalid position",
      "7230": "_ccsg.TMXLayer.setTileGID(): pos should be non-null",
      "7231": "_ccsg.TMXLayer.setTileGID(): invalid position",
      "7232": "_ccsg.TMXLayer.getTileFlagsAt(): pos should be non-null",
      "7233": "_ccsg.TMXLayer.getTileFlagsAt(): invalid position",
      "7234": "_ccsg.TMXLayer.removeTileAt(): pos should be non-null",
      "7235": "_ccsg.TMXLayer.removeTileAt(): invalid position",
      "7401": "Failed to set _defaultArmatureIndex for '%s' because the index is out of range.",
      "7402": "Failed to set _animationIndex for '%s' because the index is out of range.",
      "7501": "Failed to set _defaultSkinIndex for '%s' because the index is out of range.",
      "7502": "Failed to set _animationIndex for '%s' because its skeletonData is invalid.",
      "7503": "Failed to set _animationIndex for '%s' because the index is out of range.",
      "7504": "Can not render dynamic created SkeletonData",
      "7505": "Invalid type of atlasFile, atlas should be registered as raw asset.",
      "7506": "Failed to load spine atlas '$s'",
      "7507": "Please re-import '%s' because its textures is not initialized! (This workflow will be improved in the future.)",
      "7508": "The atlas asset of '%s' is not exists!",
      "7509": "Spine: Animation not found: %s",
      "7510": "Spine: Animation not found: %s",
      "7600": "The context of RenderTexture is invalid.",
      "7601": "cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;",
      "7602": "Could not attach texture to the framebuffer",
      "7603": "clearDepth isn't supported on Cocos2d-Html5",
      "7604": "saveToFile isn't supported on Cocos2d-Html5",
      "7605": "newCCImage isn't supported on Cocos2d-Html5",
      "7700": "On the web is always keep the aspect ratio",
      "7701": "Can't know status",
      "7702": "Video player's duration is not ready to get now!",
      "7800": "Web does not support loading",
      "7801": "Web does not support query history",
      "7802": "Web does not support query history",
      "7803": "The current browser does not support the GoBack",
      "7804": "The current browser does not support the GoForward",
      "7805": "Web does not support zoom",
      "7900": "cc.math.Matrix3.assign(): current matrix equals matIn",
      "7901": "cc.math.mat4Assign(): pOut equals pIn",
      "7902": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      "7903": "cc.math.Matrix4 equal: pMat1 and pMat2 are same object.",
      "7904": "cc.math.Matrix4.extractPlane: Invalid plane index",
      "7905": "cc.math.mat4Assign(): pOut equals pIn",
      "7906": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      "7907": "cc.math.Matrix4 equals: pMat1 and pMat2 are same object.",
      "7908": "Invalid matrix mode specified",
      "7909": "current quaternion is an invalid value",
      "8000": "Can't handle this field type or size",
      "8001": "No bytes requested",
      "8002": "Too many bytes requested",
      "8003": "Missing StripByteCounts!",
      "8100": "cocos2d: ERROR: Failed to compile shader:\n %s",
      "8101": "cocos2d: ERROR: Failed to compile vertex shader",
      "8102": "cocos2d: ERROR: Failed to compile fragment shader",
      "8103": "cc.GLProgram.link(): Cannot link invalid program",
      "8104": "cocos2d: ERROR: Failed to link program: %s",
      "8105": "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
      "8106": "Please load the resource firset : %s",
      "8107": "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null",
      "8108": "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized",
      "8109": "modelView matrix is undefined.",
      "8200": "Please set node's active instead of rigidbody's enabled.",
      "8300": "Should only one camera exists, please check your project.",
      "8301": "Camera does not support Canvas Mode.",
      "8400": "Wrong type arguments, 'filePath' must be a String.",
      "8401": "Since 1.10, `%s` accept %s instance directly, not a URL string. Please directly reference the %s object in your script, or load %s by loader first. Don't use %s's URL anymore.",
      "0100": "%s not yet implemented."
    };
  }), {} ],
  4: [ (function(require, module, exports) {
    cc.ClippingNode = _ccsg.Node.extend({
      inverted: false,
      _alphaThreshold: 0,
      _stencil: null,
      _className: "ClippingNode",
      _originStencilProgram: null,
      ctor: function(stencil) {
        stencil = stencil || null;
        _ccsg.Node.prototype.ctor.call(this);
        this._stencil = stencil;
        stencil && (this._originStencilProgram = stencil.getShaderProgram());
        this.alphaThreshold = 1;
        this.inverted = false;
        this._renderCmd.initStencilBits();
      },
      onEnter: function() {
        _ccsg.Node.prototype.onEnter.call(this);
        this._stencil && this._stencil.performRecursive(_ccsg.Node.performType.onEnter);
      },
      onEnterTransitionDidFinish: function() {
        _ccsg.Node.prototype.onEnterTransitionDidFinish.call(this);
        this._stencil && this._stencil.performRecursive(_ccsg.Node.performType.onEnterTransitionDidFinish);
      },
      onExitTransitionDidStart: function() {
        this._stencil && this._stencil.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
        _ccsg.Node.prototype.onExitTransitionDidStart.call(this);
      },
      onExit: function() {
        this._stencil && this._stencil.performRecursive(_ccsg.Node.performType.onExit);
        _ccsg.Node.prototype.onExit.call(this);
      },
      visit: function(parent) {
        this._renderCmd.clippingVisit(parent && parent._renderCmd);
      },
      _visitChildren: function() {
        this._reorderChildDirty && this.sortAllChildren();
        var children = this._children, child;
        for (var i = 0, len = children.length; i < len; i++) {
          child = children[i];
          child && child._visible && child.visit(this);
        }
        this._renderCmd._dirtyFlag = 0;
      },
      getAlphaThreshold: function() {
        return this._alphaThreshold;
      },
      setAlphaThreshold: function(alphaThreshold) {
        1 === alphaThreshold && alphaThreshold !== this._alphaThreshold && this._renderCmd.resetProgramByStencil();
        this._alphaThreshold = alphaThreshold;
      },
      isInverted: function() {
        return this.inverted;
      },
      setInverted: function(inverted) {
        this.inverted = inverted;
      },
      getStencil: function() {
        return this._stencil;
      },
      setStencil: function(stencil) {
        if (this._stencil === stencil) return;
        stencil && (this._originStencilProgram = stencil.getShaderProgram());
        this._renderCmd.setStencil(stencil);
      },
      _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ClippingNode.CanvasRenderCmd(this) : new cc.ClippingNode.WebGLRenderCmd(this);
      }
    });
    cc.ClippingNode.stencilBits = -1;
    var _p = cc.ClippingNode.prototype;
    cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil);
    cc.defineGetterSetter(_p, "alphaThreshold", _p.getAlphaThreshold, _p.setAlphaThreshold);
  }), {} ],
  5: [ (function(require, module, exports) {
    require("../shape-nodes/CCDrawNode");
    cc.ClippingNode.CanvasRenderCmd = function(renderable) {
      this._rootCtor(renderable);
      this._needDraw = false;
      this._rendererClipCmd = new cc.CustomRenderCmd(this, this._drawStencilCommand);
      this._rendererRestoreCmd = new cc.CustomRenderCmd(this, this._restoreCmdCallback);
    };
    var proto = cc.ClippingNode.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
    proto.constructor = cc.ClippingNode.CanvasRenderCmd;
    proto.resetProgramByStencil = function() {};
    proto.initStencilBits = function() {};
    proto.setStencil = function(stencil) {
      if (null == stencil) return;
      this._node._stencil = stencil;
      stencil instanceof cc.DrawNode || cc.errorID(6300);
    };
    proto._restoreCmdCallback = function(ctx) {
      var wrapper = ctx || cc._renderContext;
      wrapper.restore();
    };
    proto._drawStencilCommand = function(ctx, scaleX, scaleY) {
      var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
      wrapper.save();
      context.beginPath();
      wrapper.setTransform(this._worldTransform, scaleX, scaleY);
      var stencilBuffer = this._node._stencil._buffer;
      for (var index = 0; index < stencilBuffer.length; ++index) {
        var vertices = stencilBuffer[index].verts;
        if (vertices.length < 3) continue;
        context.moveTo(vertices[0].x, -vertices[0].y);
        for (var vIndex = 1; vIndex < vertices.length; ++vIndex) context.lineTo(vertices[vIndex].x, -vertices[vIndex].y);
      }
      context.clip();
    };
    proto.clippingVisit = function(parentCmd) {
      var node = this._node;
      parentCmd = parentCmd || this.getParentRenderCmd();
      this._propagateFlagsDown(parentCmd);
      if (!node._visible) return;
      parentCmd && (this._curLevel = parentCmd._curLevel + 1);
      this._syncStatus(parentCmd);
      node._stencil && cc.renderer.pushRenderCommand(this._rendererClipCmd);
      var children = node._children;
      var i, len = children.length;
      if (len > 0) {
        node.sortAllChildren();
        for (i = 0; i < len; i++) children[i].visit(node);
      }
      node._stencil && cc.renderer.pushRenderCommand(this._rendererRestoreCmd);
      this._dirtyFlag = 0;
    };
  }), {
    "../shape-nodes/CCDrawNode": 171
  } ],
  6: [ (function(require, module, exports) {
    require("../core/CCDrawingPrimitives");
    function setProgram(node, program) {
      node.shaderProgram = program;
      var children = node.children;
      if (!children) return;
      for (var i = 0; i < children.length; i++) setProgram(children[i], program);
    }
    var _currentState = {
      stencilEnabled: false,
      depthWriteMask: true
    };
    cc.ClippingNode.WebGLRenderCmd = function(renderable) {
      this._rootCtor(renderable);
      this._needDraw = false;
      this._beforeVisitCmd = new cc.CustomRenderCmd(this, this._onBeforeVisit);
      this._afterDrawStencilCmd = new cc.CustomRenderCmd(this, this._onAfterDrawStencil);
      this._afterVisitCmd = new cc.CustomRenderCmd(this, this._onAfterVisit);
      this._previousState = null;
      this._state = {
        stencilEnabled: true,
        stencilWriteMask: 0,
        depthWriteMask: false,
        stencilFunc: 0,
        stencilRef: 0,
        stencilValueMask: 0
      };
    };
    var proto = cc.ClippingNode.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
    proto.constructor = cc.ClippingNode.WebGLRenderCmd;
    cc.ClippingNode.WebGLRenderCmd._init_once = null;
    cc.ClippingNode.WebGLRenderCmd._visit_once = null;
    cc.ClippingNode.WebGLRenderCmd._layer = -1;
    proto.initStencilBits = function() {
      cc.ClippingNode.WebGLRenderCmd._init_once = true;
      if (cc.ClippingNode.WebGLRenderCmd._init_once) {
        cc.ClippingNode.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS);
        cc.ClippingNode.stencilBits <= 0 && cc.logID(6301);
        cc.ClippingNode.WebGLRenderCmd._init_once = false;
      }
    };
    proto.transform = function(parentCmd, recursive) {
      var node = this._node;
      this.originTransform(parentCmd, recursive);
      if (node._stencil) {
        node._stencil._renderCmd.transform(this, true);
        node._stencil._dirtyFlag &= ~_ccsg.Node._dirtyFlags.transformDirty;
      }
    };
    proto.clippingVisit = function(parentCmd) {
      var node = this._node;
      parentCmd = parentCmd || this.getParentRenderCmd();
      this.visit(parentCmd);
      if (cc.ClippingNode.stencilBits < 1) {
        node._visitChildren();
        return;
      }
      if (!node._stencil || !node._stencil.visible) {
        node.inverted && node._visitChildren();
        return;
      }
      if (cc.ClippingNode.WebGLRenderCmd._layer + 1 === cc.ClippingNode.stencilBits) {
        cc.ClippingNode.WebGLRenderCmd._visit_once = true;
        if (cc.ClippingNode.WebGLRenderCmd._visit_once) {
          cc.logID(6302, cc.ClippingNode.stencilBits);
          cc.ClippingNode.WebGLRenderCmd._visit_once = false;
        }
        node._visitChildren();
        return;
      }
      cc.renderer.pushRenderCommand(this._beforeVisitCmd);
      node._stencil.visit(node);
      cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
      var locChildren = node._children;
      if (locChildren && locChildren.length > 0) {
        var childLen = locChildren.length;
        node.sortAllChildren();
        for (var i = 0; i < childLen; i++) locChildren[i].visit(node);
      }
      cc.renderer.pushRenderCommand(this._afterVisitCmd);
      this._dirtyFlag = 0;
    };
    proto.setStencil = function(stencil) {
      var node = this._node;
      node._stencil && (node._stencil._parent = null);
      node._stencil = stencil;
      node._stencil && (node._stencil._parent = node);
    };
    proto._drawFullScreenQuadClearStencil = function() {
      var projStack = cc.math.projection_matrix_stack;
      projStack.push();
      projStack.top.identity();
      var modelViewStack = cc.math.modelview_matrix_stack;
      modelViewStack.push();
      modelViewStack.top.identity();
      cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255));
      projStack.pop();
      modelViewStack.pop();
    };
    proto.resetProgramByStencil = function() {
      var node = this._node;
      if (node._stencil) {
        var program = node._originStencilProgram;
        setProgram(node._stencil, program);
      }
    };
    proto._onBeforeVisit = function(ctx) {
      var gl = ctx || cc._renderContext, node = this._node;
      cc.ClippingNode.WebGLRenderCmd._layer++;
      var mask_layer = 1 << cc.ClippingNode.WebGLRenderCmd._layer;
      var mask_layer_l = mask_layer - 1;
      var mask_layer_le = mask_layer | mask_layer_l;
      this._previousState = _currentState;
      gl.enable(gl.STENCIL_TEST);
      gl.stencilMask(mask_layer);
      gl.depthMask(false);
      gl.stencilFunc(gl.NEVER, mask_layer, mask_layer);
      gl.stencilOp(this._node.inverted ? gl.REPLACE : gl.ZERO, gl.KEEP, gl.KEEP);
      this._drawFullScreenQuadClearStencil();
      gl.stencilFunc(gl.NEVER, mask_layer, mask_layer);
      gl.stencilOp(this._node.inverted ? gl.ZERO : gl.REPLACE, gl.KEEP, gl.KEEP);
      if (node.alphaThreshold < 1) {
        var program = cc.shaderCache.programForKey(cc.macro.SHADER_POSITION_TEXTURECOLORALPHATEST);
        cc.gl.useProgram(program.getProgram());
        program.setUniformLocationWith1f(cc.macro.UNIFORM_ALPHA_TEST_VALUE_S, node.alphaThreshold);
        program.setUniformLocationWithMatrix4fv(cc.macro.UNIFORM_MVMATRIX_S, cc.renderer.mat4Identity.mat);
        setProgram(node._stencil, program);
      }
      this._state.stencilWriteMask = mask_layer;
      this._state.stencilRef = this._state.stencilValueMask = mask_layer_le;
      this._state.stencilFunc = gl.NEVER;
      _currentState = this._state;
    };
    proto._onAfterDrawStencil = function(ctx) {
      var gl = ctx || cc._renderContext;
      gl.depthMask(this._previousState.depthWriteMask);
      gl.stencilFunc(gl.EQUAL, this._state.stencilRef, this._state.stencilValueMask);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
      this._state.stencilFunc = gl.EQUAL;
    };
    proto._onAfterVisit = function(ctx) {
      var gl = ctx || cc._renderContext;
      var state = this._previousState;
      if (state.stencilEnabled) {
        gl.stencilFunc(state.stencilFunc, state.stencilRef, state.stencilValueMask);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMask(state.stencilWriteMask);
      } else gl.disable(gl.STENCIL_TEST);
      _currentState = this._previousState;
      this._previousState = null;
      cc.ClippingNode.WebGLRenderCmd._layer--;
    };
  }), {
    "../core/CCDrawingPrimitives": 11
  } ],
  7: [ (function(require, module, exports) {
    cc.configuration = {
      ERROR: 0,
      STRING: 1,
      INT: 2,
      DOUBLE: 3,
      BOOLEAN: 4,
      _maxTextureSize: 0,
      _maxModelviewStackDepth: 0,
      _supportsPVRTC: false,
      _supportsNPOT: false,
      _supportsBGRA8888: false,
      _supportsDiscardFramebuffer: false,
      _supportsShareableVAO: false,
      _maxSamplesAllowed: 0,
      _maxTextureUnits: 0,
      _GlExtensions: "",
      _valueDict: {},
      _inited: false,
      _init: function() {
        var locValueDict = this._valueDict;
        locValueDict["cocos2d.x.version"] = cc.ENGINE_VERSION;
        locValueDict["cocos2d.x.compiled_with_profiler"] = false;
        locValueDict["cocos2d.x.compiled_with_gl_state_cache"] = cc.macro.ENABLE_GL_STATE_CACHE;
        this._inited = true;
      },
      getMaxTextureSize: function() {
        return this._maxTextureSize;
      },
      getMaxModelviewStackDepth: function() {
        return this._maxModelviewStackDepth;
      },
      getMaxTextureUnits: function() {
        return this._maxTextureUnits;
      },
      supportsNPOT: function() {
        return this._supportsNPOT;
      },
      supportsPVRTC: function() {
        return this._supportsPVRTC;
      },
      supportsETC: function() {
        return false;
      },
      supportsS3TC: function() {
        return false;
      },
      supportsATITC: function() {
        return false;
      },
      supportsBGRA8888: function() {
        return this._supportsBGRA8888;
      },
      supportsDiscardFramebuffer: function() {
        return this._supportsDiscardFramebuffer;
      },
      supportsShareableVAO: function() {
        return this._supportsShareableVAO;
      },
      checkForGLExtension: function(searchName) {
        return this._GlExtensions.indexOf(searchName) > -1;
      },
      getValue: function(key, default_value) {
        this._inited || this._init();
        var locValueDict = this._valueDict;
        if (locValueDict[key]) return locValueDict[key];
        return default_value;
      },
      setValue: function(key, value) {
        this._valueDict[key] = value;
      },
      gatherGPUInfo: function() {
        if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) return;
        this._inited || this._init();
        var gl = cc._renderContext;
        var locValueDict = this._valueDict;
        locValueDict["gl.vendor"] = gl.getParameter(gl.VENDOR);
        locValueDict["gl.renderer"] = gl.getParameter(gl.RENDERER);
        locValueDict["gl.version"] = gl.getParameter(gl.VERSION);
        this._GlExtensions = "";
        var extArr = gl.getSupportedExtensions();
        for (var i = 0; i < extArr.length; i++) this._GlExtensions += extArr[i] + " ";
        this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        locValueDict["gl.max_texture_size"] = this._maxTextureSize;
        this._maxTextureUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        locValueDict["gl.max_texture_units"] = this._maxTextureUnits;
        this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
        locValueDict["gl.supports_PVRTC"] = this._supportsPVRTC;
        this._supportsNPOT = true;
        locValueDict["gl.supports_NPOT"] = this._supportsNPOT;
        this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
        locValueDict["gl.supports_BGRA8888"] = this._supportsBGRA8888;
        this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
        locValueDict["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer;
        this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
        locValueDict["gl.supports_vertex_array_object"] = this._supportsShareableVAO;
        cc.checkGLErrorDebug();
      },
      loadConfigFile: function(url) {
        this._inited || this._init();
        var dict = cc.loader.getRes(url);
        if (!dict) throw new Error(cc._getError(1102, url));
        cc.assertID(dict, 1101, url);
        var getDatas = dict["data"];
        if (!getDatas) {
          cc.logID(1100, url);
          return;
        }
        for (var selKey in getDatas) this._valueDict[selKey] = getDatas[selKey];
      }
    };
  }), {} ],
  8: [ (function(require, module, exports) {
    var EventTarget = require("./event/event-target");
    var Class = require("./platform/_CCClass");
    var AutoReleaseUtils = require("./load-pipeline/auto-release-utils");
    var ComponentScheduler = require("./component-scheduler");
    var NodeActivator = require("./node-activator");
    var EventListeners = require("./event/event-listeners");
    var eventManager = require("./event-manager");
    cc.g_NumberOfDraws = 0;
    cc.Director = Class.extend({
      ctor: function() {
        var self = this;
        EventTarget.call(self);
        self._landscape = false;
        self._nextDeltaTimeZero = false;
        self._paused = false;
        self._purgeDirectorInNextLoop = false;
        self._sendCleanupToScene = false;
        self._animationInterval = 0;
        self._oldAnimationInterval = 0;
        self._projection = 0;
        self._projectionDelegate = null;
        self._contentScaleFactor = 1;
        self._winSizeInPoints = null;
        self._openGLView = null;
        self._scenesStack = null;
        self._nextScene = null;
        self._loadingScene = "";
        self._runningScene = null;
        self._scene = null;
        self._totalFrames = 0;
        self._lastUpdate = Date.now();
        self._deltaTime = 0;
        self._dirtyRegion = null;
        self._scheduler = null;
        self._compScheduler = null;
        self._nodeActivator = null;
        self._actionManager = null;
        cc.game.on(cc.game.EVENT_SHOW, (function() {
          self._lastUpdate = Date.now();
        }));
      },
      init: function() {
        this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS;
        this._scenesStack = [];
        this._projection = cc.Director.PROJECTION_DEFAULT;
        this._projectionDelegate = null;
        this._totalFrames = 0;
        this._lastUpdate = Date.now();
        this._paused = false;
        this._purgeDirectorInNextLoop = false;
        this._winSizeInPoints = cc.size(0, 0);
        this._openGLView = null;
        this._contentScaleFactor = 1;
        this._scheduler = new cc.Scheduler();
        if (cc.ActionManager) {
          this._actionManager = new cc.ActionManager();
          this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        } else this._actionManager = null;
        this.sharedInit();
        return true;
      },
      sharedInit: function() {
        this._compScheduler = new ComponentScheduler();
        this._nodeActivator = new NodeActivator();
        if (cc.AnimationManager) {
          this._animationManager = new cc.AnimationManager();
          this._scheduler.scheduleUpdate(this._animationManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        } else this._animationManager = null;
        if (cc.CollisionManager) {
          this._collisionManager = new cc.CollisionManager();
          this._scheduler.scheduleUpdate(this._collisionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        } else this._collisionManager = null;
        if (cc.PhysicsManager) {
          this._physicsManager = new cc.PhysicsManager();
          this._scheduler.scheduleUpdate(this._physicsManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        } else this._physicsManager = null;
        cc._widgetManager && cc._widgetManager.init(this);
        cc.loader.init(this);
      },
      calculateDeltaTime: function() {
        var now = Date.now();
        if (this._nextDeltaTimeZero) {
          this._deltaTime = 0;
          this._nextDeltaTimeZero = false;
        } else {
          this._deltaTime = (now - this._lastUpdate) / 1e3;
          cc.game.config[cc.game.CONFIG_KEY.debugMode] > 0 && this._deltaTime > 1 && (this._deltaTime = 1 / 60);
        }
        this._lastUpdate = now;
      },
      convertToGL: function(uiPoint) {
        var container = cc.game.container;
        var view = cc.view;
        var box = container.getBoundingClientRect();
        var left = box.left + window.pageXOffset - container.clientLeft;
        var top = box.top + window.pageYOffset - container.clientTop;
        var x = view._devicePixelRatio * (uiPoint.x - left);
        var y = view._devicePixelRatio * (top + box.height - uiPoint.y);
        return view._isRotated ? cc.v2(view._viewportRect.width - y, x) : cc.v2(x, y);
      },
      convertToUI: function(glPoint) {
        var container = cc.game.container;
        var view = cc.view;
        var box = container.getBoundingClientRect();
        var left = box.left + window.pageXOffset - container.clientLeft;
        var top = box.top + window.pageYOffset - container.clientTop;
        var uiPoint = cc.v2(0, 0);
        if (view._isRotated) {
          uiPoint.x = left + glPoint.y / view._devicePixelRatio;
          uiPoint.y = top + box.height - (view._viewPortRect.width - glPoint.x) / view._devicePixelRatio;
        } else {
          uiPoint.x = left + glPoint.x * view._devicePixelRatio;
          uiPoint.y = top + box.height - glPoint.y * view._devicePixelRatio;
        }
        return uiPoint;
      },
      _visitScene: function() {
        if (this._runningScene) {
          var renderer = cc.renderer;
          if (renderer.childrenOrderDirty) {
            renderer.clearRenderCommands();
            cc.renderer.assignedZ = 0;
            this._runningScene._renderCmd._curLevel = 0;
            this._runningScene.visit();
            renderer.resetFlag();
          } else renderer.transformDirty() && renderer.transform();
        }
      },
      end: function() {
        this._purgeDirectorInNextLoop = true;
      },
      getContentScaleFactor: function() {
        return this._contentScaleFactor;
      },
      getWinSize: function() {
        return cc.size(this._winSizeInPoints);
      },
      getWinSizeInPixels: function() {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor);
      },
      getVisibleSize: null,
      getVisibleOrigin: null,
      getZEye: null,
      pause: function() {
        if (this._paused) return;
        this._oldAnimationInterval = this._animationInterval;
        this.setAnimationInterval(.25);
        this._paused = true;
      },
      popScene: function() {
        cc.assertID(this._runningScene, 1204);
        this._scenesStack.pop();
        var c = this._scenesStack.length;
        if (0 === c) this.end(); else {
          this._sendCleanupToScene = true;
          this._nextScene = this._scenesStack[c - 1];
        }
      },
      purgeCachedData: function() {
        cc.textureCache._clear();
        cc.loader.releaseAll();
      },
      purgeDirector: function() {
        this.getScheduler().unscheduleAll();
        this._compScheduler.unscheduleAll();
        this._nodeActivator.reset();
        eventManager && eventManager.setEnabled(false);
        if (this._runningScene) {
          this._runningScene.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
          this._runningScene.performRecursive(_ccsg.Node.performType.onExit);
          this._runningScene.performRecursive(_ccsg.Node.performType.cleanup);
          cc.renderer.clearRenderCommands();
        }
        this._runningScene = null;
        this._nextScene = null;
        this._scenesStack.length = 0;
        this.stopAnimation();
        this.purgeCachedData();
        false;
      },
      reset: function() {
        this.purgeDirector();
        eventManager && eventManager.setEnabled(true);
        this._actionManager && this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._animationManager && this._scheduler.scheduleUpdate(this._animationManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._collisionManager && this._scheduler.scheduleUpdate(this._collisionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._physicsManager && this._scheduler.scheduleUpdate(this._physicsManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this.startAnimation();
      },
      pushScene: function(scene) {
        cc.assertID(scene, 1205);
        this._sendCleanupToScene = false;
        this._scenesStack.push(scene);
        this._nextScene = scene;
      },
      runSceneImmediate: function(scene, onBeforeLoadScene, onLaunched) {
        if (scene instanceof cc.Scene) {
          (true, true) && console.time("InitScene");
          scene._load();
          (true, true) && console.timeEnd("InitScene");
        }
        var game = cc.game;
        var persistNodeList = Object.keys(game._persistRootNodes).map((function(x) {
          return game._persistRootNodes[x];
        }));
        for (var _i = 0; _i < persistNodeList.length; _i++) {
          var node = persistNodeList[_i];
          game._ignoreRemovePersistNode = node;
          node.parent = null;
          game._ignoreRemovePersistNode = null;
        }
        var oldScene = this._scene;
        true;
        (true, true) && console.time("AutoRelease");
        var autoReleaseAssets = oldScene && oldScene.autoReleaseAssets && oldScene.dependAssets;
        AutoReleaseUtils.autoRelease(autoReleaseAssets, scene.dependAssets, persistNodeList);
        (true, true) && console.timeEnd("AutoRelease");
        (true, true) && console.time("Destroy");
        cc.isValid(oldScene) && oldScene.destroy();
        this._scene = null;
        cc.Object._deferredDestroy();
        (true, true) && console.timeEnd("Destroy");
        onBeforeLoadScene && onBeforeLoadScene();
        this.emit(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, scene);
        var sgScene = scene;
        if (scene instanceof cc.Scene) {
          this._scene = scene;
          sgScene = scene._sgNode;
          (true, true) && console.time("AttachPersist");
          for (var _i2 = 0; _i2 < persistNodeList.length; _i2++) {
            var _node = persistNodeList[_i2];
            var existNode = scene.getChildByUuid(_node.uuid);
            if (existNode) {
              var index = existNode.getSiblingIndex();
              existNode._destroyImmediate();
              scene.insertChild(_node, index);
            } else _node.parent = scene;
          }
          (true, true) && console.timeEnd("AttachPersist");
          (true, true) && console.time("Activate");
          scene._activate();
          (true, true) && console.timeEnd("Activate");
        }
        if (this._runningScene) {
          var i = this._scenesStack.length;
          this._scenesStack[Math.max(i - 1, 0)] = sgScene;
          this._sendCleanupToScene = true;
          this._nextScene = sgScene;
        } else {
          this.pushScene(sgScene);
          this.startAnimation();
        }
        this._nextScene && this.setNextScene();
        onLaunched && onLaunched(null, scene);
        this.emit(cc.Director.EVENT_AFTER_SCENE_LAUNCH, scene);
      },
      runScene: function(scene, onBeforeLoadScene, onLaunched) {
        cc.assertID(scene, 1205);
        scene instanceof cc.Scene && scene._load();
        this.once(cc.Director.EVENT_AFTER_UPDATE, (function() {
          this.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
        }));
      },
      _getSceneUuid: function(key) {
        var scenes = cc.game._sceneInfos;
        if ("string" === typeof key) {
          key.endsWith(".fire") || (key += ".fire");
          "/" === key[0] || key.startsWith("db://assets/") || (key = "/" + key);
          for (var i = 0; i < scenes.length; i++) {
            var info = scenes[i];
            if (info.url.endsWith(key)) return info;
          }
        } else if ("number" === typeof key) {
          if (0 <= key && key < scenes.length) return scenes[key];
          cc.errorID(1206, key);
        } else cc.errorID(1207, key);
        return null;
      },
      loadScene: function(sceneName, onLaunched, _onUnloaded) {
        if (this._loadingScene) {
          cc.errorID(1208, sceneName, this._loadingScene);
          return false;
        }
        var info = this._getSceneUuid(sceneName);
        if (info) {
          var uuid = info.uuid;
          this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
          this._loadingScene = sceneName;
          var self;
          var groupName;
          var ensureAsync;
          false;
          this._loadSceneByUuid(uuid, onLaunched, _onUnloaded);
          return true;
        }
        cc.errorID(1209, sceneName);
        return false;
      },
      preloadScene: function(sceneName, onLoaded) {
        var info = this._getSceneUuid(sceneName);
        if (info) {
          this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
          cc.loader.load({
            uuid: info.uuid,
            type: "uuid"
          }, (function(error, asset) {
            error && cc.errorID(1210, sceneName, error.message);
            onLoaded && onLoaded(error, asset);
          }));
        } else {
          var error = 'Can not preload the scene "' + sceneName + '" because it is not in the build settings.';
          onLoaded(new Error(error));
          cc.error("preloadScene: " + error);
        }
      },
      _loadSceneByUuid: function(uuid, onLaunched, onUnloaded, dontRunScene) {
        false;
        console.time("LoadScene " + uuid);
        cc.AssetLibrary.loadAsset(uuid, (function(error, sceneAsset) {
          console.timeEnd("LoadScene " + uuid);
          var self = cc.director;
          self._loadingScene = "";
          if (error) {
            error = "Failed to load scene: " + error;
            cc.error(error);
          } else {
            if (sceneAsset instanceof cc.SceneAsset) {
              var scene = sceneAsset.scene;
              scene._id = sceneAsset._uuid;
              scene._name = sceneAsset._name;
              false;
              self.runSceneImmediate(scene, onUnloaded, onLaunched);
              return;
            }
            error = "The asset " + uuid + " is not a scene";
            cc.error(error);
          }
          onLaunched && onLaunched(error);
        }));
      },
      resume: function() {
        if (!this._paused) return;
        this.setAnimationInterval(this._oldAnimationInterval);
        this._lastUpdate = Date.now();
        this._lastUpdate || cc.logID(1200);
        this._paused = false;
        this._deltaTime = 0;
      },
      setContentScaleFactor: function(scaleFactor) {
        scaleFactor !== this._contentScaleFactor && (this._contentScaleFactor = scaleFactor);
      },
      setDepthTest: null,
      setClearColor: null,
      setDefaultValues: function() {},
      setNextDeltaTimeZero: function(nextDeltaTimeZero) {
        this._nextDeltaTimeZero = nextDeltaTimeZero;
      },
      setNextScene: function() {
        var runningIsTransition = false, newIsTransition = false;
        if (cc.TransitionScene) {
          runningIsTransition = !!this._runningScene && this._runningScene instanceof cc.TransitionScene;
          newIsTransition = !!this._nextScene && this._nextScene instanceof cc.TransitionScene;
        }
        if (!newIsTransition) {
          var locRunningScene = this._runningScene;
          if (locRunningScene) {
            locRunningScene.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
            locRunningScene.performRecursive(_ccsg.Node.performType.onExit);
          }
          this._sendCleanupToScene && locRunningScene && locRunningScene.performRecursive(_ccsg.Node.performType.cleanup);
        }
        this._runningScene = this._nextScene;
        cc.renderer.childrenOrderDirty = true;
        this._nextScene = null;
        if (!runningIsTransition && null !== this._runningScene) {
          this._runningScene.performRecursive(_ccsg.Node.performType.onEnter);
          this._runningScene.performRecursive(_ccsg.Node.performType.onEnterTransitionDidFinish);
        }
      },
      getDelegate: function() {
        return this._projectionDelegate;
      },
      setDelegate: function(delegate) {
        this._projectionDelegate = delegate;
      },
      setOpenGLView: null,
      setProjection: null,
      setViewport: null,
      getOpenGLView: null,
      getProjection: null,
      setAlphaBlending: null,
      isSendCleanupToScene: function() {
        return this._sendCleanupToScene;
      },
      getRunningScene: function() {
        return this._runningScene;
      },
      getScene: function() {
        return this._scene;
      },
      getAnimationInterval: function() {
        return this._animationInterval;
      },
      isDisplayStats: function() {
        return !!cc.profiler && cc.profiler.isShowingStats();
      },
      setDisplayStats: function(displayStats) {
        if (cc.profiler) {
          displayStats ? cc.profiler.showStats() : cc.profiler.hideStats();
          cc.game.config[cc.game.CONFIG_KEY.showFPS] = !!displayStats;
        }
      },
      isNextDeltaTimeZero: function() {
        return this._nextDeltaTimeZero;
      },
      isPaused: function() {
        return this._paused;
      },
      getTotalFrames: function() {
        return this._totalFrames;
      },
      popToRootScene: function() {
        this.popToSceneStackLevel(1);
      },
      popToSceneStackLevel: function(level) {
        cc.assertID(this._runningScene, 1203);
        var locScenesStack = this._scenesStack;
        var c = locScenesStack.length;
        if (0 === c) {
          this.end();
          return;
        }
        if (level > c) return;
        while (c > level) {
          var current = locScenesStack.pop();
          if (current.running) {
            current.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
            current.performRecursive(_ccsg.Node.performType.onExit);
          }
          current.performRecursive(_ccsg.Node.performType.cleanup);
          c--;
        }
        this._nextScene = locScenesStack[locScenesStack.length - 1];
        this._sendCleanupToScene = true;
      },
      getScheduler: function() {
        return this._scheduler;
      },
      setScheduler: function(scheduler) {
        this._scheduler !== scheduler && (this._scheduler = scheduler);
      },
      getActionManager: function() {
        return this._actionManager;
      },
      setActionManager: function(actionManager) {
        if (this._actionManager !== actionManager) {
          this._actionManager && this._scheduler.unscheduleUpdate(this._actionManager);
          this._actionManager = actionManager;
          this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        }
      },
      getAnimationManager: function() {
        return this._animationManager;
      },
      getCollisionManager: function() {
        return this._collisionManager;
      },
      getPhysicsManager: function() {
        return this._physicsManager;
      },
      getDeltaTime: function() {
        return this._deltaTime;
      }
    });
    cc.js.addon(cc.Director.prototype, EventTarget.prototype);
    cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
    cc.Director.EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading";
    cc.Director.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch";
    cc.Director.EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch";
    cc.Director.EVENT_BEFORE_UPDATE = "director_before_update";
    cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
    cc.Director.EVENT_BEFORE_VISIT = "director_before_visit";
    cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
    cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
    cc.DisplayLinkDirector = cc.Director.extend({
      invalid: false,
      startAnimation: function() {
        this._nextDeltaTimeZero = true;
        this.invalid = false;
      },
      mainLoop: function() {
        if (this._purgeDirectorInNextLoop) {
          this._purgeDirectorInNextLoop = false;
          this.purgeDirector();
        } else if (!this.invalid) {
          this.calculateDeltaTime();
          if (!this._paused) {
            this.emit(cc.Director.EVENT_BEFORE_UPDATE);
            this._compScheduler.startPhase();
            this._compScheduler.updatePhase(this._deltaTime);
            this._scheduler.update(this._deltaTime);
            this._compScheduler.lateUpdatePhase(this._deltaTime);
            this.emit(cc.Director.EVENT_AFTER_UPDATE);
            cc.Object._deferredDestroy();
          }
          this._nextScene && this.setNextScene();
          this.emit(cc.Director.EVENT_BEFORE_VISIT);
          this._visitScene();
          this.emit(cc.Director.EVENT_AFTER_VISIT);
          cc.g_NumberOfDraws = 0;
          cc.renderer.clear();
          cc.renderer.rendering(cc._renderContext);
          this._totalFrames++;
          this.emit(cc.Director.EVENT_AFTER_DRAW);
          eventManager.frameUpdateListeners();
        }
      },
      stopAnimation: function() {
        this.invalid = true;
      },
      setAnimationInterval: function(value) {
        this._animationInterval = value;
        if (!this.invalid) {
          this.stopAnimation();
          this.startAnimation();
        }
      },
      __fastOn: function(type, callback, target) {
        var listeners = this._bubblingListeners;
        listeners || (listeners = this._bubblingListeners = new EventListeners());
        listeners.add(type, callback, target);
        this._addEventFlag(type, listeners, false);
      },
      __fastOff: function(type, callback, target) {
        var listeners = this._bubblingListeners;
        if (listeners) {
          listeners.remove(type, callback, target);
          this._purgeEventFlag(type, listeners, false);
        }
      }
    });
    cc.Director.sharedDirector = null;
    cc.Director.firstUseDirector = true;
    cc.Director._getInstance = function() {
      if (cc.Director.firstUseDirector) {
        cc.Director.firstUseDirector = false;
        cc.Director.sharedDirector = new cc.DisplayLinkDirector();
        cc.Director.sharedDirector.init();
      }
      return cc.Director.sharedDirector;
    };
    cc.defaultFPS = 60;
    cc.Director.PROJECTION_2D = 0;
    cc.Director.PROJECTION_3D = 1;
    cc.Director.PROJECTION_CUSTOM = 3;
    cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_2D;
  }), {
    "./component-scheduler": 37,
    "./event-manager": 58,
    "./event/event-listeners": 59,
    "./event/event-target": 60,
    "./load-pipeline/auto-release-utils": 73,
    "./node-activator": 86,
    "./platform/_CCClass": 100
  } ],
  9: [ (function(require, module, exports) {
    require("./CCDirector");
    require("./CCGame");
    var eventManager = require("./event-manager");
    cc.game.once(cc.game.EVENT_RENDERER_INITED, (function() {
      if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
        var _p = cc.Director.prototype;
        _p.getProjection = function(projection) {
          return this._projection;
        };
        _p.setProjection = function(projection) {
          this._projection = projection;
          this.emit(cc.Director.EVENT_PROJECTION_CHANGED, this);
        };
        _p.setDepthTest = function() {};
        _p.setClearColor = function(clearColor) {
          cc.renderer._clearColor = clearColor;
          cc.renderer._clearFillStyle = "rgb(" + clearColor.r + "," + clearColor.g + "," + clearColor.b + ")";
        };
        _p.setOpenGLView = function(openGLView) {
          this._winSizeInPoints.width = cc._canvas.width;
          this._winSizeInPoints.height = cc._canvas.height;
          this._openGLView = openGLView || cc.view;
          eventManager && eventManager.setEnabled(true);
        };
        _p.getVisibleSize = function() {
          return this.getWinSize();
        };
        _p.getVisibleOrigin = function() {
          return cc.p(0, 0);
        };
      }
    }));
  }), {
    "./CCDirector": 8,
    "./CCGame": 14,
    "./event-manager": 58
  } ],
  10: [ (function(require, module, exports) {
    require("./CCDirector");
    require("./CCGame");
    require("../kazmath");
    var eventManager = require("./event-manager");
    var math = cc.math;
    cc.game.once(cc.game.EVENT_RENDERER_INITED, (function() {
      if (cc._renderType !== cc.game.RENDER_TYPE_WEBGL) return;
      cc.DirectorDelegate = cc._Class.extend({
        updateProjection: function() {}
      });
      var _p = cc.Director.prototype;
      var recursiveChild = function(node) {
        if (node && node._renderCmd) {
          node._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
          var i, children = node._children;
          for (i = 0; i < children.length; i++) recursiveChild(children[i]);
        }
      };
      cc.Director._getInstance().on(cc.Director.EVENT_PROJECTION_CHANGED, (function() {
        var stack = cc.director._scenesStack;
        for (var i = 0; i < stack.length; i++) recursiveChild(stack[i]);
      }));
      _p.setProjection = function(projection) {
        var _t = this;
        var size = _t._winSizeInPoints;
        _t.setViewport();
        var view = _t._openGLView, ox = view._viewPortRect.x / view._scaleX, oy = view._viewPortRect.y / view._scaleY;
        switch (projection) {
         case cc.Director.PROJECTION_2D:
          math.glMatrixMode(math.KM_GL_PROJECTION);
          math.glLoadIdentity();
          var orthoMatrix = math.Matrix4.createOrthographicProjection(-ox, size.width - ox, -oy, size.height - oy, -1024, 1024);
          math.glMultMatrix(orthoMatrix);
          math.glMatrixMode(math.KM_GL_MODELVIEW);
          math.glLoadIdentity();
          break;

         case cc.Director.PROJECTION_3D:
          var zeye = _t.getZEye();
          var matrixPerspective = new math.Matrix4(), matrixLookup = new math.Matrix4();
          math.glMatrixMode(math.KM_GL_PROJECTION);
          math.glLoadIdentity();
          matrixPerspective = math.Matrix4.createPerspectiveProjection(60, size.width / size.height, .1, 2 * zeye);
          math.glMultMatrix(matrixPerspective);
          var eye = new math.Vec3(-ox + size.width / 2, -oy + size.height / 2, zeye);
          var center = new math.Vec3(-ox + size.width / 2, -oy + size.height / 2, 0);
          var up = new math.Vec3(0, 1, 0);
          matrixLookup.lookAt(eye, center, up);
          math.glMultMatrix(matrixLookup);
          math.glMatrixMode(math.KM_GL_MODELVIEW);
          math.glLoadIdentity();
          break;

         case cc.Director.PROJECTION_CUSTOM:
          _t._projectionDelegate && _t._projectionDelegate.updateProjection();
          break;

         default:
          cc.logID(1201);
        }
        _t._projection = projection;
        _t.emit(cc.Director.EVENT_PROJECTION_CHANGED, _t);
        cc.gl.setProjectionMatrixDirty();
        cc.renderer.childrenOrderDirty = true;
      };
      _p.setDepthTest = function(on) {
        cc.renderer.setDepthTest(on);
      };
      _p.setClearColor = function(clearColor) {
        var locClearColor = cc.renderer._clearColor;
        locClearColor.r = clearColor.r / 255;
        locClearColor.g = clearColor.g / 255;
        locClearColor.b = clearColor.b / 255;
        locClearColor.a = clearColor.a / 255;
      };
      _p.setOpenGLView = function(openGLView) {
        var _t = this;
        _t._winSizeInPoints.width = cc._canvas.width;
        _t._winSizeInPoints.height = cc._canvas.height;
        _t._openGLView = openGLView || cc.view;
        true;
        var conf = cc.configuration;
        conf.gatherGPUInfo();
        _t.setGLDefaultValues();
        eventManager && eventManager.setEnabled(true);
      };
      _p.getVisibleSize = function() {
        return this._openGLView.getVisibleSize();
      };
      _p.getVisibleOrigin = function() {
        return this._openGLView.getVisibleOrigin();
      };
      _p.getZEye = function() {
        return this._winSizeInPoints.height / 1.1566;
      };
      _p.setViewport = function() {
        var view = this._openGLView;
        if (view) {
          var locWinSizeInPoints = this._winSizeInPoints;
          view.setViewPortInPoints(-view._viewPortRect.x / view._scaleX, -view._viewPortRect.y / view._scaleY, locWinSizeInPoints.width, locWinSizeInPoints.height);
        }
      };
      _p.getOpenGLView = function() {
        return this._openGLView;
      };
      _p.getProjection = function() {
        return this._projection;
      };
      _p.setAlphaBlending = function(on) {
        on ? cc.gl.blendFunc(cc.macro.BLEND_SRC, cc.macro.BLEND_DST) : cc.gl.blendFunc(cc.macro.ONE, cc.macro.ZERO);
      };
      _p.setGLDefaultValues = function() {
        var _t = this;
        _t.setAlphaBlending(true);
        _t.setProjection(_t._projection);
        cc._renderContext.clearColor(0, 0, 0, 0);
      };
    }));
  }), {
    "../kazmath": 156,
    "./CCDirector": 8,
    "./CCGame": 14,
    "./event-manager": 58
  } ],
  11: [ (function(require, module, exports) {
    var game = require("./CCGame");
    cc._drawingUtil = null;
    game.once(game.EVENT_RENDERER_INITED, (function() {
      cc._renderType === game.RENDER_TYPE_WEBGL ? cc._drawingUtil = new (require("./CCDrawingPrimitivesWebGL"))(cc._renderContext) : cc._drawingUtil = new (require("./CCDrawingPrimitivesCanvas"))(cc._renderContext);
    }));
  }), {
    "./CCDrawingPrimitivesCanvas": 12,
    "./CCDrawingPrimitivesWebGL": 13,
    "./CCGame": 14
  } ],
  12: [ (function(require, module, exports) {
    var DrawingPrimitiveCanvas = cc._Class.extend({
      _cacheArray: [],
      ctor: function(renderContext) {
        this._renderContext = renderContext;
      },
      drawPoint: function(point, size) {
        size || (size = 1);
        var locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
        var newPoint = cc.p(point.x * locScaleX, point.y * locScaleY);
        var ctx = this._renderContext.getContext();
        ctx.beginPath();
        ctx.arc(newPoint.x, -newPoint.y, size * locScaleX, 0, 2 * Math.PI, false);
        ctx.closePath();
        ctx.fill();
      },
      drawPoints: function(points, numberOfPoints, size) {
        if (null == points) return;
        size || (size = 1);
        var locContext = this._renderContext.getContext(), locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
        locContext.beginPath();
        for (var i = 0, len = points.length; i < len; i++) locContext.arc(points[i].x * locScaleX, -points[i].y * locScaleY, size * locScaleX, 0, 2 * Math.PI, false);
        locContext.closePath();
        locContext.fill();
      },
      drawLine: function(origin, destination) {
        var locContext = this._renderContext.getContext(), locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
        locContext.beginPath();
        locContext.moveTo(origin.x * locScaleX, -origin.y * locScaleY);
        locContext.lineTo(destination.x * locScaleX, -destination.y * locScaleY);
        locContext.closePath();
        locContext.stroke();
      },
      drawRect: function(origin, destination) {
        this.drawLine(cc.p(origin.x, origin.y), cc.p(destination.x, origin.y));
        this.drawLine(cc.p(destination.x, origin.y), cc.p(destination.x, destination.y));
        this.drawLine(cc.p(destination.x, destination.y), cc.p(origin.x, destination.y));
        this.drawLine(cc.p(origin.x, destination.y), cc.p(origin.x, origin.y));
      },
      drawSolidRect: function(origin, destination, color) {
        var vertices = [ origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y) ];
        this.drawSolidPoly(vertices, 4, color);
      },
      drawPoly: function(vertices, numOfVertices, closePolygon, fill) {
        fill = fill || false;
        if (null == vertices) return;
        if (vertices.length < 3) throw new Error(cc._getError(6704));
        var firstPoint = vertices[0], locContext = this._renderContext.getContext();
        var locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
        locContext.beginPath();
        locContext.moveTo(firstPoint.x * locScaleX, -firstPoint.y * locScaleY);
        for (var i = 1, len = vertices.length; i < len; i++) locContext.lineTo(vertices[i].x * locScaleX, -vertices[i].y * locScaleY);
        closePolygon && locContext.closePath();
        fill ? locContext.fill() : locContext.stroke();
      },
      drawSolidPoly: function(polygons, numberOfPoints, color) {
        this.setDrawColor(color.r, color.g, color.b, color.a);
        this.drawPoly(polygons, numberOfPoints, true, true);
      },
      drawCircle: function(center, radius, angle, segments, drawLineToCenter) {
        drawLineToCenter = drawLineToCenter || false;
        var locContext = this._renderContext.getContext();
        var locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
        locContext.beginPath();
        var endAngle = angle - 2 * Math.PI;
        locContext.arc(0 | center.x * locScaleX, 0 | -center.y * locScaleY, radius * locScaleX, -angle, -endAngle, false);
        drawLineToCenter && locContext.lineTo(0 | center.x * locScaleX, 0 | -center.y * locScaleY);
        locContext.stroke();
      },
      drawQuadBezier: function(origin, control, destination, segments) {
        var vertices = this._cacheArray;
        vertices.length = 0;
        var t = 0;
        for (var i = 0; i < segments; i++) {
          var x = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
          var y = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
          vertices.push(cc.p(x, y));
          t += 1 / segments;
        }
        vertices.push(cc.p(destination.x, destination.y));
        this.drawPoly(vertices, segments + 1, false, false);
      },
      drawCubicBezier: function(origin, control1, control2, destination, segments) {
        var vertices = this._cacheArray;
        vertices.length = 0;
        var t = 0;
        for (var i = 0; i < segments; i++) {
          var x = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
          var y = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
          vertices.push(cc.p(x, y));
          t += 1 / segments;
        }
        vertices.push(cc.p(destination.x, destination.y));
        this.drawPoly(vertices, segments + 1, false, false);
      },
      drawCatmullRom: function(points, segments) {
        this.drawCardinalSpline(points, .5, segments);
      },
      drawCardinalSpline: function(config, tension, segments) {
        cc._renderContext.setStrokeStyle("rgba(255,255,255,1)");
        var points = this._cacheArray;
        points.length = 0;
        var p, lt;
        var deltaT = 1 / config.length;
        for (var i = 0; i < segments + 1; i++) {
          var dt = i / segments;
          if (1 === dt) {
            p = config.length - 1;
            lt = 1;
          } else {
            p = 0 | dt / deltaT;
            lt = (dt - deltaT * p) / deltaT;
          }
          var newPos = cc.cardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p - 0), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
          points.push(newPos);
        }
        this.drawPoly(points, segments + 1, false, false);
      },
      drawImage: function(image, sourcePoint, sourceSize, destPoint, destSize) {
        var len = arguments.length;
        var ctx = this._renderContext.getContext();
        switch (len) {
         case 2:
          var height = image.height;
          ctx.drawImage(image, sourcePoint.x, -(sourcePoint.y + height));
          break;

         case 3:
          ctx.drawImage(image, sourcePoint.x, -(sourcePoint.y + sourceSize.height), sourceSize.width, sourceSize.height);
          break;

         case 5:
          ctx.drawImage(image, sourcePoint.x, sourcePoint.y, sourceSize.width, sourceSize.height, destPoint.x, -(destPoint.y + destSize.height), destSize.width, destSize.height);
          break;

         default:
          throw new Error(cc._getError(6705));
        }
      },
      drawStar: function(ctx, radius, color) {
        var wrapper = ctx || this._renderContext;
        var context = wrapper.getContext();
        radius *= cc.view.getScaleX();
        var colorStr = "rgba(" + (0 | color.r) + "," + (0 | color.g) + "," + (0 | color.b);
        wrapper.setFillStyle(colorStr + ",1)");
        var subRadius = radius / 10;
        context.beginPath();
        context.moveTo(-radius, radius);
        context.lineTo(0, subRadius);
        context.lineTo(radius, radius);
        context.lineTo(subRadius, 0);
        context.lineTo(radius, -radius);
        context.lineTo(0, -subRadius);
        context.lineTo(-radius, -radius);
        context.lineTo(-subRadius, 0);
        context.lineTo(-radius, radius);
        context.closePath();
        context.fill();
        var rg = context.createRadialGradient(0, 0, subRadius, 0, 0, radius);
        rg.addColorStop(0, colorStr + ", 1)");
        rg.addColorStop(.3, colorStr + ", 0.8)");
        rg.addColorStop(1, colorStr + ", 0.0)");
        wrapper.setFillStyle(rg);
        context.beginPath();
        var startAngle_1 = 0;
        var endAngle_1 = cc.macro.PI2;
        context.arc(0, 0, radius - subRadius, startAngle_1, endAngle_1, false);
        context.closePath();
        context.fill();
      },
      drawColorBall: function(ctx, radius, color) {
        var wrapper = ctx || this._renderContext;
        var context = wrapper.getContext();
        radius *= cc.view.getScaleX();
        var colorStr = "rgba(" + (0 | color.r) + "," + (0 | color.g) + "," + (0 | color.b);
        var subRadius = radius / 10;
        var g1 = context.createRadialGradient(0, 0, subRadius, 0, 0, radius);
        g1.addColorStop(0, colorStr + ", 1)");
        g1.addColorStop(.3, colorStr + ", 0.8)");
        g1.addColorStop(.6, colorStr + ", 0.4)");
        g1.addColorStop(1, colorStr + ", 0.0)");
        wrapper.setFillStyle(g1);
        context.beginPath();
        var startAngle_1 = 0;
        var endAngle_1 = cc.macro.PI2;
        context.arc(0, 0, radius, startAngle_1, endAngle_1, false);
        context.closePath();
        context.fill();
      },
      fillText: function(strText, x, y) {
        this._renderContext.getContext().fillText(strText, x, -y);
      },
      setDrawColor: function(r, g, b, a) {
        this._renderContext.setFillStyle("rgba(" + r + "," + g + "," + b + "," + a / 255 + ")");
        this._renderContext.setStrokeStyle("rgba(" + r + "," + g + "," + b + "," + a / 255 + ")");
      },
      setPointSize: function(pointSize) {},
      setLineWidth: function(width) {
        this._renderContext.getContext().lineWidth = width * cc.view.getScaleX();
      }
    });
    module.exports = DrawingPrimitiveCanvas;
  }), {} ],
  13: [ (function(require, module, exports) {
    var macro = cc.macro;
    var DrawingPrimitiveWebGL = cc._Class.extend({
      _initialized: false,
      _shader: null,
      _colorLocation: "u_color",
      _pointSizeLocation: "u_pointSize",
      _pointSize: -1,
      ctor: function(ctx) {
        false;
        this._renderContext = ctx;
        this._colorArray = new Float32Array([ 1, 1, 1, 1 ]);
      },
      lazy_init: function() {
        var _t = this;
        if (!_t._initialized) {
          _t._shader = cc.shaderCache.programForKey(macro.SHADER_POSITION_UCOLOR);
          _t._shader._addUniformLocation(_t._colorLocation);
          _t._shader._addUniformLocation(_t._pointSizeLocation);
          _t._initialized = true;
        }
      },
      drawInit: function() {
        this._initialized = false;
      },
      drawPoint: function(point) {
        this.lazy_init();
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, new Float32Array([ point.x, point.y ]), glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.POINTS, 0, 1);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      drawPoints: function(points, numberOfPoints) {
        if (!points || 0 === points.length) return;
        this.lazy_init();
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray(points), glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.POINTS, 0, points.length);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      _pointsToTypeArray: function(points) {
        var typeArr = new Float32Array(2 * points.length);
        for (var i = 0; i < points.length; i++) {
          typeArr[2 * i] = points[i].x;
          typeArr[2 * i + 1] = points[i].y;
        }
        return typeArr;
      },
      drawLine: function(origin, destination) {
        this.lazy_init();
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray([ origin, destination ]), glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.LINES, 0, 2);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      drawRect: function(origin, destination) {
        this.drawLine(cc.p(origin.x, origin.y), cc.p(destination.x, origin.y));
        this.drawLine(cc.p(destination.x, origin.y), cc.p(destination.x, destination.y));
        this.drawLine(cc.p(destination.x, destination.y), cc.p(origin.x, destination.y));
        this.drawLine(cc.p(origin.x, destination.y), cc.p(origin.x, origin.y));
      },
      drawSolidRect: function(origin, destination, color) {
        var vertices = [ origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y) ];
        this.drawSolidPoly(vertices, 4, color);
      },
      drawPoly: function(vertices, numOfVertices, closePolygon) {
        this.lazy_init();
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray(vertices), glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        closePolygon ? glContext.drawArrays(glContext.LINE_LOOP, 0, vertices.length) : glContext.drawArrays(glContext.LINE_STRIP, 0, vertices.length);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      drawSolidPoly: function(poli, numberOfPoints, color) {
        this.lazy_init();
        color && this.setDrawColor(color.r, color.g, color.b, color.a);
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray(poli), glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.TRIANGLE_FAN, 0, poli.length);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      drawCircle: function(center, radius, angle, segments, drawLineToCenter) {
        this.lazy_init();
        var additionalSegment = 1;
        drawLineToCenter && additionalSegment++;
        var coef = 2 * Math.PI / segments;
        var vertices = new Float32Array(2 * (segments + 2));
        if (!vertices) return;
        for (var i = 0; i <= segments; i++) {
          var rads = i * coef;
          var j = radius * Math.cos(rads + angle) + center.x;
          var k = radius * Math.sin(rads + angle) + center.y;
          vertices[2 * i] = j;
          vertices[2 * i + 1] = k;
        }
        vertices[2 * (segments + 1)] = center.x;
        vertices[2 * (segments + 1) + 1] = center.y;
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.LINE_STRIP, 0, segments + additionalSegment);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      drawQuadBezier: function(origin, control, destination, segments) {
        this.lazy_init();
        var vertices = new Float32Array(2 * (segments + 1));
        var t = 0;
        for (var i = 0; i < segments; i++) {
          vertices[2 * i] = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
          vertices[2 * i + 1] = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
          t += 1 / segments;
        }
        vertices[2 * segments] = destination.x;
        vertices[2 * segments + 1] = destination.y;
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.LINE_STRIP, 0, segments + 1);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      drawCubicBezier: function(origin, control1, control2, destination, segments) {
        this.lazy_init();
        var vertices = new Float32Array(2 * (segments + 1));
        var t = 0;
        for (var i = 0; i < segments; i++) {
          vertices[2 * i] = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
          vertices[2 * i + 1] = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
          t += 1 / segments;
        }
        vertices[2 * segments] = destination.x;
        vertices[2 * segments + 1] = destination.y;
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.LINE_STRIP, 0, segments + 1);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      drawCatmullRom: function(points, segments) {
        this.drawCardinalSpline(points, .5, segments);
      },
      drawCardinalSpline: function(config, tension, segments) {
        this.lazy_init();
        var vertices = new Float32Array(2 * (segments + 1));
        var p, lt, deltaT = 1 / config.length;
        for (var i = 0; i < segments + 1; i++) {
          var dt = i / segments;
          if (1 === dt) {
            p = config.length - 1;
            lt = 1;
          } else {
            p = 0 | dt / deltaT;
            lt = (dt - deltaT * p) / deltaT;
          }
          var newPos = cc.cardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
          vertices[2 * i] = newPos.x;
          vertices[2 * i + 1] = newPos.y;
        }
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.LINE_STRIP, 0, segments + 1);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      setDrawColor: function(r, g, b, a) {
        this._colorArray[0] = r / 255;
        this._colorArray[1] = g / 255;
        this._colorArray[2] = b / 255;
        this._colorArray[3] = a / 255;
      },
      setPointSize: function(pointSize) {
        this._pointSize = pointSize;
      },
      setLineWidth: function(width) {
        this._renderContext.lineWidth && this._renderContext.lineWidth(width);
      }
    });
    module.exports = DrawingPrimitiveWebGL;
  }), {} ],
  14: [ (function(require, module, exports) {
    var EventTarget = require("./event/event-target");
    var View;
    true;
    View = require("./platform/CCView");
    require("../audio/CCAudioEngine");
    var inputManager = require("./platform/CCInputManager");
    var game = {
      EVENT_HIDE: "game_on_hide",
      EVENT_SHOW: "game_on_show",
      EVENT_GAME_INITED: "game_inited",
      EVENT_RENDERER_INITED: "renderer_inited",
      RENDER_TYPE_CANVAS: 0,
      RENDER_TYPE_WEBGL: 1,
      RENDER_TYPE_OPENGL: 2,
      _persistRootNodes: {},
      _ignoreRemovePersistNode: null,
      CONFIG_KEY: {
        width: "width",
        height: "height",
        debugMode: "debugMode",
        exposeClassName: "exposeClassName",
        showFPS: "showFPS",
        frameRate: "frameRate",
        id: "id",
        renderMode: "renderMode",
        registerSystemEvent: "registerSystemEvent",
        jsList: "jsList",
        scenes: "scenes"
      },
      _paused: true,
      _configLoaded: false,
      _isCloning: false,
      _prepareCalled: false,
      _prepared: false,
      _rendererInitialized: false,
      _renderContext: null,
      _intervalId: null,
      _lastTime: null,
      _frameTime: null,
      _sceneInfos: [],
      frame: null,
      container: null,
      canvas: null,
      config: null,
      onStart: null,
      setFrameRate: function(frameRate) {
        var self = this, config = self.config, CONFIG_KEY = self.CONFIG_KEY;
        config[CONFIG_KEY.frameRate] = frameRate;
        self._intervalId && window.cancelAnimFrame(self._intervalId);
        self._intervalId = 0;
        self._paused = true;
        self._setAnimFrame();
        self._runMainLoop();
      },
      step: function() {
        cc.director.mainLoop();
      },
      pause: function() {
        if (this._paused) return;
        this._paused = true;
        cc.audioEngine && cc.audioEngine._break();
        this._intervalId && window.cancelAnimFrame(this._intervalId);
        this._intervalId = 0;
      },
      resume: function() {
        if (!this._paused) return;
        this._paused = false;
        cc.audioEngine && cc.audioEngine._restore();
        this._runMainLoop();
      },
      isPaused: function() {
        return this._paused;
      },
      restart: function() {
        cc.director.once(cc.Director.EVENT_AFTER_DRAW, (function() {
          for (var id in game._persistRootNodes) game.removePersistRootNode(game._persistRootNodes[id]);
          cc.director.getScene().destroy();
          cc.Object._deferredDestroy();
          cc.director.purgeDirector();
          cc.audioEngine && cc.audioEngine.uncacheAll();
          cc.director.reset();
          game.onStart();
        }));
      },
      end: function() {
        close();
      },
      prepare: function(cb) {
        var self = this, config = self.config, CONFIG_KEY = self.CONFIG_KEY;
        if (!this._configLoaded) {
          this._loadConfig((function() {
            self.prepare(cb);
          }));
          return;
        }
        if (this._prepared) {
          cb && cb();
          return;
        }
        if (this._prepareCalled) return;
        if (cc._engineLoaded) {
          this._prepareCalled = true;
          this._initRenderer(config[CONFIG_KEY.width], config[CONFIG_KEY.height]);
          cc.view = View ? View._getInstance() : null;
          cc.director = cc.Director._getInstance();
          cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view);
          cc.winSize = cc.director.getWinSize();
          true;
          this._initEvents();
          this._setAnimFrame();
          this._runMainLoop();
          var jsList = config[CONFIG_KEY.jsList];
          if (jsList && jsList.length > 0) cc.loader.load(jsList, (function(err) {
            if (err) throw new Error(JSON.stringify(err));
            self._prepared = true;
            cb && cb();
            self.emit(self.EVENT_GAME_INITED);
          })); else {
            cb && cb();
            self.emit(self.EVENT_GAME_INITED);
          }
          return;
        }
        cc.initEngine(this.config, (function() {
          self.prepare(cb);
        }));
      },
      run: function(config, onStart) {
        if ("function" === typeof config) game.onStart = config; else {
          config && (game.config = config);
          "function" === typeof onStart && (game.onStart = onStart);
        }
        this.prepare(game.onStart && game.onStart.bind(game));
      },
      addPersistRootNode: function(node) {
        if (!cc.Node.isNode(node) || !node.uuid) {
          cc.warnID(3800);
          return;
        }
        var id = node.uuid;
        if (!this._persistRootNodes[id]) {
          var scene = cc.director._scene;
          if (cc.isValid(scene)) {
            if (node.parent) {
              if (!(node.parent instanceof cc.Scene)) {
                cc.warnID(3801);
                return;
              }
              if (node.parent !== scene) {
                cc.warnID(3802);
                return;
              }
            } else node.parent = scene;
            this._persistRootNodes[id] = node;
            node._persistNode = true;
          }
        }
      },
      removePersistRootNode: function(node) {
        if (node !== this._ignoreRemovePersistNode) {
          var id = node.uuid || "";
          if (node === this._persistRootNodes[id]) {
            delete this._persistRootNodes[id];
            node._persistNode = false;
          }
        }
      },
      isPersistRootNode: function(node) {
        return node._persistNode;
      },
      _setAnimFrame: function() {
        this._lastTime = new Date();
        var frameRate = game.config[game.CONFIG_KEY.frameRate];
        this._frameTime = 1e3 / frameRate;
        if (60 !== frameRate && 30 !== frameRate) {
          window.requestAnimFrame = this._stTime;
          window.cancelAnimFrame = this._ctTime;
        } else {
          window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime;
          window.cancelAnimFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || this._ctTime;
        }
      },
      _stTime: function(callback) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, game._frameTime - (currTime - game._lastTime));
        var id = window.setTimeout((function() {
          callback();
        }), timeToCall);
        game._lastTime = currTime + timeToCall;
        return id;
      },
      _ctTime: function(id) {
        window.clearTimeout(id);
      },
      _runMainLoop: function() {
        var self = this, callback, config = self.config, CONFIG_KEY = self.CONFIG_KEY, director = cc.director, skip = true, frameRate = config[CONFIG_KEY.frameRate];
        director.setDisplayStats(config[CONFIG_KEY.showFPS]);
        callback = function() {
          if (!self._paused) {
            self._intervalId = window.requestAnimFrame(callback);
            if (30 === frameRate && (skip = !skip)) return;
            director.mainLoop();
          }
        };
        self._intervalId = window.requestAnimFrame(callback);
        self._paused = false;
      },
      _loadConfig: function(cb) {
        if (this.config) {
          this._initConfig(this.config);
          cb && cb();
          return;
        }
        if (document["ccConfig"]) {
          this._initConfig(document["ccConfig"]);
          cb && cb();
          return;
        }
        var self = this;
        cc.loader.load("project.json", (function(err, data) {
          err && cc.logID(3818);
          self._initConfig(data || {});
          cb && cb();
        }));
      },
      _initConfig: function(config) {
        var CONFIG_KEY = this.CONFIG_KEY;
        "number" !== typeof config[CONFIG_KEY.debugMode] && (config[CONFIG_KEY.debugMode] = 0);
        config[CONFIG_KEY.exposeClassName] = !!config[CONFIG_KEY.exposeClassName];
        "number" !== typeof config[CONFIG_KEY.frameRate] && (config[CONFIG_KEY.frameRate] = 60);
        "number" !== typeof config[CONFIG_KEY.renderMode] && (config[CONFIG_KEY.renderMode] = 0);
        "boolean" !== typeof config[CONFIG_KEY.registerSystemEvent] && (config[CONFIG_KEY.registerSystemEvent] = true);
        config[CONFIG_KEY.showFPS] = !(CONFIG_KEY.showFPS in config) || !!config[CONFIG_KEY.showFPS];
        this._sceneInfos = config[CONFIG_KEY.scenes] || [];
        this.collisionMatrix = config.collisionMatrix || [];
        this.groupList = config.groupList || [];
        cc._initDebugSetting(config[CONFIG_KEY.debugMode]);
        this.config = config;
        this._configLoaded = true;
      },
      _initRenderer: function(width, height) {
        if (this._rendererInitialized) return;
        if (!cc._supportRender) throw new Error(cc._getError(3820, this.config[this.CONFIG_KEY.renderMode]));
        var el = this.config[game.CONFIG_KEY.id], win = window, localCanvas, localContainer, isWeChatGame = cc.sys.platform === cc.sys.WECHAT_GAME, isQQPlay = cc.sys.platform === cc.sys.QQ_PLAY;
        if (isWeChatGame) {
          this.container = cc.container = localContainer = document.createElement("DIV");
          this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode;
          localCanvas = cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB ? wx.getSharedCanvas() : canvas;
          this.canvas = cc._canvas = localCanvas;
        } else if (isQQPlay) {
          this.container = cc.container = document.createElement("DIV");
          this.frame = document.documentElement;
          this.canvas = cc._canvas = localCanvas = canvas;
        } else {
          var element = el instanceof HTMLElement ? el : document.querySelector(el) || document.querySelector("#" + el);
          if ("CANVAS" === element.tagName) {
            width = width || element.width;
            height = height || element.height;
            this.canvas = cc._canvas = localCanvas = element;
            this.container = cc.container = localContainer = document.createElement("DIV");
            localCanvas.parentNode && localCanvas.parentNode.insertBefore(localContainer, localCanvas);
          } else {
            "DIV" !== element.tagName && cc.warnID(3819);
            width = width || element.clientWidth;
            height = height || element.clientHeight;
            this.canvas = cc._canvas = localCanvas = document.createElement("CANVAS");
            this.container = cc.container = localContainer = document.createElement("DIV");
            element.appendChild(localContainer);
          }
          localContainer.setAttribute("id", "Cocos2dGameContainer");
          localContainer.appendChild(localCanvas);
          this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode;
          function addClass(element, name) {
            var hasClass = (" " + element.className + " ").indexOf(" " + name + " ") > -1;
            if (!hasClass) {
              element.className && (element.className += " ");
              element.className += name;
            }
          }
          addClass(localCanvas, "gameCanvas");
          localCanvas.setAttribute("width", width || 480);
          localCanvas.setAttribute("height", height || 320);
          localCanvas.setAttribute("tabindex", 99);
        }
        if (cc._renderType === game.RENDER_TYPE_WEBGL) {
          var opts = {
            stencil: true,
            antialias: cc.macro.ENABLE_WEBGL_ANTIALIAS,
            alpha: cc.macro.ENABLE_TRANSPARENT_CANVAS
          };
          isWeChatGame && (opts["preserveDrawingBuffer"] = true);
          this._renderContext = cc._renderContext = cc.webglContext = cc.create3DContext(localCanvas, opts);
        }
        if (this._renderContext) {
          cc.renderer = cc.rendererWebGL;
          win.gl = this._renderContext;
          cc.renderer.init();
        } else {
          cc._renderType = game.RENDER_TYPE_CANVAS;
          cc.renderer = cc.rendererCanvas;
          cc.renderer.init();
          this._renderContext = cc._renderContext = new cc.CanvasContextWrapper(localCanvas.getContext("2d"));
        }
        cc._gameDiv = localContainer;
        game.canvas.oncontextmenu = function() {
          if (!cc._isContextMenuEnable) return false;
        };
        this.emit(this.EVENT_RENDERER_INITED, true);
        this._rendererInitialized = true;
      },
      _initEvents: function() {
        var win = window, hiddenPropName;
        this.config[this.CONFIG_KEY.registerSystemEvent] && inputManager.registerSystemEvent(this.canvas);
        "undefined" !== typeof document.hidden ? hiddenPropName = "hidden" : "undefined" !== typeof document.mozHidden ? hiddenPropName = "mozHidden" : "undefined" !== typeof document.msHidden ? hiddenPropName = "msHidden" : "undefined" !== typeof document.webkitHidden && (hiddenPropName = "webkitHidden");
        var hidden = false;
        function onHidden() {
          if (!hidden) {
            hidden = true;
            game.emit(game.EVENT_HIDE, game);
          }
        }
        function onShown() {
          if (hidden) {
            hidden = false;
            game.emit(game.EVENT_SHOW, game);
          }
        }
        if (hiddenPropName) {
          var changeList = [ "visibilitychange", "mozvisibilitychange", "msvisibilitychange", "webkitvisibilitychange", "qbrowserVisibilityChange" ];
          for (var i = 0; i < changeList.length; i++) document.addEventListener(changeList[i], (function(event) {
            var visible = document[hiddenPropName];
            visible = visible || event["hidden"];
            visible ? onHidden() : onShown();
          }));
        } else {
          win.addEventListener("blur", onHidden);
          win.addEventListener("focus", onShown);
        }
        navigator.userAgent.indexOf("MicroMessenger") > -1 && (win.onfocus = onShown);
        if (true, cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB) {
          wx.onShow && wx.onShow(onShown);
          wx.onHide && wx.onHide(onHidden);
        }
        if ("onpageshow" in window && "onpagehide" in window) {
          win.addEventListener("pagehide", onHidden);
          win.addEventListener("pageshow", onShown);
          document.addEventListener("pagehide", onHidden);
          document.addEventListener("pageshow", onShown);
        }
        this.on(game.EVENT_HIDE, (function() {
          game.pause();
        }));
        this.on(game.EVENT_SHOW, (function() {
          game.resume();
        }));
      }
    };
    EventTarget.call(game);
    cc.js.addon(game, EventTarget.prototype);
    cc.game = module.exports = game;
  }), {
    "../audio/CCAudioEngine": 179,
    "./event/event-target": 60,
    "./platform/BKInputManager": 87,
    "./platform/CCInputManager": 93,
    "./platform/CCView": 98
  } ],
  15: [ (function(require, module, exports) {
    "use strict";
    var PrefabHelper = require("./utils/prefab-helper");
    var SgHelper = require("./utils/scene-graph-helper");
    var eventManager = require("./event-manager");
    var Flags = cc.Object.Flags;
    var Destroying = Flags.Destroying;
    var POSITION_CHANGED = "position-changed";
    var SIZE_CHANGED = "size-changed";
    var ANCHOR_CHANGED = "anchor-changed";
    var ROTATION_CHANGED = "rotation-changed";
    var SCALE_CHANGED = "scale-changed";
    var CHILD_REORDER = "child-reorder";
    var ERR_INVALID_NUMBER = false;
    var Misc = require("./utils/misc");
    var Event = require("./event/event");
    var ActionManagerExist = !!cc.ActionManager;
    var emptyFunc = function() {};
    var EventType = cc.Enum({
      TOUCH_START: "touchstart",
      TOUCH_MOVE: "touchmove",
      TOUCH_END: "touchend",
      TOUCH_CANCEL: "touchcancel",
      MOUSE_DOWN: "mousedown",
      MOUSE_MOVE: "mousemove",
      MOUSE_ENTER: "mouseenter",
      MOUSE_LEAVE: "mouseleave",
      MOUSE_UP: "mouseup",
      MOUSE_WHEEL: "mousewheel"
    });
    var _touchEvents = [ EventType.TOUCH_START, EventType.TOUCH_MOVE, EventType.TOUCH_END, EventType.TOUCH_CANCEL ];
    var _mouseEvents = [ EventType.MOUSE_DOWN, EventType.MOUSE_ENTER, EventType.MOUSE_MOVE, EventType.MOUSE_LEAVE, EventType.MOUSE_UP, EventType.MOUSE_WHEEL ];
    var _currentHovered = null;
    var _touchStartHandler = function(touch, event) {
      var pos = touch.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        false;
        event.type = EventType.TOUCH_START;
        event.touch = touch;
        event.bubbles = true;
        node.dispatchEvent(event);
        false;
        return true;
      }
      return false;
    };
    var _touchMoveHandler = function(touch, event) {
      false;
      var node = this.owner;
      event.type = EventType.TOUCH_MOVE;
      event.touch = touch;
      event.bubbles = true;
      node.dispatchEvent(event);
      false;
    };
    var _touchEndHandler = function(touch, event) {
      false;
      var pos = touch.getLocation();
      var node = this.owner;
      node._hitTest(pos, this) ? event.type = EventType.TOUCH_END : event.type = EventType.TOUCH_CANCEL;
      event.touch = touch;
      event.bubbles = true;
      node.dispatchEvent(event);
      false;
    };
    var _touchCancelHandler = function(touch, event) {
      false;
      var pos = touch.getLocation();
      var node = this.owner;
      event.type = EventType.TOUCH_CANCEL;
      event.touch = touch;
      event.bubbles = true;
      node.dispatchEvent(event);
      false;
    };
    var _mouseDownHandler = function(event) {
      var pos = event.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        false;
        event.type = EventType.MOUSE_DOWN;
        event.bubbles = true;
        node.dispatchEvent(event);
        false;
        event.stopPropagation();
      }
    };
    var _mouseMoveHandler = function(event) {
      var pos = event.getLocation();
      var node = this.owner;
      var hit = node._hitTest(pos, this);
      false;
      if (hit) {
        if (!this._previousIn) {
          if (_currentHovered) {
            event.type = EventType.MOUSE_LEAVE;
            _currentHovered.dispatchEvent(event);
            _currentHovered._mouseListener._previousIn = false;
          }
          _currentHovered = this.owner;
          event.type = EventType.MOUSE_ENTER;
          node.dispatchEvent(event);
          this._previousIn = true;
        }
        event.type = EventType.MOUSE_MOVE;
        event.bubbles = true;
        node.dispatchEvent(event);
      } else {
        if (!this._previousIn) return;
        event.type = EventType.MOUSE_LEAVE;
        node.dispatchEvent(event);
        this._previousIn = false;
        _currentHovered = null;
      }
      false;
      event.stopPropagation();
    };
    var _mouseUpHandler = function(event) {
      var pos = event.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        false;
        event.type = EventType.MOUSE_UP;
        event.bubbles = true;
        node.dispatchEvent(event);
        false;
        event.stopPropagation();
      }
    };
    var _mouseWheelHandler = function(event) {
      var pos = event.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        false;
        event.type = EventType.MOUSE_WHEEL;
        event.bubbles = true;
        node.dispatchEvent(event);
        false;
        event.stopPropagation();
      }
    };
    function _searchMaskInParent(node) {
      var Mask = cc.Mask;
      if (Mask) {
        var index = 0;
        for (var curr = node; curr && cc.Node.isNode(curr); curr = curr._parent, ++index) if (curr.getComponent(Mask)) return {
          index: index,
          node: curr
        };
      }
      return null;
    }
    function updateOrder(node) {
      node._parent._delaySort();
      true;
      eventManager._setDirtyForNode(node);
    }
    var Node = cc.Class({
      name: "cc.Node",
      extends: require("./utils/base-node"),
      properties: {
        _opacity: 255,
        _color: cc.Color.WHITE,
        _cascadeOpacityEnabled: true,
        _anchorPoint: cc.p(.5, .5),
        _contentSize: cc.size(0, 0),
        _rotationX: 0,
        _rotationY: 0,
        _scaleX: 1,
        _scaleY: 1,
        _position: cc.p(0, 0),
        _skewX: 0,
        _skewY: 0,
        _localZOrder: 0,
        _globalZOrder: 0,
        _opacityModifyRGB: false,
        groupIndex: {
          default: 0,
          type: cc.Integer
        },
        group: {
          get: function() {
            return cc.game.groupList[this.groupIndex] || "";
          },
          set: function(value) {
            this.groupIndex = cc.game.groupList.indexOf(value);
            this.emit("group-changed");
          }
        },
        x: {
          get: function() {
            return this._position.x;
          },
          set: function(value) {
            var localPosition = this._position;
            if (value !== localPosition.x) {
              true;
              var oldValue;
              false;
              localPosition.x = value;
              this._sgNode.setPositionX(value);
              var cache = this._hasListenerCache;
              if (cache && cache[POSITION_CHANGED]) {
                false;
                this.emit(POSITION_CHANGED);
              }
            }
          }
        },
        y: {
          get: function() {
            return this._position.y;
          },
          set: function(value) {
            var localPosition = this._position;
            if (value !== localPosition.y) {
              true;
              var oldValue;
              false;
              localPosition.y = value;
              this._sgNode.setPositionY(value);
              var cache = this._hasListenerCache;
              if (cache && cache[POSITION_CHANGED]) {
                false;
                this.emit(POSITION_CHANGED);
              }
            }
          }
        },
        rotation: {
          get: function() {
            this._rotationX !== this._rotationY && cc.logID(1602);
            return this._rotationX;
          },
          set: function(value) {
            if (this._rotationX !== value || this._rotationY !== value) {
              this._rotationX = this._rotationY = value;
              this._sgNode.rotation = value;
              var cache = this._hasListenerCache;
              cache && cache[ROTATION_CHANGED] && this.emit(ROTATION_CHANGED);
            }
          }
        },
        rotationX: {
          get: function() {
            return this._rotationX;
          },
          set: function(value) {
            if (this._rotationX !== value) {
              this._rotationX = value;
              this._sgNode.rotationX = value;
              var cache = this._hasListenerCache;
              cache && cache[ROTATION_CHANGED] && this.emit(ROTATION_CHANGED);
            }
          }
        },
        rotationY: {
          get: function() {
            return this._rotationY;
          },
          set: function(value) {
            if (this._rotationY !== value) {
              this._rotationY = value;
              this._sgNode.rotationY = value;
              var cache = this._hasListenerCache;
              cache && cache[ROTATION_CHANGED] && this.emit(ROTATION_CHANGED);
            }
          }
        },
        scaleX: {
          get: function() {
            return this._scaleX;
          },
          set: function(value) {
            if (this._scaleX !== value) {
              this._scaleX = value;
              this._sgNode.scaleX = value;
              var cache = this._hasListenerCache;
              cache && cache[SCALE_CHANGED] && this.emit(SCALE_CHANGED);
            }
          }
        },
        scaleY: {
          get: function() {
            return this._scaleY;
          },
          set: function(value) {
            if (this._scaleY !== value) {
              this._scaleY = value;
              this._sgNode.scaleY = value;
              var cache = this._hasListenerCache;
              cache && cache[SCALE_CHANGED] && this.emit(SCALE_CHANGED);
            }
          }
        },
        skewX: {
          get: function() {
            return this._skewX;
          },
          set: function(value) {
            this._skewX = value;
            this._sgNode.skewX = value;
          }
        },
        skewY: {
          get: function() {
            return this._skewY;
          },
          set: function(value) {
            this._skewY = value;
            this._sgNode.skewY = value;
          }
        },
        opacity: {
          get: function() {
            return this._opacity;
          },
          set: function(value) {
            if (this._opacity !== value) {
              this._opacity = value;
              this._sgNode.setOpacity(value);
              if (!this._cascadeOpacityEnabled) {
                var sizeProvider = this._sizeProvider;
                sizeProvider instanceof _ccsg.Node && sizeProvider !== this._sgNode && sizeProvider.setOpacity(value);
              }
            }
          },
          range: [ 0, 255 ]
        },
        cascadeOpacity: {
          get: function() {
            return this._cascadeOpacityEnabled;
          },
          set: function(value) {
            if (this._cascadeOpacityEnabled !== value) {
              this._cascadeOpacityEnabled = value;
              this._sgNode.cascadeOpacity = value;
              var opacity = value ? 255 : this._opacity;
              var sizeProvider = this._sizeProvider;
              sizeProvider instanceof _ccsg.Node && sizeProvider.setOpacity(opacity);
            }
          }
        },
        color: {
          get: function() {
            return this._color.clone();
          },
          set: function(value) {
            if (!this._color.equals(value)) {
              this._color.fromColor(value);
              false;
              this._sizeProvider instanceof _ccsg.Node && this._sizeProvider.setColor(value);
            }
          }
        },
        anchorX: {
          get: function() {
            return this._anchorPoint.x;
          },
          set: function(value) {
            var anchorPoint = this._anchorPoint;
            if (anchorPoint.x !== value) {
              anchorPoint.x = value;
              var sizeProvider = this._sizeProvider;
              sizeProvider instanceof _ccsg.Node && sizeProvider.setAnchorPoint(anchorPoint);
              this.emit(ANCHOR_CHANGED);
            }
          }
        },
        anchorY: {
          get: function() {
            return this._anchorPoint.y;
          },
          set: function(value) {
            var anchorPoint = this._anchorPoint;
            if (anchorPoint.y !== value) {
              anchorPoint.y = value;
              var sizeProvider = this._sizeProvider;
              sizeProvider instanceof _ccsg.Node && sizeProvider.setAnchorPoint(anchorPoint);
              this.emit(ANCHOR_CHANGED);
            }
          }
        },
        width: {
          get: function() {
            if (this._sizeProvider) {
              var w = this._sizeProvider._getWidth();
              this._contentSize.width = w;
              return w;
            }
            return this._contentSize.width;
          },
          set: function(value) {
            if (value !== this._contentSize.width) {
              var sizeProvider = this._sizeProvider;
              sizeProvider && sizeProvider.setContentSize(value, sizeProvider._getHeight());
              var clone;
              false;
              this._contentSize.width = value;
              false;
              this.emit(SIZE_CHANGED);
            }
          }
        },
        height: {
          get: function() {
            if (this._sizeProvider) {
              var h = this._sizeProvider._getHeight();
              this._contentSize.height = h;
              return h;
            }
            return this._contentSize.height;
          },
          set: function(value) {
            if (value !== this._contentSize.height) {
              var sizeProvider = this._sizeProvider;
              sizeProvider && sizeProvider.setContentSize(sizeProvider._getWidth(), value);
              var clone;
              false;
              this._contentSize.height = value;
              false;
              this.emit(SIZE_CHANGED);
            }
          }
        },
        zIndex: {
          get: function() {
            return this._localZOrder;
          },
          set: function(value) {
            if (this._localZOrder !== value) {
              this._localZOrder = value;
              this._sgNode.zIndex = value;
              this._parent && updateOrder(this);
            }
          }
        }
      },
      ctor: function(name) {
        var sgNode = this._sgNode = new _ccsg.Node();
        false;
        cc.game._isCloning || (sgNode.cascadeOpacity = true);
        this._sizeProvider = null;
        this._reorderChildDirty = false;
        this._widget = null;
        this._touchListener = null;
        this._mouseListener = null;
      },
      statics: {
        isNode: function(obj) {
          return obj instanceof Node && (obj.constructor === Node || !(obj instanceof cc.Scene));
        }
      },
      _onSetParent: function(value) {
        var sgNode = this._sgNode;
        sgNode.parent && sgNode.parent.removeChild(sgNode, false);
        if (value) {
          value._sgNode.addChild(sgNode);
          value._delaySort();
        }
      },
      _onSiblingIndexChanged: function(index) {
        var parent = this._parent;
        var siblings = parent._children;
        var i = 0, len = siblings.length, sibling;
        var zOrder;
        var nextSibling;
        var oldZOrder;
        false;
        for (;i < len; i++) {
          sibling = siblings[i]._sgNode;
          sibling._arrivalOrder = i;
          eventManager._setDirtyForNode(siblings[i]);
        }
        cc.renderer.childrenOrderDirty = true;
        parent._sgNode._reorderChildDirty = true;
        parent._delaySort();
      },
      _onPreDestroy: function() {
        var destroyByParent = this._onPreDestroyBase();
        ActionManagerExist && cc.director.getActionManager().removeAllActionsFromTarget(this);
        _currentHovered === this && (_currentHovered = null);
        false;
        this._reorderChildDirty && cc.director.__fastOff(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
        eventManager.removeListeners(this);
        if (destroyByParent) false; else {
          this._removeSgNode();
          false;
        }
      },
      _onPostActivated: function(active) {
        var actionManager = ActionManagerExist ? cc.director.getActionManager() : null;
        if (active) {
          actionManager && actionManager.resumeTarget(this);
          eventManager.resumeTarget(this);
          if (this._touchListener) {
            var mask = this._touchListener.mask = _searchMaskInParent(this);
            this._mouseListener && (this._mouseListener.mask = mask);
          } else this._mouseListener && (this._mouseListener.mask = _searchMaskInParent(this));
        } else {
          actionManager && actionManager.pauseTarget(this);
          eventManager.pauseTarget(this);
        }
      },
      _onHierarchyChanged: function(oldParent) {
        this._onHierarchyChangedBase(oldParent);
        cc._widgetManager._nodesOrderDirty = true;
      },
      _onBatchCreated: function() {
        var prefabInfo = this._prefab;
        if (prefabInfo && prefabInfo.sync && prefabInfo.root === this) {
          false;
          PrefabHelper.syncWithPrefab(this);
        }
        this._updateDummySgNode();
        this._parent && this._parent._sgNode.addChild(this._sgNode);
        if (!this._activeInHierarchy) {
          ActionManagerExist && cc.director.getActionManager().pauseTarget(this);
          eventManager.pauseTarget(this);
        }
        var children = this._children;
        for (var i = 0, len = children.length; i < len; i++) children[i]._onBatchCreated();
      },
      _onBatchRestored: function() {
        this._updateDummySgNode();
        this._parent && this._parent._sgNode.addChild(this._sgNode);
        if (!this._activeInHierarchy) {
          ActionManagerExist && cc.director.getActionManager().pauseTarget(this);
          eventManager.pauseTarget(this);
        }
        var children = this._children;
        for (var i = 0, len = children.length; i < len; i++) children[i]._onBatchRestored();
      },
      on: function(type, callback, target, useCapture) {
        var newAdded = false;
        if (-1 !== _touchEvents.indexOf(type)) {
          if (!this._touchListener) {
            this._touchListener = cc.EventListener.create({
              event: cc.EventListener.TOUCH_ONE_BY_ONE,
              swallowTouches: true,
              owner: this,
              mask: _searchMaskInParent(this),
              onTouchBegan: _touchStartHandler,
              onTouchMoved: _touchMoveHandler,
              onTouchEnded: _touchEndHandler,
              onTouchCancelled: _touchCancelHandler
            });
            eventManager.addListener(this._touchListener, this);
            newAdded = true;
          }
        } else if (-1 !== _mouseEvents.indexOf(type) && !this._mouseListener) {
          this._mouseListener = cc.EventListener.create({
            event: cc.EventListener.MOUSE,
            _previousIn: false,
            owner: this,
            mask: _searchMaskInParent(this),
            onMouseDown: _mouseDownHandler,
            onMouseMove: _mouseMoveHandler,
            onMouseUp: _mouseUpHandler,
            onMouseScroll: _mouseWheelHandler
          });
          eventManager.addListener(this._mouseListener, this);
          newAdded = true;
        }
        newAdded && !this._activeInHierarchy && cc.director.getScheduler().schedule((function() {
          this._activeInHierarchy || eventManager.pauseTarget(this);
        }), this, 0, 0, 0, false);
        return this._EventTargetOn(type, callback, target, useCapture);
      },
      off: function(type, callback, target, useCapture) {
        this._EventTargetOff(type, callback, target, useCapture);
        -1 !== _touchEvents.indexOf(type) ? this._checkTouchListeners() : -1 !== _mouseEvents.indexOf(type) && this._checkMouseListeners();
      },
      targetOff: function(target) {
        this._EventTargetTargetOff(target);
        this._checkTouchListeners();
        this._checkMouseListeners();
      },
      pauseSystemEvents: function(recursive) {
        eventManager.pauseTarget(this, recursive);
      },
      resumeSystemEvents: function(recursive) {
        eventManager.resumeTarget(this, recursive);
      },
      _checkTouchListeners: function() {
        if (!(this._objFlags & Destroying) && this._touchListener) {
          var i = 0;
          if (this._bubblingListeners) for (;i < _touchEvents.length; ++i) if (this._bubblingListeners.has(_touchEvents[i])) return;
          if (this._capturingListeners) for (;i < _touchEvents.length; ++i) if (this._capturingListeners.has(_touchEvents[i])) return;
          eventManager.removeListener(this._touchListener);
          this._touchListener = null;
        }
      },
      _checkMouseListeners: function() {
        if (!(this._objFlags & Destroying) && this._mouseListener) {
          var i = 0;
          if (this._bubblingListeners) for (;i < _mouseEvents.length; ++i) if (this._bubblingListeners.has(_mouseEvents[i])) return;
          if (this._capturingListeners) for (;i < _mouseEvents.length; ++i) if (this._capturingListeners.has(_mouseEvents[i])) return;
          _currentHovered === this && (_currentHovered = null);
          eventManager.removeListener(this._mouseListener);
          this._mouseListener = null;
        }
      },
      _hitTest: function(point, listener) {
        var w = this.width, h = this.height, pt = point;
        var Camera = cc.Camera;
        Camera && Camera.main && Camera.main.containsNode(this) && (pt = Camera.main.getCameraToWorldPoint(pt));
        var trans = cc.affineTransformInvertIn(this._sgNode.getNodeToWorldTransform());
        pt = cc.pointApplyAffineTransform(pt, trans);
        pt.x += this._anchorPoint.x * w;
        pt.y += this._anchorPoint.y * h;
        var left = pt.x, right = w - pt.x, bottom = pt.y, top = h - pt.y;
        if (left >= 0 && right >= 0 && top >= 0 && bottom >= 0) {
          if (listener && listener.mask) {
            var mask = listener.mask;
            var parent = this;
            for (var i = 0; parent && i < mask.index; ++i, parent = parent.parent) ;
            if (parent === mask.node) {
              var comp = parent.getComponent(cc.Mask);
              return !comp || !comp.enabledInHierarchy || comp._hitTest(point);
            }
            listener.mask = null;
            return true;
          }
          return true;
        }
        return false;
      },
      _getCapturingTargets: function(type, array) {
        var parent = this.parent;
        while (parent) {
          parent.hasEventListener(type, true) && array.push(parent);
          parent = parent.parent;
        }
      },
      _getBubblingTargets: function(type, array) {
        var parent = this.parent;
        while (parent) {
          parent.hasEventListener(type) && array.push(parent);
          parent = parent.parent;
        }
      },
      isRunning: function() {
        return this._activeInHierarchy;
      },
      runAction: ActionManagerExist ? function(action) {
        if (!this.active) return;
        cc.assertID(action, 1618);
        false;
        cc.director.getActionManager().addAction(action, this, false);
        return action;
      } : emptyFunc,
      pauseAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().pauseTarget(this);
      } : emptyFunc,
      resumeAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().resumeTarget(this);
      } : emptyFunc,
      stopAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().removeAllActionsFromTarget(this);
      } : emptyFunc,
      stopAction: ActionManagerExist ? function(action) {
        cc.director.getActionManager().removeAction(action);
      } : emptyFunc,
      stopActionByTag: ActionManagerExist ? function(tag) {
        if (tag === cc.Action.TAG_INVALID) {
          cc.logID(1612);
          return;
        }
        cc.director.getActionManager().removeActionByTag(tag, this);
      } : emptyFunc,
      getActionByTag: ActionManagerExist ? function(tag) {
        if (tag === cc.Action.TAG_INVALID) {
          cc.logID(1613);
          return null;
        }
        return cc.director.getActionManager().getActionByTag(tag, this);
      } : function() {
        return null;
      },
      getNumberOfRunningActions: ActionManagerExist ? function() {
        return cc.director.getActionManager().getNumberOfRunningActionsInTarget(this);
      } : function() {
        return 0;
      },
      setTag: function(value) {
        this._tag = value;
        this._sgNode.tag = value;
      },
      getPosition: function() {
        return new cc.Vec2(this._position);
      },
      setPosition: function(newPosOrX, y) {
        var x;
        if ("undefined" === typeof y) {
          x = newPosOrX.x;
          y = newPosOrX.y;
        } else x = newPosOrX;
        var locPosition = this._position;
        if (locPosition.x === x && locPosition.y === y) return;
        var oldPosition;
        false;
        true;
        locPosition.x = x;
        true;
        locPosition.y = y;
        this._sgNode.setPosition(x, y);
        var cache = this._hasListenerCache;
        if (cache && cache[POSITION_CHANGED]) {
          false;
          this.emit(POSITION_CHANGED);
        }
      },
      getScale: function() {
        this._scaleX !== this._scaleY && cc.logID(1603);
        return this._scaleX;
      },
      setScale: function(scaleX, scaleY) {
        if ("object" === typeof scaleX) {
          scaleY = scaleX.y;
          scaleX = scaleX.x;
        } else scaleY = scaleY || 0 === scaleY ? scaleY : scaleX;
        if (this._scaleX !== scaleX || this._scaleY !== scaleY) {
          this._scaleX = scaleX;
          this._scaleY = scaleY;
          this._sgNode.setScale(scaleX, scaleY);
          var cache = this._hasListenerCache;
          cache && cache[SCALE_CHANGED] && this.emit(SCALE_CHANGED);
        }
      },
      getContentSize: function(ignoreSizeProvider) {
        if (this._sizeProvider && !ignoreSizeProvider) {
          var size = this._sizeProvider.getContentSize();
          this._contentSize = size;
          return cc.size(size);
        }
        return cc.size(this._contentSize);
      },
      setContentSize: function(size, height) {
        var locContentSize = this._contentSize;
        var clone;
        if (void 0 === height) {
          if (size.width === locContentSize.width && size.height === locContentSize.height) return;
          false;
          locContentSize.width = size.width;
          locContentSize.height = size.height;
        } else {
          if (size === locContentSize.width && height === locContentSize.height) return;
          false;
          locContentSize.width = size;
          locContentSize.height = height;
        }
        this._sizeProvider && this._sizeProvider.setContentSize(locContentSize);
        false;
        this.emit(SIZE_CHANGED);
      },
      setOpacityModifyRGB: function(opacityValue) {
        if (this._opacityModifyRGB !== opacityValue) {
          this._opacityModifyRGB = opacityValue;
          this._sgNode.setOpacityModifyRGB(opacityValue);
          var sizeProvider = this._sizeProvider;
          sizeProvider instanceof _ccsg.Node && sizeProvider !== this._sgNode && sizeProvider.setOpacityModifyRGB(opacityValue);
        }
      },
      isOpacityModifyRGB: function() {
        return this._opacityModifyRGB;
      },
      setGlobalZOrder: function(globalZOrder) {
        this._globalZOrder = globalZOrder;
        this._sgNode.setGlobalZOrder(globalZOrder);
      },
      getGlobalZOrder: function() {
        this._globalZOrder = this._sgNode.getGlobalZOrder();
        return this._globalZOrder;
      },
      getAnchorPoint: function() {
        return cc.p(this._anchorPoint);
      },
      setAnchorPoint: function(point, y) {
        var locAnchorPoint = this._anchorPoint;
        if (void 0 === y) {
          if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) return;
          locAnchorPoint.x = point.x;
          locAnchorPoint.y = point.y;
        } else {
          if (point === locAnchorPoint.x && y === locAnchorPoint.y) return;
          locAnchorPoint.x = point;
          locAnchorPoint.y = y;
        }
        var sizeProvider = this._sizeProvider;
        sizeProvider instanceof _ccsg.Node && sizeProvider.setAnchorPoint(locAnchorPoint);
        this.emit(ANCHOR_CHANGED);
      },
      getAnchorPointInPoints: function() {
        return this._sgNode.getAnchorPointInPoints();
      },
      getDisplayedOpacity: function() {
        return this._sgNode.getDisplayedOpacity();
      },
      _updateDisplayedOpacity: function(parentOpacity) {
        this._sgNode.updateDisplayedOpacity(parentOpacity);
      },
      getDisplayedColor: function() {
        return this._sgNode.getDisplayedColor();
      },
      getNodeToParentTransformAR: function() {
        var contentSize = this.getContentSize();
        var mat = this._sgNode.getNodeToParentTransform();
        if (!this._isSgTransformArToMe(contentSize)) {
          var tx = this._anchorPoint.x * contentSize.width;
          var ty = this._anchorPoint.y * contentSize.height;
          var offset = cc.affineTransformMake(1, 0, 0, 1, tx, ty);
          mat = cc.affineTransformConcatIn(offset, mat);
        }
        return mat;
      },
      getBoundingBox: function() {
        var size = this.getContentSize();
        var rect = cc.rect(0, 0, size.width, size.height);
        return cc._rectApplyAffineTransformIn(rect, this.getNodeToParentTransform());
      },
      getBoundingBoxToWorld: function() {
        var trans;
        this.parent && (trans = this.parent.getNodeToWorldTransformAR());
        return this._getBoundingBoxTo(trans);
      },
      _getBoundingBoxTo: function(parentTransformAR) {
        var size = this.getContentSize();
        var width = size.width;
        var height = size.height;
        var rect = cc.rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
        var transAR = cc.affineTransformConcat(this.getNodeToParentTransformAR(), parentTransformAR);
        cc._rectApplyAffineTransformIn(rect, transAR);
        if (!this._children) return rect;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
          var child = locChildren[i];
          if (child && child.active) {
            var childRect = child._getBoundingBoxTo(transAR);
            childRect && (rect = cc.rectUnion(rect, childRect));
          }
        }
        return rect;
      },
      getNodeToParentTransform: function() {
        var contentSize = this.getContentSize();
        var mat = this._sgNode.getNodeToParentTransform();
        if (this._isSgTransformArToMe(contentSize)) {
          var tx = -this._anchorPoint.x * contentSize.width;
          var ty = -this._anchorPoint.y * contentSize.height;
          var offset = cc.affineTransformMake(1, 0, 0, 1, tx, ty);
          mat = cc.affineTransformConcatIn(offset, mat);
        }
        return mat;
      },
      getNodeToWorldTransform: function() {
        var contentSize = this.getContentSize();
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
        var mat = this._sgNode.getNodeToWorldTransform();
        if (this._isSgTransformArToMe(contentSize)) {
          var tx = -this._anchorPoint.x * contentSize.width;
          var ty = -this._anchorPoint.y * contentSize.height;
          var offset = cc.affineTransformMake(1, 0, 0, 1, tx, ty);
          mat = cc.affineTransformConcatIn(offset, mat);
        }
        return mat;
      },
      getNodeToWorldTransformAR: function() {
        var contentSize = this.getContentSize();
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
        var mat = this._sgNode.getNodeToWorldTransform();
        if (!this._isSgTransformArToMe(contentSize)) {
          var tx = this._anchorPoint.x * contentSize.width;
          var ty = this._anchorPoint.y * contentSize.height;
          var offset = cc.affineTransformMake(1, 0, 0, 1, tx, ty);
          mat = cc.affineTransformConcatIn(offset, mat);
        }
        return mat;
      },
      getParentToNodeTransform: function() {
        return this._sgNode.getParentToNodeTransform();
      },
      getWorldToNodeTransform: function() {
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
        return this._sgNode.getWorldToNodeTransform();
      },
      _isSgTransformArToMe: function(myContentSize) {
        var renderSize = this._sgNode.getContentSize();
        if (0 === renderSize.width && 0 === renderSize.height && (0 !== myContentSize.width || 0 !== myContentSize.height)) return true;
        if (this._sgNode.isIgnoreAnchorPointForPosition()) return true;
        return false;
      },
      convertToNodeSpace: function(worldPoint) {
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
        var nodePositionIgnoreAnchorPoint = this._sgNode.convertToNodeSpace(worldPoint);
        return cc.pAdd(nodePositionIgnoreAnchorPoint, cc.p(this._anchorPoint.x * this._contentSize.width, this._anchorPoint.y * this._contentSize.height));
      },
      convertToWorldSpace: function(nodePoint) {
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
        var x = nodePoint.x - this._anchorPoint.x * this._contentSize.width;
        var y = nodePoint.y - this._anchorPoint.y * this._contentSize.height;
        return cc.v2(this._sgNode.convertToWorldSpace(cc.v2(x, y)));
      },
      convertToNodeSpaceAR: function(worldPoint) {
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
        return this._sgNode.isIgnoreAnchorPointForPosition() ? cc.v2(this._sgNode.convertToNodeSpace(worldPoint)) : this._sgNode.convertToNodeSpaceAR(worldPoint);
      },
      convertToWorldSpaceAR: function(nodePoint) {
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
        return this._sgNode.isIgnoreAnchorPointForPosition() ? cc.v2(this._sgNode.convertToWorldSpace(nodePoint)) : cc.v2(this._sgNode.convertToWorldSpaceAR(nodePoint));
      },
      convertTouchToNodeSpace: function(touch) {
        return this.convertToNodeSpace(touch.getLocation());
      },
      convertTouchToNodeSpaceAR: function(touch) {
        return this.convertToNodeSpaceAR(touch.getLocation());
      },
      setNodeDirty: function() {
        this._sgNode.setNodeDirty();
      },
      addChild: function(child, localZOrder, tag) {
        localZOrder = void 0 === localZOrder ? child._localZOrder : localZOrder;
        var name, setTag = false;
        if ("undefined" === typeof tag) {
          tag = void 0;
          name = child._name;
        } else if (cc.js.isString(tag)) {
          name = tag;
          tag = void 0;
        } else if (cc.js.isNumber(tag)) {
          setTag = true;
          name = "";
        }
        false;
        cc.assertID(child, 1606);
        cc.assertID(null === child._parent, 1605);
        child.parent = this;
        child.zIndex = localZOrder;
        setTag ? child.setTag(tag) : child.setName(name);
      },
      cleanup: function() {
        ActionManagerExist && cc.director.getActionManager().removeAllActionsFromTarget(this);
        eventManager.removeListeners(this);
        var i, len = this._children.length, node;
        for (i = 0; i < len; ++i) {
          node = this._children[i];
          node && node.cleanup();
        }
      },
      sortAllChildren: function() {
        if (this._reorderChildDirty) {
          this._reorderChildDirty = false;
          var _children = this._children;
          if (_children.length > 1) {
            var len = _children.length, i, j, child;
            for (i = 1; i < len; i++) {
              child = _children[i];
              j = i - 1;
              while (j >= 0) {
                if (child._localZOrder < _children[j]._localZOrder) _children[j + 1] = _children[j]; else {
                  if (!(child._localZOrder === _children[j]._localZOrder && child._sgNode._arrivalOrder < _children[j]._sgNode._arrivalOrder)) break;
                  _children[j + 1] = _children[j];
                }
                j--;
              }
              _children[j + 1] = child;
            }
            this.emit(CHILD_REORDER);
          }
          cc.director.__fastOff(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
        }
      },
      _delaySort: function() {
        if (!this._reorderChildDirty) {
          this._reorderChildDirty = true;
          cc.director.__fastOn(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
        }
      },
      _updateDummySgNode: function() {
        var self = this;
        var sgNode = self._sgNode;
        sgNode.setPosition(self._position);
        sgNode.setRotationX(self._rotationX);
        sgNode.setRotationY(self._rotationY);
        sgNode.setScale(self._scaleX, self._scaleY);
        sgNode.setSkewX(self._skewX);
        sgNode.setSkewY(self._skewY);
        var arrivalOrder = sgNode._arrivalOrder;
        sgNode.setLocalZOrder(self._localZOrder);
        sgNode._arrivalOrder = arrivalOrder;
        sgNode.setGlobalZOrder(self._globalZOrder);
        false;
        sgNode.setOpacity(self._opacity);
        sgNode.setOpacityModifyRGB(self._opacityModifyRGB);
        sgNode.setCascadeOpacityEnabled(self._cascadeOpacityEnabled);
        sgNode.setTag(self._tag);
      },
      _updateSgNode: function() {
        this._updateDummySgNode();
        var sgNode = this._sgNode;
        sgNode.setAnchorPoint(this._anchorPoint);
        sgNode.setVisible(this._active);
        sgNode.setColor(this._color);
        var actionManager = ActionManagerExist ? cc.director.getActionManager() : null;
        if (this._activeInHierarchy) {
          actionManager && actionManager.resumeTarget(this);
          eventManager.resumeTarget(this);
        } else {
          actionManager && actionManager.pauseTarget(this);
          eventManager.pauseTarget(this);
        }
      },
      _removeSgNode: SgHelper.removeSgNode,
      onRestore: false
    });
    var updateListeners;
    false;
    var SameNameGetSets = [ "parent", "tag", "skewX", "skewY", "position", "rotation", "rotationX", "rotationY", "scale", "scaleX", "scaleY", "opacity", "color" ];
    var DiffNameGetSets = {
      x: [ "getPositionX", "setPositionX" ],
      y: [ "getPositionY", "setPositionY" ],
      zIndex: [ "getLocalZOrder", "setLocalZOrder" ],
      opacityModifyRGB: [ "isOpacityModifyRGB", "setOpacityModifyRGB" ],
      cascadeOpacity: [ "isCascadeOpacityEnabled", "setCascadeOpacityEnabled" ]
    };
    Misc.propertyDefine(Node, SameNameGetSets, DiffNameGetSets);
    Node.EventType = EventType;
    cc.Node = module.exports = Node;
  }), {
    "./event-manager": 58,
    "./event/event": 61,
    "./utils/base-node": 133,
    "./utils/misc": 137,
    "./utils/prefab-helper": 139,
    "./utils/scene-graph-helper": 140
  } ],
  16: [ (function(require, module, exports) {
    var NIL = function() {};
    cc.Scene = cc.Class({
      name: "cc.Scene",
      extends: require("./CCNode"),
      properties: {
        autoReleaseAssets: {
          default: void 0,
          type: cc.Boolean
        }
      },
      ctor: function() {
        var sgNode = this._sgNode = new _ccsg.Scene();
        sgNode.setAnchorPoint(0, 0);
        this._anchorPoint.x = 0;
        this._anchorPoint.y = 0;
        this._activeInHierarchy = false;
        this._inited = !cc.game._isCloning;
        false;
        this.dependAssets = null;
      },
      destroy: function() {
        this._super();
        this._activeInHierarchy = false;
      },
      _onHierarchyChanged: NIL,
      _instantiate: null,
      _load: function() {
        if (!this._inited) {
          false;
          false;
          this._onBatchCreated();
          this._inited = true;
        }
      },
      _activate: function(active) {
        active = false !== active;
        false, false;
        cc.director._nodeActivator.activateNode(this, active);
      }
    });
    module.exports = cc.Scene;
  }), {
    "./CCNode": 15
  } ],
  17: [ (function(require, module, exports) {
    var MAX_POOL_SIZE = 20;
    var ListEntry = function(prev, next, callback, target, priority, paused, markedForDeletion) {
      this.prev = prev;
      this.next = next;
      this.callback = callback;
      this.target = target;
      this.priority = priority;
      this.paused = paused;
      this.markedForDeletion = markedForDeletion;
      this.isUpdate = !callback;
    };
    var _listEntries = [];
    ListEntry.get = function(prev, next, callback, target, priority, paused, markedForDeletion) {
      var result = _listEntries.pop();
      if (result) {
        result.prev = prev;
        result.next = next;
        result.callback = callback;
        result.target = target;
        result.priority = priority;
        result.paused = paused;
        result.markedForDeletion = markedForDeletion;
        result.isUpdate = !callback;
      } else result = new ListEntry(prev, next, callback, target, priority, paused, markedForDeletion);
      return result;
    };
    ListEntry.put = function(entry) {
      if (_listEntries.length < MAX_POOL_SIZE) {
        entry.prev = entry.next = entry.callback = entry.target = null;
        _listEntries.push(entry);
      }
    };
    var HashUpdateEntry = function(list, entry, target, callback) {
      this.list = list;
      this.entry = entry;
      this.target = target;
      this.callback = callback;
    };
    var _hashUpdateEntries = [];
    HashUpdateEntry.get = function(list, entry, target, callback) {
      var result = _hashUpdateEntries.pop();
      if (result) {
        result.list = list;
        result.entry = entry;
        result.target = target;
        result.callback = callback;
      } else result = new HashUpdateEntry(list, entry, target, callback);
      return result;
    };
    HashUpdateEntry.put = function(entry) {
      if (_hashUpdateEntries.length < MAX_POOL_SIZE) {
        entry.list = entry.entry = entry.target = entry.callback = null;
        _hashUpdateEntries.push(entry);
      }
    };
    var HashTimerEntry = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
      var _t = this;
      _t.timers = timers;
      _t.target = target;
      _t.timerIndex = timerIndex;
      _t.currentTimer = currentTimer;
      _t.currentTimerSalvaged = currentTimerSalvaged;
      _t.paused = paused;
    };
    var _hashTimerEntries = [];
    HashTimerEntry.get = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
      var result = _hashTimerEntries.pop();
      if (result) {
        result.timers = timers;
        result.target = target;
        result.timerIndex = timerIndex;
        result.currentTimer = currentTimer;
        result.currentTimerSalvaged = currentTimerSalvaged;
        result.paused = paused;
      } else result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused);
      return result;
    };
    HashTimerEntry.put = function(entry) {
      if (_hashTimerEntries.length < MAX_POOL_SIZE) {
        entry.timers = entry.target = entry.currentTimer = null;
        _hashTimerEntries.push(entry);
      }
    };
    function CallbackTimer() {
      this._lock = false;
      this._scheduler = null;
      this._elapsed = -1;
      this._runForever = false;
      this._useDelay = false;
      this._timesExecuted = 0;
      this._repeat = 0;
      this._delay = 0;
      this._interval = 0;
      this._target = null;
      this._callback = null;
    }
    var proto = CallbackTimer.prototype;
    proto.initWithCallback = function(scheduler, callback, target, seconds, repeat, delay) {
      this._lock = false;
      this._scheduler = scheduler;
      this._target = target;
      this._callback = callback;
      this._elapsed = -1;
      this._interval = seconds;
      this._delay = delay;
      this._useDelay = this._delay > 0;
      this._repeat = repeat;
      this._runForever = this._repeat === cc.macro.REPEAT_FOREVER;
      return true;
    };
    proto.getInterval = function() {
      return this._interval;
    };
    proto.setInterval = function(interval) {
      this._interval = interval;
    };
    proto.update = function(dt) {
      if (-1 === this._elapsed) {
        this._elapsed = 0;
        this._timesExecuted = 0;
      } else {
        this._elapsed += dt;
        if (this._runForever && !this._useDelay) {
          if (this._elapsed >= this._interval) {
            this.trigger();
            this._elapsed = 0;
          }
        } else {
          if (this._useDelay) {
            if (this._elapsed >= this._delay) {
              this.trigger();
              this._elapsed -= this._delay;
              this._timesExecuted += 1;
              this._useDelay = false;
            }
          } else if (this._elapsed >= this._interval) {
            this.trigger();
            this._elapsed = 0;
            this._timesExecuted += 1;
          }
          this._callback && !this._runForever && this._timesExecuted > this._repeat && this.cancel();
        }
      }
    };
    proto.getCallback = function() {
      return this._callback;
    };
    proto.trigger = function() {
      if (this._target && this._callback) {
        this._lock = true;
        this._callback.call(this._target, this._elapsed);
        this._lock = false;
      }
    };
    proto.cancel = function() {
      this._scheduler.unschedule(this._callback, this._target);
    };
    var _timers = [];
    CallbackTimer.get = function() {
      return _timers.pop() || new CallbackTimer();
    };
    CallbackTimer.put = function(timer) {
      if (_timers.length < MAX_POOL_SIZE && !timer._lock) {
        timer._scheduler = timer._target = timer._callback = null;
        _timers.push(timer);
      }
    };
    var getTargetId = function(target) {
      return target.__instanceId || target.uuid;
    };
    cc.Scheduler = cc._Class.extend({
      ctor: function() {
        this._timeScale = 1;
        this._updatesNegList = [];
        this._updates0List = [];
        this._updatesPosList = [];
        this._hashForUpdates = {};
        this._hashForTimers = {};
        this._currentTarget = null;
        this._currentTargetSalvaged = false;
        this._updateHashLocked = false;
        this._arrayForTimers = [];
      },
      _removeHashElement: function(element) {
        delete this._hashForTimers[getTargetId(element.target)];
        var arr = this._arrayForTimers;
        for (var i = 0, l = arr.length; i < l; i++) if (arr[i] === element) {
          arr.splice(i, 1);
          break;
        }
        HashTimerEntry.put(element);
      },
      _removeUpdateFromHash: function(entry) {
        var targetId = getTargetId(entry.target);
        var self = this, element = self._hashForUpdates[targetId];
        if (element) {
          var list = element.list, listEntry = element.entry;
          for (var i = 0, l = list.length; i < l; i++) if (list[i] === listEntry) {
            list.splice(i, 1);
            break;
          }
          delete self._hashForUpdates[targetId];
          ListEntry.put(listEntry);
          HashUpdateEntry.put(element);
        }
      },
      _priorityIn: function(ppList, listElement, priority) {
        for (var i = 0; i < ppList.length; i++) if (priority < ppList[i].priority) {
          ppList.splice(i, 0, listElement);
          return;
        }
        ppList.push(listElement);
      },
      _appendIn: function(ppList, listElement) {
        ppList.push(listElement);
      },
      setTimeScale: function(timeScale) {
        this._timeScale = timeScale;
      },
      getTimeScale: function() {
        return this._timeScale;
      },
      update: function(dt) {
        this._updateHashLocked = true;
        1 !== this._timeScale && (dt *= this._timeScale);
        var i, list, len, entry;
        for (i = 0, list = this._updatesNegList, len = list.length; i < len; i++) {
          entry = list[i];
          entry.paused || entry.markedForDeletion || (entry.isUpdate ? entry.target.update(dt) : entry.callback.call(entry.target, dt));
        }
        for (i = 0, list = this._updates0List, len = list.length; i < len; i++) {
          entry = list[i];
          entry.paused || entry.markedForDeletion || (entry.isUpdate ? entry.target.update(dt) : entry.callback.call(entry.target, dt));
        }
        for (i = 0, list = this._updatesPosList, len = list.length; i < len; i++) {
          entry = list[i];
          entry.paused || entry.markedForDeletion || (entry.isUpdate ? entry.target.update(dt) : entry.callback.call(entry.target, dt));
        }
        var elt, arr = this._arrayForTimers;
        for (i = 0; i < arr.length; i++) {
          elt = arr[i];
          this._currentTarget = elt;
          this._currentTargetSalvaged = false;
          if (!elt.paused) for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) {
            elt.currentTimer = elt.timers[elt.timerIndex];
            elt.currentTimerSalvaged = false;
            elt.currentTimer.update(dt);
            elt.currentTimer = null;
          }
          if (this._currentTargetSalvaged && 0 === this._currentTarget.timers.length) {
            this._removeHashElement(this._currentTarget);
            --i;
          }
        }
        for (i = 0, list = this._updatesNegList; i < list.length; ) {
          entry = list[i];
          entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
        }
        for (i = 0, list = this._updates0List; i < list.length; ) {
          entry = list[i];
          entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
        }
        for (i = 0, list = this._updatesPosList; i < list.length; ) {
          entry = list[i];
          entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
        }
        this._updateHashLocked = false;
        this._currentTarget = null;
      },
      scheduleCallbackForTarget: function(target, callback_fn, interval, repeat, delay, paused) {
        this.schedule(callback_fn, target, interval, repeat, delay, paused);
      },
      schedule: function(callback, target, interval, repeat, delay, paused) {
        "use strict";
        if ("function" !== typeof callback) {
          var tmp = callback;
          callback = target;
          target = tmp;
        }
        if (4 === arguments.length || 5 === arguments.length) {
          paused = !!repeat;
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
        }
        cc.assertID(target, 1502);
        var instanceId = getTargetId(target);
        cc.assertID(instanceId, 1510);
        var element = this._hashForTimers[instanceId];
        if (element) element.paused !== paused && cc.warnID(1511); else {
          element = HashTimerEntry.get(null, target, 0, null, null, paused);
          this._arrayForTimers.push(element);
          this._hashForTimers[instanceId] = element;
        }
        var timer, i;
        if (null == element.timers) element.timers = []; else for (i = 0; i < element.timers.length; ++i) {
          timer = element.timers[i];
          if (timer && callback === timer._callback) {
            cc.logID(1507, timer.getInterval(), interval);
            timer._interval = interval;
            return;
          }
        }
        timer = CallbackTimer.get();
        timer.initWithCallback(this, callback, target, interval, repeat, delay);
        element.timers.push(timer);
        this._currentTarget === element && this._currentTargetSalvaged && (this._currentTargetSalvaged = false);
      },
      scheduleUpdate: function(target, priority, paused, updateFunc) {
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var hashElement = this._hashForUpdates[targetId];
        if (hashElement && hashElement.entry) {
          if (hashElement.entry.priority === priority) {
            hashElement.entry.markedForDeletion = false;
            hashElement.entry.paused = paused;
            return;
          }
          if (this._updateHashLocked) {
            cc.logID(1506);
            hashElement.entry.markedForDeletion = false;
            hashElement.entry.paused = paused;
            return;
          }
          this.unscheduleUpdate(target);
        }
        updateFunc && cc.warnID(1512);
        var listElement = ListEntry.get(null, null, updateFunc, target, priority, paused, false);
        var ppList;
        if (0 === priority) {
          ppList = this._updates0List;
          this._appendIn(ppList, listElement);
        } else {
          ppList = priority < 0 ? this._updatesNegList : this._updatesPosList;
          this._priorityIn(ppList, listElement, priority);
        }
        this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
      },
      unschedule: function(callback, target) {
        if (!target || !callback) return;
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var self = this, element = self._hashForTimers[targetId];
        if (element) {
          var timers = element.timers;
          for (var i = 0, li = timers.length; i < li; i++) {
            var timer = timers[i];
            if (callback === timer._callback) {
              timer !== element.currentTimer || element.currentTimerSalvaged || (element.currentTimerSalvaged = true);
              timers.splice(i, 1);
              CallbackTimer.put(timer);
              element.timerIndex >= i && element.timerIndex--;
              0 === timers.length && (self._currentTarget === element ? self._currentTargetSalvaged = true : self._removeHashElement(element));
              return;
            }
          }
        }
      },
      unscheduleUpdate: function(target) {
        if (!target) return;
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var element = this._hashForUpdates[targetId];
        element && (this._updateHashLocked ? element.entry.markedForDeletion = true : this._removeUpdateFromHash(element.entry));
      },
      unscheduleAllForTarget: function(target) {
        if (!target) return;
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var element = this._hashForTimers[targetId];
        if (element) {
          var timers = element.timers;
          timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged && (element.currentTimerSalvaged = true);
          for (var i = 0, l = timers.length; i < l; i++) CallbackTimer.put(timers[i]);
          timers.length = 0;
          this._currentTarget === element ? this._currentTargetSalvaged = true : this._removeHashElement(element);
        }
        this.unscheduleUpdate(target);
      },
      unscheduleAll: function() {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
      },
      unscheduleAllWithMinPriority: function(minPriority) {
        var i, element, arr = this._arrayForTimers;
        for (i = arr.length - 1; i >= 0; i--) {
          element = arr[i];
          this.unscheduleAllForTarget(element.target);
        }
        var entry;
        var temp_length = 0;
        if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; ) {
          temp_length = this._updatesNegList.length;
          entry = this._updatesNegList[i];
          entry && entry.priority >= minPriority && this.unscheduleUpdate(entry.target);
          temp_length == this._updatesNegList.length && i++;
        }
        if (minPriority <= 0) for (i = 0; i < this._updates0List.length; ) {
          temp_length = this._updates0List.length;
          entry = this._updates0List[i];
          entry && this.unscheduleUpdate(entry.target);
          temp_length == this._updates0List.length && i++;
        }
        for (i = 0; i < this._updatesPosList.length; ) {
          temp_length = this._updatesPosList.length;
          entry = this._updatesPosList[i];
          entry && entry.priority >= minPriority && this.unscheduleUpdate(entry.target);
          temp_length == this._updatesPosList.length && i++;
        }
      },
      isScheduled: function(callback, target) {
        cc.assertID(callback, 1508);
        cc.assertID(target, 1509);
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var element = this._hashForTimers[targetId];
        if (!element) return false;
        if (null == element.timers) return false;
        var timers = element.timers;
        for (var i = 0; i < timers.length; ++i) {
          var timer = timers[i];
          if (callback === timer._callback) return true;
        }
        return false;
      },
      pauseAllTargets: function() {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
      },
      pauseAllTargetsWithMinPriority: function(minPriority) {
        var idsWithSelectors = [];
        var self = this, element, locArrayForTimers = self._arrayForTimers;
        var i, li;
        for (i = 0, li = locArrayForTimers.length; i < li; i++) {
          element = locArrayForTimers[i];
          if (element) {
            element.paused = true;
            idsWithSelectors.push(element.target);
          }
        }
        var entry;
        if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; i++) {
          entry = this._updatesNegList[i];
          if (entry && entry.priority >= minPriority) {
            entry.paused = true;
            idsWithSelectors.push(entry.target);
          }
        }
        if (minPriority <= 0) for (i = 0; i < this._updates0List.length; i++) {
          entry = this._updates0List[i];
          if (entry) {
            entry.paused = true;
            idsWithSelectors.push(entry.target);
          }
        }
        for (i = 0; i < this._updatesPosList.length; i++) {
          entry = this._updatesPosList[i];
          if (entry && entry.priority >= minPriority) {
            entry.paused = true;
            idsWithSelectors.push(entry.target);
          }
        }
        return idsWithSelectors;
      },
      resumeTargets: function(targetsToResume) {
        if (!targetsToResume) return;
        for (var i = 0; i < targetsToResume.length; i++) this.resumeTarget(targetsToResume[i]);
      },
      pauseTarget: function(target) {
        cc.assertID(target, 1503);
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var self = this, element = self._hashForTimers[targetId];
        element && (element.paused = true);
        var elementUpdate = self._hashForUpdates[targetId];
        elementUpdate && (elementUpdate.entry.paused = true);
      },
      resumeTarget: function(target) {
        cc.assertID(target, 1504);
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var self = this, element = self._hashForTimers[targetId];
        element && (element.paused = false);
        var elementUpdate = self._hashForUpdates[targetId];
        elementUpdate && (elementUpdate.entry.paused = false);
      },
      isTargetPaused: function(target) {
        cc.assertID(target, 1505);
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var element = this._hashForTimers[targetId];
        if (element) return element.paused;
        var elementUpdate = this._hashForUpdates[targetId];
        if (elementUpdate) return elementUpdate.entry.paused;
        return false;
      },
      scheduleUpdateForTarget: function(target, priority, paused) {
        this.scheduleUpdate(target, priority, paused);
      },
      unscheduleCallbackForTarget: function(target, callback) {
        this.unschedule(callback, target);
      },
      unscheduleUpdateForTarget: function(target) {
        this.unscheduleUpdate(target);
      },
      unscheduleAllCallbacksForTarget: function(target) {
        this.unscheduleAllForTarget(target);
      },
      unscheduleAllCallbacks: function() {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
      },
      unscheduleAllCallbacksWithMinPriority: function(minPriority) {
        this.unscheduleAllWithMinPriority(minPriority);
      }
    });
    cc.Scheduler.PRIORITY_SYSTEM = 1 << 31;
    cc.Scheduler.PRIORITY_NON_SYSTEM = cc.Scheduler.PRIORITY_SYSTEM + 1;
  }), {} ],
  18: [ (function(require, module, exports) {
    var RawAsset = require("./CCRawAsset");
    cc.Asset = cc.Class({
      name: "cc.Asset",
      extends: RawAsset,
      ctor: function() {
        this.loaded = true;
      },
      properties: {
        nativeUrl: {
          get: function() {
            if (this._native) {
              var name = this._native;
              if (47 === name.charCodeAt(0)) return name.slice(1);
              if (cc.AssetLibrary) {
                var base = cc.AssetLibrary.getLibUrlNoExt(this._uuid, true);
                return 46 === name.charCodeAt(0) ? base + name : base + "/" + name;
              }
              cc.errorID(6400);
            }
            return "";
          },
          visible: false
        },
        _native: "",
        _nativeAsset: {
          get: function() {},
          set: function(obj) {}
        }
      },
      statics: {
        deserialize: false,
        preventDeferredLoadDependents: false,
        preventPreloadNativeObject: false
      },
      toString: function() {
        return this.nativeUrl;
      },
      serialize: false,
      createNode: null,
      _setRawAsset: function(filename, inLibrary) {
        this._native = false !== inLibrary ? filename || void 0 : "/" + filename;
      }
    });
    module.exports = cc.Asset;
  }), {
    "./CCRawAsset": 25
  } ],
  19: [ (function(require, module, exports) {
    var Asset = require("./CCAsset");
    var EventTarget = require("../event/event-target");
    var LoadMode = cc.Enum({
      WEB_AUDIO: 0,
      DOM_AUDIO: 1
    });
    var AudioClip = cc.Class({
      name: "cc.AudioClip",
      extends: Asset,
      mixins: [ EventTarget ],
      ctor: function() {
        this.loaded = false;
        this._audio = null;
      },
      properties: {
        loadMode: {
          default: LoadMode.WEB_AUDIO,
          type: LoadMode
        },
        _nativeAsset: {
          get: function() {
            return this._audio;
          },
          set: function(value) {
            this._audio = value;
            if (value) {
              this.loaded = true;
              this.emit("load");
            }
          },
          override: true
        }
      },
      statics: {
        LoadMode: LoadMode,
        _loadByUrl: function(url, callback) {
          var item = cc.loader.getItem(url) || cc.loader.getItem(url + "?useDom=1");
          item && item.complete ? item._owner instanceof AudioClip ? callback(null, item._owner) : callback(null, item.content) : cc.loader.load(url, (function(error, downloadUrl) {
            if (error) return callback(error);
            item = cc.loader.getItem(url) || cc.loader.getItem(url + "?useDom=1");
            callback(null, item.content);
          }));
        }
      },
      destroy: function() {
        cc.audioEngine.uncache(this);
        this._super();
      }
    });
    cc.AudioClip = AudioClip;
    module.exports = AudioClip;
  }), {
    "../event/event-target": 60,
    "./CCAsset": 18
  } ],
  20: [ (function(require, module, exports) {
    var BitmapFont = cc.Class({
      name: "cc.BitmapFont",
      extends: cc.Font,
      properties: {
        fntDataStr: {
          default: ""
        },
        spriteFrame: {
          default: null,
          type: cc.SpriteFrame
        },
        fontSize: {
          default: -1
        },
        _fntConfig: null
      }
    });
    cc.BitmapFont = BitmapFont;
    module.exports = BitmapFont;
  }), {} ],
  21: [ (function(require, module, exports) {
    var Font = cc.Class({
      name: "cc.Font",
      extends: cc.Asset
    });
    cc.Font = module.exports = Font;
  }), {} ],
  22: [ (function(require, module, exports) {
    var JsonAsset = cc.Class({
      name: "cc.JsonAsset",
      extends: cc.Asset,
      properties: {
        json: null
      }
    });
    module.exports = cc.JsonAsset = JsonAsset;
  }), {} ],
  23: [ (function(require, module, exports) {
    var LabelAtlas = cc.Class({
      name: "cc.LabelAtlas",
      extends: cc.BitmapFont
    });
    cc.LabelAtlas = LabelAtlas;
    module.exports = LabelAtlas;
  }), {} ],
  24: [ (function(require, module, exports) {
    var OptimizationPolicy = cc.Enum({
      AUTO: 0,
      SINGLE_INSTANCE: 1,
      MULTI_INSTANCE: 2
    });
    var Prefab = cc.Class({
      name: "cc.Prefab",
      extends: cc.Asset,
      ctor: function() {
        this._createFunction = null;
        this._instantiatedTimes = 0;
      },
      properties: {
        data: null,
        optimizationPolicy: OptimizationPolicy.AUTO,
        asyncLoadAssets: false
      },
      statics: {
        OptimizationPolicy: OptimizationPolicy,
        OptimizationPolicyThreshold: 3
      },
      createNode: false,
      compileCreateFunction: function() {
        var jit = require("../platform/instantiate-jit");
        this._createFunction = jit.compile(this.data);
      },
      _doInstantiate: function(rootToRedirect) {
        this.data._prefab ? this.data._prefab._synced = true : cc.warnID(3700);
        this._createFunction || this.compileCreateFunction();
        return this._createFunction(rootToRedirect);
      },
      _instantiate: function() {
        var node, useJit = false;
        false;
        if (useJit) {
          node = this._doInstantiate();
          this.data._instantiate(node);
        } else {
          this.data._prefab._synced = true;
          node = this.data._instantiate();
        }
        ++this._instantiatedTimes;
        var PrefabUtils;
        false, false;
        return node;
      }
    });
    cc.Prefab = module.exports = Prefab;
    cc.js.obsolete(cc, "cc._Prefab", "Prefab");
  }), {
    "../platform/instantiate-jit": 107
  } ],
  25: [ (function(require, module, exports) {
    var CCObject = require("../platform/CCObject");
    var JS = require("../platform/js");
    cc.RawAsset = cc.Class({
      name: "cc.RawAsset",
      extends: CCObject,
      ctor: function() {
        Object.defineProperty(this, "_uuid", {
          value: "",
          writable: true
        });
      }
    });
    JS.value(cc.RawAsset, "isRawAssetType", (function(ctor) {
      return cc.isChildClassOf(ctor, cc.RawAsset) && !cc.isChildClassOf(ctor, cc.Asset);
    }));
    JS.value(cc.RawAsset, "wasRawAssetType", (function(ctor) {
      return ctor === cc.Texture2D || ctor === cc.AudioClip || ctor === cc.ParticleAsset || ctor === cc.Asset;
    }));
    module.exports = cc.RawAsset;
  }), {
    "../platform/CCObject": 95,
    "../platform/js": 109
  } ],
  26: [ (function(require, module, exports) {
    var Scene = cc.Class({
      name: "cc.SceneAsset",
      extends: cc.Asset,
      properties: {
        scene: null,
        asyncLoadAssets: void 0
      }
    });
    cc.SceneAsset = Scene;
    module.exports = Scene;
  }), {} ],
  27: [ (function(require, module, exports) {
    var Script = cc.Class({
      name: "cc.Script",
      extends: cc.Asset
    });
    cc._Script = Script;
    var JavaScript = cc.Class({
      name: "cc.JavaScript",
      extends: Script
    });
    cc._JavaScript = JavaScript;
    var CoffeeScript = cc.Class({
      name: "cc.CoffeeScript",
      extends: Script
    });
    cc._CoffeeScript = CoffeeScript;
    var TypeScript = cc.Class({
      name: "cc.TypeScript",
      extends: Script
    });
    cc._TypeScript = TypeScript;
  }), {} ],
  28: [ (function(require, module, exports) {
    var SpriteAtlas = cc.Class({
      name: "cc.SpriteAtlas",
      extends: cc.Asset,
      properties: {
        _spriteFrames: {
          default: {}
        }
      },
      getTexture: function() {
        var keys = Object.keys(this._spriteFrames);
        if (keys.length > 0) {
          var spriteFrame = this._spriteFrames[keys[0]];
          return spriteFrame ? spriteFrame.getTexture() : null;
        }
        return null;
      },
      getSpriteFrame: function(key) {
        var sf = this._spriteFrames[key];
        if (!sf) return null;
        sf.name || (sf.name = key);
        return sf;
      },
      getSpriteFrames: function() {
        var frames = [];
        var spriteFrames = this._spriteFrames;
        for (var key in spriteFrames) frames.push(this.getSpriteFrame(key));
        return frames;
      }
    });
    cc.SpriteAtlas = SpriteAtlas;
    module.exports = SpriteAtlas;
  }), {} ],
  29: [ (function(require, module, exports) {
    var TTFFont = cc.Class({
      name: "cc.TTFFont",
      extends: cc.Font,
      statics: {
        preventPreloadNativeObject: true
      }
    });
    cc.TTFFont = module.exports = TTFFont;
  }), {} ],
  30: [ (function(require, module, exports) {
    var TextAsset = cc.Class({
      name: "cc.TextAsset",
      extends: cc.Asset,
      properties: {
        text: ""
      },
      toString: function() {
        return this.text;
      }
    });
    module.exports = cc.TextAsset = TextAsset;
  }), {} ],
  31: [ (function(require, module, exports) {
    require("./CCRawAsset");
    require("./CCAsset");
    require("./CCFont");
    require("./CCPrefab");
    require("./CCAudioClip");
    require("./CCScripts");
    require("./CCSceneAsset");
    require("../sprites/CCSpriteFrame");
    require("../textures/CCTexture2D");
    require("./CCTTFFont");
    require("./CCSpriteAtlas");
    require("./CCBitmapFont");
    require("./CCLabelAtlas");
    require("./CCTextAsset");
    require("./CCJsonAsset");
  }), {
    "../sprites/CCSpriteFrame": 127,
    "../textures/CCTexture2D": 128,
    "./CCAsset": 18,
    "./CCAudioClip": 19,
    "./CCBitmapFont": 20,
    "./CCFont": 21,
    "./CCJsonAsset": 22,
    "./CCLabelAtlas": 23,
    "./CCPrefab": 24,
    "./CCRawAsset": 25,
    "./CCSceneAsset": 26,
    "./CCScripts": 27,
    "./CCSpriteAtlas": 28,
    "./CCTTFFont": 29,
    "./CCTextAsset": 30
  } ],
  32: [ (function(require, module, exports) {
    var Misc = require("../utils/misc");
    var eventManager = require("../event-manager");
    var ActionManagerExist = !!cc.ActionManager;
    var emptyFunc = function() {};
    cc.s_globalOrderOfArrival = 1;
    _ccsg.Node = cc.Class({
      name: "ccsg.Node",
      properties: {
        _running: false,
        _localZOrder: 0,
        _globalZOrder: 0,
        _arrivalOrder: 0,
        _reorderChildDirty: false,
        _vertexZ: 0,
        _customZ: void 0,
        _rotationX: 0,
        _rotationY: 0,
        _scaleX: 1,
        _scaleY: 1,
        _position: cc.p(0, 0),
        _skewX: 0,
        _skewY: 0,
        _children: [],
        _visible: true,
        _anchorPoint: cc.p(0, 0),
        _contentSize: cc.size(0, 0),
        _parent: null,
        _ignoreAnchorPointForPosition: false,
        tag: cc.macro.NODE_TAG_INVALID,
        _name: "",
        _realOpacity: 255,
        _realColor: cc.Color.WHITE,
        _cascadeColorEnabled: false,
        _cascadeOpacityEnabled: false,
        _isTransitionFinished: false,
        _actionManager: null,
        _scheduler: null,
        _renderCmd: null
      },
      ctor: function() {
        this.__instanceId = cc.ClassManager.getNewInstanceId();
        this._renderCmd = this._createRenderCmd();
      },
      init: function() {
        return true;
      },
      attr: function(attrs) {
        for (var key in attrs) this[key] = attrs[key];
      },
      getSkewX: function() {
        return this._skewX;
      },
      setSkewX: function(newSkewX) {
        this._skewX = newSkewX;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getSkewY: function() {
        return this._skewY;
      },
      setSkewY: function(newSkewY) {
        this._skewY = newSkewY;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      setLocalZOrder: function(localZOrder) {
        this._parent ? this._parent.reorderChild(this, localZOrder) : this._localZOrder = localZOrder;
        eventManager._setDirtyForNode(this);
      },
      _setLocalZOrder: function(localZOrder) {
        this._localZOrder = localZOrder;
      },
      getLocalZOrder: function() {
        return this._localZOrder;
      },
      getZOrder: function() {
        cc.logID(1600);
        return this.getLocalZOrder();
      },
      setZOrder: function(z) {
        cc.logID(1601);
        this.setLocalZOrder(z);
      },
      setGlobalZOrder: function(globalZOrder) {
        if (this._globalZOrder !== globalZOrder) {
          this._globalZOrder = globalZOrder;
          eventManager._setDirtyForNode(this);
        }
      },
      getGlobalZOrder: function() {
        return this._globalZOrder;
      },
      getVertexZ: function() {
        return this._vertexZ;
      },
      setVertexZ: function(Var) {
        this._customZ = this._vertexZ = Var;
      },
      getRotation: function() {
        this._rotationX !== this._rotationY && cc.logID(1602);
        return this._rotationX;
      },
      setRotation: function(newRotation) {
        this._rotationX = this._rotationY = newRotation;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getRotationX: function() {
        return this._rotationX;
      },
      setRotationX: function(rotationX) {
        this._rotationX = rotationX;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getRotationY: function() {
        return this._rotationY;
      },
      setRotationY: function(rotationY) {
        this._rotationY = rotationY;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getScale: function() {
        this._scaleX !== this._scaleY && cc.logID(1603);
        return this._scaleX;
      },
      setScale: function(scale, scaleY) {
        this._scaleX = scale;
        this._scaleY = scaleY || 0 === scaleY ? scaleY : scale;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getScaleX: function() {
        return this._scaleX;
      },
      setScaleX: function(newScaleX) {
        this._scaleX = newScaleX;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getScaleY: function() {
        return this._scaleY;
      },
      setScaleY: function(newScaleY) {
        this._scaleY = newScaleY;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      setPosition: function(newPosOrxValue, yValue) {
        var locPosition = this._position;
        if (void 0 === yValue) {
          if (locPosition.x === newPosOrxValue.x && locPosition.y === newPosOrxValue.y) return;
          locPosition.x = newPosOrxValue.x;
          locPosition.y = newPosOrxValue.y;
        } else {
          if (locPosition.x === newPosOrxValue && locPosition.y === yValue) return;
          locPosition.x = newPosOrxValue;
          locPosition.y = yValue;
        }
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getPosition: function() {
        return cc.p(this._position);
      },
      getPositionX: function() {
        return this._position.x;
      },
      setPositionX: function(x) {
        this._position.x = x;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getPositionY: function() {
        return this._position.y;
      },
      setPositionY: function(y) {
        this._position.y = y;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getChildrenCount: function() {
        return this._children.length;
      },
      getChildren: function() {
        return this._children;
      },
      isVisible: function() {
        return this._visible;
      },
      setVisible: function(visible) {
        if (this._visible !== visible) {
          this._visible = visible;
          this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
          cc.renderer.childrenOrderDirty = true;
        }
      },
      getAnchorPoint: function() {
        return cc.p(this._anchorPoint);
      },
      setAnchorPoint: function(point, y) {
        var locAnchorPoint = this._anchorPoint;
        if (void 0 === y) {
          if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) return;
          locAnchorPoint.x = point.x;
          locAnchorPoint.y = point.y;
        } else {
          if (point === locAnchorPoint.x && y === locAnchorPoint.y) return;
          locAnchorPoint.x = point;
          locAnchorPoint.y = y;
        }
        this._renderCmd._updateAnchorPointInPoint();
      },
      _getAnchorX: function() {
        return this._anchorPoint.x;
      },
      _setAnchorX: function(x) {
        if (this._anchorPoint.x === x) return;
        this._anchorPoint.x = x;
        this._renderCmd._updateAnchorPointInPoint();
      },
      _getAnchorY: function() {
        return this._anchorPoint.y;
      },
      _setAnchorY: function(y) {
        if (this._anchorPoint.y === y) return;
        this._anchorPoint.y = y;
        this._renderCmd._updateAnchorPointInPoint();
      },
      getAnchorPointInPoints: function() {
        return this._renderCmd.getAnchorPointInPoints();
      },
      _getWidth: function() {
        return this._contentSize.width;
      },
      _setWidth: function(width) {
        this._contentSize.width = width;
        this._renderCmd._updateAnchorPointInPoint();
      },
      _getHeight: function() {
        return this._contentSize.height;
      },
      _setHeight: function(height) {
        this._contentSize.height = height;
        this._renderCmd._updateAnchorPointInPoint();
      },
      getContentSize: function() {
        return cc.size(this._contentSize);
      },
      setContentSize: function(size, height) {
        var locContentSize = this._contentSize;
        if (void 0 === height) {
          if (size.width === locContentSize.width && size.height === locContentSize.height) return;
          locContentSize.width = size.width;
          locContentSize.height = size.height;
        } else {
          if (size === locContentSize.width && height === locContentSize.height) return;
          locContentSize.width = size;
          locContentSize.height = height;
        }
        this._renderCmd._updateAnchorPointInPoint();
      },
      isRunning: function() {
        return this._running;
      },
      getParent: function() {
        return this._parent;
      },
      setParent: function(parent) {
        this._parent = parent;
        var dirtyFlags = _ccsg.Node._dirtyFlags;
        this._renderCmd.setDirtyFlag(dirtyFlags.transformDirty | dirtyFlags.opacityDirty);
      },
      isIgnoreAnchorPointForPosition: function() {
        return this._ignoreAnchorPointForPosition;
      },
      setIgnoreAnchorPointForPosition: function(newValue) {
        if (newValue !== this._ignoreAnchorPointForPosition) {
          this._ignoreAnchorPointForPosition = newValue;
          this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
        }
      },
      getTag: function() {
        return this.tag;
      },
      setTag: function(tag) {
        this.tag = tag;
      },
      setName: function(name) {
        this._name = name;
      },
      getName: function() {
        return this._name;
      },
      updateOrderOfArrival: function() {
        this._arrivalOrder = ++cc.s_globalOrderOfArrival;
      },
      getScheduler: function() {
        return this._scheduler || cc.director.getScheduler();
      },
      setScheduler: function(scheduler) {
        if (this._scheduler !== scheduler) {
          this.unscheduleAllCallbacks();
          this._scheduler = scheduler;
        }
      },
      boundingBox: function() {
        cc.logID(1608);
        return this.getBoundingBox();
      },
      getBoundingBox: function() {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc._rectApplyAffineTransformIn(rect, this.getNodeToParentTransform());
      },
      cleanup: function() {
        this.stopAllActions();
        this.unscheduleAllCallbacks();
        eventManager.removeListeners(this);
      },
      getChildByTag: function(aTag) {
        var __children = this._children;
        if (null !== __children) for (var i = 0; i < __children.length; i++) {
          var node = __children[i];
          if (node && node.tag === aTag) return node;
        }
        return null;
      },
      getChildByName: function(name) {
        if (!name) {
          cc.log("Invalid name");
          return null;
        }
        var locChildren = this._children;
        for (var i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._name === name) return locChildren[i];
        return null;
      },
      addChild: function(child, localZOrder, tag) {
        localZOrder = void 0 === localZOrder ? child._localZOrder : localZOrder;
        var name, setTag = false;
        if (void 0 === tag) name = child._name; else if ("string" === typeof tag) {
          name = tag;
          tag = void 0;
        } else if ("number" === typeof tag) {
          setTag = true;
          name = "";
        }
        cc.assertID(child, 1606);
        cc.assertID(null === child._parent, 1605);
        this._addChildHelper(child, localZOrder, tag, name, setTag);
      },
      _addChildHelper: function(child, localZOrder, tag, name, setTag) {
        this._children || (this._children = []);
        this._insertChild(child, localZOrder);
        setTag ? child.setTag(tag) : child.setName(name);
        child.setParent(this);
        child.updateOrderOfArrival();
        if (this._running) {
          child.performRecursive(_ccsg.Node.performType.onEnter);
          this._isTransitionFinished && child.performRecursive(_ccsg.Node.performType.onEnterTransitionDidFinish);
        }
        child._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
        this._cascadeColorEnabled && child._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty);
        this._cascadeOpacityEnabled && child._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.opacityDirty);
      },
      removeFromParent: function(cleanup) {
        if (this._parent) {
          void 0 === cleanup && (cleanup = true);
          this._parent.removeChild(this, cleanup);
        }
      },
      removeFromParentAndCleanup: function(cleanup) {
        cc.logID(1607);
        this.removeFromParent(cleanup);
      },
      removeChild: function(child, cleanup) {
        if (0 === this._children.length) return;
        void 0 === cleanup && (cleanup = true);
        this._children.indexOf(child) > -1 && this._detachChild(child, cleanup);
        cc.renderer.childrenOrderDirty = true;
      },
      removeChildByTag: function(tag, cleanup) {
        tag === cc.macro.NODE_TAG_INVALID && cc.logID(1609);
        var child = this.getChildByTag(tag);
        child ? this.removeChild(child, cleanup) : cc.logID(1610, tag);
      },
      removeAllChildrenWithCleanup: function(cleanup) {
        this.removeAllChildren(cleanup);
      },
      removeAllChildren: function(cleanup) {
        var __children = this._children;
        if (null !== __children) {
          void 0 === cleanup && (cleanup = true);
          for (var i = 0; i < __children.length; i++) {
            var node = __children[i];
            if (node) {
              if (this._running) {
                node.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
                node.performRecursive(_ccsg.Node.performType.onExit);
              }
              cleanup && node.performRecursive(_ccsg.Node.performType.cleanup);
              node.parent = null;
              node._renderCmd.detachFromParent();
            }
          }
          this._children.length = 0;
          cc.renderer.childrenOrderDirty = true;
        }
      },
      _detachChild: function(child, doCleanup) {
        if (this._running) {
          child.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
          child.performRecursive(_ccsg.Node.performType.onExit);
        }
        doCleanup && child.performRecursive(_ccsg.Node.performType.cleanup);
        child.parent = null;
        child._renderCmd.detachFromParent();
        cc.js.array.remove(this._children, child);
      },
      _insertChild: function(child, z) {
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = true;
        this._children.push(child);
        child._setLocalZOrder(z);
      },
      setNodeDirty: function() {
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      reorderChild: function(child, zOrder) {
        cc.assertID(child, 1617);
        if (-1 === this._children.indexOf(child)) {
          cc.logID(1635);
          return;
        }
        if (zOrder === child.zIndex) return;
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = true;
        child.updateOrderOfArrival();
        child._setLocalZOrder(zOrder);
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.orderDirty);
      },
      sortAllChildren: function() {
        if (this._reorderChildDirty) {
          var _children = this._children;
          var len = _children.length, i, j, tmp;
          for (i = 1; i < len; i++) {
            tmp = _children[i];
            j = i - 1;
            while (j >= 0) {
              if (tmp._localZOrder < _children[j]._localZOrder) _children[j + 1] = _children[j]; else {
                if (!(tmp._localZOrder === _children[j]._localZOrder && tmp._arrivalOrder < _children[j]._arrivalOrder)) break;
                _children[j + 1] = _children[j];
              }
              j--;
            }
            _children[j + 1] = tmp;
          }
          this._reorderChildDirty = false;
        }
      },
      draw: function(ctx) {},
      transformAncestors: function() {
        if (null !== this._parent) {
          this._parent.transformAncestors();
          this._parent.transform();
        }
      },
      onEnter: function() {
        this._isTransitionFinished = false;
        this._running = true;
        this.resume();
      },
      performRecursive: function(callbackType) {
        var nodeCallbackType = _ccsg.Node.performType;
        if (callbackType >= nodeCallbackType.max) return;
        var index = 0;
        var children, child, curr, i, len;
        var stack = _ccsg.Node._performStacks[_ccsg.Node._performing];
        if (!stack) {
          stack = [];
          _ccsg.Node._performStacks.push(stack);
        }
        stack.length = 0;
        _ccsg.Node._performing++;
        curr = stack[0] = this;
        while (curr) {
          children = curr._children;
          if (children && children.length > 0) for (i = 0, len = children.length; i < len; ++i) {
            child = children[i];
            stack.push(child);
          }
          index++;
          curr = stack[index];
        }
        switch (callbackType) {
         case nodeCallbackType.onEnter:
          for (i = stack.length - 1; i >= 0; --i) {
            curr = stack[i];
            stack[i] = null;
            if (!curr) continue;
            curr.onEnter();
          }
          break;

         case nodeCallbackType.onExit:
          for (i = stack.length - 1; i >= 0; --i) {
            curr = stack[i];
            stack[i] = null;
            if (!curr) continue;
            curr.onExit();
          }
          break;

         case nodeCallbackType.onEnterTransitionDidFinish:
          for (i = stack.length - 1; i >= 0; --i) {
            curr = stack[i];
            stack[i] = null;
            if (!curr) continue;
            curr.onEnterTransitionDidFinish();
          }
          break;

         case nodeCallbackType.cleanup:
          for (i = stack.length - 1; i >= 0; --i) {
            curr = stack[i];
            stack[i] = null;
            if (!curr) continue;
            curr.cleanup();
          }
          break;

         case nodeCallbackType.onExitTransitionDidStart:
          for (i = stack.length - 1; i >= 0; --i) {
            curr = stack[i];
            stack[i] = null;
            if (!curr) continue;
            curr.onExitTransitionDidStart();
          }
        }
        _ccsg.Node._performing--;
      },
      onEnterTransitionDidFinish: function() {
        this._isTransitionFinished = true;
      },
      onExitTransitionDidStart: function() {},
      onExit: function() {
        this._running = false;
        this.pause();
      },
      runAction: ActionManagerExist ? function(action) {
        cc.assertID(action, 1618);
        cc.director.getActionManager().addAction(action, this, !this._running);
        return action;
      } : emptyFunc,
      stopAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().removeAllActionsFromTarget(this);
      } : emptyFunc,
      stopAction: ActionManagerExist ? function(action) {
        cc.director.getActionManager().removeAction(action);
      } : emptyFunc,
      stopActionByTag: ActionManagerExist ? function(tag) {
        if (tag === cc.Action.TAG_INVALID) {
          cc.logID(1612);
          return;
        }
        cc.director.getActionManager().removeActionByTag(tag, this);
      } : emptyFunc,
      getActionByTag: ActionManagerExist ? function(tag) {
        if (tag === cc.Action.TAG_INVALID) {
          cc.logID(1613);
          return null;
        }
        return cc.director.getActionManager().getActionByTag(tag, this);
      } : function() {
        return null;
      },
      getNumberOfRunningActions: ActionManagerExist ? function() {
        return cc.director.getActionManager().getNumberOfRunningActionsInTarget(this);
      } : function() {
        return 0;
      },
      scheduleUpdate: function() {
        this.scheduleUpdateWithPriority(0);
      },
      scheduleUpdateWithPriority: function(priority) {
        this.scheduler.scheduleUpdate(this, priority, !this._running);
      },
      unscheduleUpdate: function() {
        this.scheduler.unscheduleUpdate(this);
      },
      schedule: function(callback, interval, repeat, delay, key) {
        var len = arguments.length;
        if ("function" === typeof callback) if (1 === len) {
          interval = 0;
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
          key = this.__instanceId;
        } else if (2 === len) if ("number" === typeof interval) {
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
          key = this.__instanceId;
        } else {
          key = interval;
          interval = 0;
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
        } else if (3 === len) {
          if ("string" === typeof repeat) {
            key = repeat;
            repeat = cc.macro.REPEAT_FOREVER;
          } else key = this.__instanceId;
          delay = 0;
        } else 4 === len && (key = this.__instanceId); else if (1 === len) {
          interval = 0;
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
        } else if (2 === len) {
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
        }
        cc.assertID(callback, 1619);
        cc.assertID(interval >= 0, 1620);
        interval = interval || 0;
        repeat = isNaN(repeat) ? cc.macro.REPEAT_FOREVER : repeat;
        delay = delay || 0;
        this.scheduler.schedule(callback, this, interval, repeat, delay, !this._running, key);
      },
      scheduleOnce: function(callback, delay, key) {
        void 0 === key && (key = this.__instanceId);
        this.schedule(callback, 0, 0, delay, key);
      },
      unschedule: function(callback_fn) {
        if (!callback_fn) return;
        this.scheduler.unschedule(callback_fn, this);
      },
      unscheduleAllCallbacks: function() {
        this.scheduler.unscheduleAllForTarget(this);
      },
      resumeSchedulerAndActions: function() {
        cc.logID(1614);
        this.resume();
      },
      resume: function() {
        this.scheduler.resumeTarget(this);
        ActionManagerExist && cc.director.getActionManager().resumeTarget(this);
        eventManager.resumeTarget(this);
      },
      pauseSchedulerAndActions: function() {
        cc.logID(1615);
        this.pause();
      },
      pause: function() {
        this.scheduler.pauseTarget(this);
        ActionManagerExist && cc.director.getActionManager().pauseTarget(this);
        eventManager.pauseTarget(this);
      },
      getParentToNodeTransform: function() {
        return this._renderCmd.getParentToNodeTransform();
      },
      parentToNodeTransform: function() {
        return this.getParentToNodeTransform();
      },
      getNodeToWorldTransform: function() {
        var t = cc.affineTransformClone(this.getNodeToParentTransform());
        for (var p = this._parent; null !== p; p = p.parent) t = cc.affineTransformConcatIn(t, p.getNodeToParentTransform());
        return t;
      },
      nodeToWorldTransform: function() {
        return this.getNodeToWorldTransform();
      },
      getWorldToNodeTransform: function() {
        var trans = this.getNodeToWorldTransform();
        cc.affineTransformInvertOut(trans, trans);
        return trans;
      },
      worldToNodeTransform: function() {
        return this.getWorldToNodeTransform();
      },
      convertToNodeSpace: function(worldPoint) {
        return cc.pointApplyAffineTransform(worldPoint, this.getWorldToNodeTransform());
      },
      convertToWorldSpace: function(nodePoint) {
        nodePoint = nodePoint || cc.v2(0, 0);
        return cc.pointApplyAffineTransform(nodePoint, this.getNodeToWorldTransform());
      },
      convertToNodeSpaceAR: function(worldPoint) {
        return cc.pSub(this.convertToNodeSpace(worldPoint), this._renderCmd.getAnchorPointInPoints());
      },
      convertToWorldSpaceAR: function(nodePoint) {
        nodePoint = nodePoint || cc.v2(0, 0);
        var pt = cc.pAdd(nodePoint, this._renderCmd.getAnchorPointInPoints());
        return this.convertToWorldSpace(pt);
      },
      _convertToWindowSpace: function(nodePoint) {
        var worldPoint = this.convertToWorldSpace(nodePoint);
        return cc.director.convertToUI(worldPoint);
      },
      convertTouchToNodeSpace: function(touch) {
        var point = touch.getLocation();
        return this.convertToNodeSpace(point);
      },
      convertTouchToNodeSpaceAR: function(touch) {
        var point = cc.director.convertToGL(touch.getLocation());
        return this.convertToNodeSpaceAR(point);
      },
      updateTransform: function() {
        var children = this._children, node;
        for (var i = 0; i < children.length; i++) {
          var node = children[i];
          node && node.updateTransform();
        }
      },
      retain: function() {},
      release: function() {},
      visit: function(parent) {
        var cmd = this._renderCmd, parentCmd = parent ? parent._renderCmd : null;
        if (!this._visible) {
          cmd._propagateFlagsDown(parentCmd);
          return;
        }
        var renderer = cc.renderer;
        cmd.visit(parentCmd);
        var i, children = this._children, len = children.length, child;
        if (len > 0) {
          this._reorderChildDirty && this.sortAllChildren();
          for (i = 0; i < len; i++) {
            child = children[i];
            if (!(child._localZOrder < 0)) break;
            child.visit(this);
          }
          renderer.pushRenderCommand(cmd);
          for (;i < len; i++) children[i].visit(this);
        } else renderer.pushRenderCommand(cmd);
        cmd._dirtyFlag = 0;
      },
      transform: function(parentCmd, recursive) {
        this._renderCmd.transform(parentCmd, recursive);
      },
      nodeToParentTransform: function() {
        return this.getNodeToParentTransform();
      },
      getNodeToParentTransform: function(ancestor) {
        var t = this._renderCmd.getNodeToParentTransform();
        if (ancestor) {
          var T = {
            a: t.a,
            b: t.b,
            c: t.c,
            d: t.d,
            tx: t.tx,
            ty: t.ty
          };
          for (var p = this._parent; null != p && p != ancestor; p = p.getParent()) cc.affineTransformConcatIn(T, p.getNodeToParentTransform());
          return T;
        }
        return t;
      },
      getNodeToParentAffineTransform: function(ancestor) {
        return this.getNodeToParentTransform(ancestor);
      },
      getShaderProgram: function() {
        return this._renderCmd.getShaderProgram();
      },
      setShaderProgram: function(newShaderProgram) {
        this._renderCmd.setShaderProgram(newShaderProgram);
      },
      getGLServerState: function() {
        return 0;
      },
      setGLServerState: function(state) {},
      getBoundingBoxToWorld: function() {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        var trans = this.getNodeToWorldTransform();
        cc._rectApplyAffineTransformIn(rect, trans);
        if (!this._children) return rect;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
          var child = locChildren[i];
          if (child && child._visible) {
            var childRect = child._getBoundingBoxToCurrentNode(trans);
            childRect && (rect = cc.rectUnion(rect, childRect));
          }
        }
        return rect;
      },
      _getBoundingBoxToCurrentNode: function(parentTransform) {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        var trans = void 0 === parentTransform ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), parentTransform);
        cc._rectApplyAffineTransformIn(rect, trans);
        if (!this._children) return rect;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
          var child = locChildren[i];
          if (child && child._visible) {
            var childRect = child._getBoundingBoxToCurrentNode(trans);
            childRect && (rect = cc.rectUnion(rect, childRect));
          }
        }
        return rect;
      },
      getOpacity: function() {
        return this._realOpacity;
      },
      getDisplayedOpacity: function() {
        return this._renderCmd.getDisplayedOpacity();
      },
      setOpacity: function(opacity) {
        this._realOpacity = opacity;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.opacityDirty);
      },
      updateDisplayedOpacity: function(parentOpacity) {
        this._renderCmd._updateDisplayOpacity(parentOpacity);
      },
      isCascadeOpacityEnabled: function() {
        return this._cascadeOpacityEnabled;
      },
      setCascadeOpacityEnabled: function(cascadeOpacityEnabled) {
        if (this._cascadeOpacityEnabled === cascadeOpacityEnabled) return;
        this._cascadeOpacityEnabled = cascadeOpacityEnabled;
        this._renderCmd.setCascadeOpacityEnabledDirty();
      },
      getColor: function() {
        var locRealColor = this._realColor;
        return cc.color(locRealColor.r, locRealColor.g, locRealColor.b, locRealColor.a);
      },
      getDisplayedColor: function() {
        return this._renderCmd.getDisplayedColor();
      },
      setColor: function(color) {
        var locRealColor = this._realColor;
        locRealColor.r = color.r;
        locRealColor.g = color.g;
        locRealColor.b = color.b;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty);
      },
      updateDisplayedColor: function(parentColor) {
        this._renderCmd._updateDisplayColor(parentColor);
      },
      isCascadeColorEnabled: function() {
        return this._cascadeColorEnabled;
      },
      setCascadeColorEnabled: function(cascadeColorEnabled) {
        if (this._cascadeColorEnabled === cascadeColorEnabled) return;
        this._cascadeColorEnabled = cascadeColorEnabled;
        this._renderCmd.setCascadeColorEnabledDirty();
      },
      setOpacityModifyRGB: function(opacityValue) {},
      isOpacityModifyRGB: function() {
        return false;
      },
      _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new _ccsg.Node.CanvasRenderCmd(this) : new _ccsg.Node.WebGLRenderCmd(this);
      }
    });
    _ccsg.Node.extend = cc._Class.extend;
    _ccsg.Node.prototype.ctor = _ccsg.Node;
    _ccsg.Node.performType = {
      onEnter: 1,
      onExit: 2,
      cleanup: 3,
      onEnterTransitionDidFinish: 4,
      onExitTransitionDidStart: 5,
      max: 6
    };
    _ccsg.Node._performStacks = [ [] ];
    _ccsg.Node._performing = 0;
    var SameNameGetSets = [ "skewX", "skewY", "vertexZ", "rotation", "rotationX", "rotationY", "scale", "scaleX", "scaleY", "children", "childrenCount", "parent", "scheduler", "shaderProgram", "opacity", "color" ];
    var DiffNameGetSets = {
      x: [ "getPositionX", "setPositionX" ],
      y: [ "getPositionY", "setPositionY" ],
      width: [ "_getWidth", "_setWidth" ],
      height: [ "_getHeight", "_setHeight" ],
      anchorX: [ "_getAnchorX", "_setAnchorX" ],
      anchorY: [ "_getAnchorY", "_setAnchorY" ],
      zIndex: [ "getLocalZOrder", "setLocalZOrder" ],
      visible: [ "isVisible", "setVisible" ],
      running: [ "isRunning" ],
      ignoreAnchor: [ "isIgnoreAnchorPointForPosition", "setIgnoreAnchorPointForPosition" ],
      opacityModifyRGB: [ "isOpacityModifyRGB", "setOpacityModifyRGB" ],
      cascadeOpacity: [ "isCascadeOpacityEnabled", "setCascadeOpacityEnabled" ],
      cascadeColor: [ "isCascadeColorEnabled", "setCascadeColorEnabled" ]
    };
    Misc.propertyDefine(_ccsg.Node, SameNameGetSets, DiffNameGetSets);
  }), {
    "../event-manager": 58,
    "../utils/misc": 137
  } ],
  33: [ (function(require, module, exports) {
    cc.CustomRenderCmd = function(target, func) {
      this._needDraw = true;
      this._target = target;
      this._callback = func;
    };
    cc.CustomRenderCmd.prototype.rendering = function(ctx, scaleX, scaleY) {
      if (!this._callback) return;
      this._callback.call(this._target, ctx, scaleX, scaleY);
    };
    var dirtyFlags = _ccsg.Node._dirtyFlags = {
      transformDirty: 1,
      visibleDirty: 2,
      colorDirty: 4,
      opacityDirty: 8,
      cacheDirty: 16,
      orderDirty: 32,
      textDirty: 64,
      gradientDirty: 128,
      textureDirty: 256,
      contentDirty: 512,
      cullingDirty: 1024,
      COUNT: 9
    };
    cc.js.get(dirtyFlags, "all", (function() {
      var count = dirtyFlags.COUNT;
      return (1 << count) - 1;
    }), false);
    _ccsg.Node._requestDirtyFlag = function(key) {
      cc.assertID(!dirtyFlags[key], 1622, key);
      var count = dirtyFlags.COUNT;
      var value = 1 << count;
      dirtyFlags[key] = value;
      dirtyFlags.COUNT++;
      return value;
    };
    var ONE_DEGREE = Math.PI / 180;
    function walkChildTree(root, funcName) {
      var index = 1;
      var children, child, curr, parentCmd, i, len;
      var stack = _ccsg.Node._performStacks[_ccsg.Node._performing];
      if (!stack) {
        stack = [];
        _ccsg.Node._performStacks.push(stack);
      }
      stack.length = 0;
      _ccsg.Node._performing++;
      stack[0] = root;
      var childChildren;
      while (index) {
        index--;
        curr = stack[index];
        stack[index] = null;
        if (!curr) continue;
        children = curr._children;
        if (children && children.length > 0) {
          parentCmd = curr._renderCmd;
          for (i = 0, len = children.length; i < len; ++i) {
            child = children[i];
            stack[index] = child;
            index++;
            child._renderCmd[funcName](parentCmd);
          }
        }
      }
      _ccsg.Node._performing--;
    }
    _ccsg.Node.RenderCmd = function(renderable) {
      this._node = renderable;
      this._anchorPointInPoints = new cc.Vec2(0, 0);
      this._needDraw = false;
      this._dirtyFlag = 1;
      this._curLevel = -1;
      this._cameraFlag = 0;
      this._displayedColor = new cc.Color(255, 255, 255, 255);
      this._displayedOpacity = 255;
      this._cascadeColorEnabledDirty = false;
      this._cascadeOpacityEnabledDirty = false;
      this._transform = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
      };
      this._worldTransform = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
      };
      this._inverse = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
      };
      this._transformUpdated = false;
      cc.renderer.pushDirtyNode(this);
    };
    _ccsg.Node.RenderCmd.prototype = {
      constructor: _ccsg.Node.RenderCmd,
      _ctor: _ccsg.Node.RenderCmd,
      getAnchorPointInPoints: function() {
        return cc.p(this._anchorPointInPoints);
      },
      getDisplayedColor: function() {
        var tmpColor = this._displayedColor;
        return cc.color(tmpColor.r, tmpColor.g, tmpColor.b, tmpColor.a);
      },
      getDisplayedOpacity: function() {
        return this._displayedOpacity;
      },
      setCascadeColorEnabledDirty: function() {
        this._cascadeColorEnabledDirty = true;
        this.setDirtyFlag(dirtyFlags.colorDirty);
      },
      setCascadeOpacityEnabledDirty: function() {
        this._cascadeOpacityEnabledDirty = true;
        this.setDirtyFlag(dirtyFlags.opacityDirty);
      },
      getParentToNodeTransform: function() {
        this._dirtyFlag & dirtyFlags.transformDirty && cc.affineTransformInvertOut(this.getNodeToParentTransform(), this._inverse);
        return this._inverse;
      },
      detachFromParent: function() {},
      _updateAnchorPointInPoint: function() {
        var locAPP = this._anchorPointInPoints, locSize = this._node._contentSize, locAnchorPoint = this._node._anchorPoint;
        locAPP.x = locSize.width * locAnchorPoint.x;
        locAPP.y = locSize.height * locAnchorPoint.y;
        this.setDirtyFlag(dirtyFlags.transformDirty);
      },
      setDirtyFlag: function(dirtyFlag) {
        0 === this._dirtyFlag && 0 !== dirtyFlag && cc.renderer.pushDirtyNode(this);
        this._dirtyFlag |= dirtyFlag;
      },
      getParentRenderCmd: function() {
        if (this._node && this._node._parent && this._node._parent._renderCmd) return this._node._parent._renderCmd;
        return null;
      },
      updateTransform: function(parentCmd, recursive) {
        var node = this._node, pt = parentCmd ? parentCmd._worldTransform : null, t = this._transform, wt = this._worldTransform;
        if (!this._transformUpdated) {
          var hasRotation = node._rotationX || node._rotationY;
          var hasSkew = node._skewX || node._skewY;
          var sx = node._scaleX, sy = node._scaleY;
          var appX = this._anchorPointInPoints.x, appY = this._anchorPointInPoints.y;
          var a = 1, b = 0, c = 0, d = 1;
          if (hasRotation || hasSkew) {
            t.tx = node._position.x;
            t.ty = node._position.y;
            if (hasRotation) {
              var rotationRadiansX = node._rotationX * ONE_DEGREE;
              c = Math.sin(rotationRadiansX);
              d = Math.cos(rotationRadiansX);
              if (node._rotationY === node._rotationX) {
                a = d;
                b = -c;
              } else {
                var rotationRadiansY = node._rotationY * ONE_DEGREE;
                a = Math.cos(rotationRadiansY);
                b = -Math.sin(rotationRadiansY);
              }
            }
            t.a = a *= sx;
            t.b = b *= sx;
            t.c = c *= sy;
            t.d = d *= sy;
            if (hasSkew) {
              var skx = Math.tan(node._skewX * ONE_DEGREE);
              var sky = Math.tan(node._skewY * ONE_DEGREE);
              Infinity === skx && (skx = 99999999);
              Infinity === sky && (sky = 99999999);
              t.a = a + c * sky;
              t.b = b + d * sky;
              t.c = c + a * skx;
              t.d = d + b * skx;
            }
            if (appX || appY) {
              t.tx -= t.a * appX + t.c * appY;
              t.ty -= t.b * appX + t.d * appY;
              if (node._ignoreAnchorPointForPosition) {
                t.tx += appX;
                t.ty += appY;
              }
            }
          } else {
            t.a = sx;
            t.b = 0;
            t.c = 0;
            t.d = sy;
            t.tx = node._position.x;
            t.ty = node._position.y;
            if (appX || appY) {
              t.tx -= t.a * appX;
              t.ty -= t.d * appY;
              if (node._ignoreAnchorPointForPosition) {
                t.tx += appX;
                t.ty += appY;
              }
            }
          }
        }
        if (pt) {
          wt.a = t.a * pt.a + t.b * pt.c;
          wt.b = t.a * pt.b + t.b * pt.d;
          wt.c = t.c * pt.a + t.d * pt.c;
          wt.d = t.c * pt.b + t.d * pt.d;
          wt.tx = t.tx * pt.a + t.ty * pt.c + pt.tx;
          wt.ty = t.tx * pt.b + t.ty * pt.d + pt.ty;
        } else {
          wt.a = t.a;
          wt.b = t.b;
          wt.c = t.c;
          wt.d = t.d;
          wt.tx = t.tx;
          wt.ty = t.ty;
        }
      },
      transform: function(parentCmd, recursive) {
        this.updateTransform(parentCmd);
        if (this._currentRegion) {
          this._updateCurrentRegions();
          this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.DirtyDouble);
        }
        if (cc.macro.ENABLE_CULLING) {
          this._updateCameraFlag(parentCmd);
          this._doCulling && this._doCulling();
        } else this._doCulling && (this._needDraw = true);
        recursive && walkChildTree(this._node, "transform");
      },
      _updateCameraFlag: function(parentCmd) {
        var Camera = cc.Camera;
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && Camera && parentCmd && this._cameraFlag != Camera.flags.InCamera && (this._cameraFlag = parentCmd._cameraFlag > 0 ? Camera.flags.ParentInCamera : 0);
      },
      culling: function(parentCmd, recursive) {
        if (!cc.macro.ENABLE_CULLING) {
          this._doCulling && (this._needDraw = true);
          return;
        }
        this._updateCameraFlag(parentCmd);
        this._doCulling && this._doCulling();
        recursive && walkChildTree(this._node, "culling");
      },
      getNodeToParentTransform: function() {
        this._dirtyFlag & dirtyFlags.transformDirty && this.transform();
        return this._transform;
      },
      setNodeToParentTransform: function(transform) {
        if (transform) {
          this._transform = transform;
          this._transformUpdated = true;
        } else this._transformUpdated = false;
        this.setDirtyFlag(dirtyFlags.transformDirty);
      },
      _propagateFlagsDown: function(parentCmd) {
        if (!parentCmd) return;
        var locFlag = this._dirtyFlag;
        var parentNode = parentCmd._node;
        var parentFlag = parentCmd._dirtyFlag;
        parentNode._cascadeColorEnabled && parentFlag & dirtyFlags.colorDirty && (locFlag |= dirtyFlags.colorDirty);
        parentNode._cascadeOpacityEnabled && parentFlag & dirtyFlags.opacityDirty && (locFlag |= dirtyFlags.opacityDirty);
        parentFlag & dirtyFlags.transformDirty && (locFlag |= dirtyFlags.transformDirty);
        parentFlag & dirtyFlags.cullingDirty && (locFlag |= dirtyFlags.cullingDirty);
        this._dirtyFlag = locFlag;
      },
      visit: function(parentCmd) {
        var node = this._node, renderer = cc.renderer;
        parentCmd && (this._curLevel = parentCmd._curLevel + 1);
        this._propagateFlagsDown(parentCmd);
        if (isNaN(node._customZ)) {
          node._vertexZ = renderer.assignedZ;
          renderer.assignedZ += renderer.assignedZStep;
        }
        this._syncStatus(parentCmd);
      },
      _updateDisplayColor: function(parentColor) {
        var node = this._node;
        var locDispColor = this._displayedColor, locRealColor = node._realColor;
        var i, len, selChildren, item;
        this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
        if (this._cascadeColorEnabledDirty && !node._cascadeColorEnabled) {
          locDispColor.r = locRealColor.r;
          locDispColor.g = locRealColor.g;
          locDispColor.b = locRealColor.b;
          var whiteColor = new cc.Color(255, 255, 255, 255);
          selChildren = node._children;
          for (i = 0, len = selChildren.length; i < len; i++) {
            item = selChildren[i];
            item && item._renderCmd && item._renderCmd._updateDisplayColor(whiteColor);
          }
          this._cascadeColorEnabledDirty = false;
        } else {
          if (void 0 === parentColor) {
            var locParent = node._parent;
            parentColor = locParent && locParent._cascadeColorEnabled ? locParent.getDisplayedColor() : cc.Color.WHITE;
          }
          locDispColor.r = 0 | locRealColor.r * parentColor.r / 255;
          locDispColor.g = 0 | locRealColor.g * parentColor.g / 255;
          locDispColor.b = 0 | locRealColor.b * parentColor.b / 255;
          if (node._cascadeColorEnabled) {
            selChildren = node._children;
            for (i = 0, len = selChildren.length; i < len; i++) {
              item = selChildren[i];
              if (item && item._renderCmd) {
                item._renderCmd._updateDisplayColor(locDispColor);
                item._renderCmd._updateColor();
              }
            }
          }
        }
        this._dirtyFlag &= ~dirtyFlags.colorDirty;
      },
      _updateDisplayOpacity: function(parentOpacity) {
        var node = this._node;
        var i, len, selChildren, item;
        this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
        if (this._cascadeOpacityEnabledDirty && !node._cascadeOpacityEnabled) {
          this._displayedOpacity = node._realOpacity;
          selChildren = node._children;
          for (i = 0, len = selChildren.length; i < len; i++) {
            item = selChildren[i];
            item && item._renderCmd && item._renderCmd._updateDisplayOpacity(255);
          }
          this._cascadeOpacityEnabledDirty = false;
        } else {
          if (void 0 === parentOpacity) {
            var locParent = node._parent;
            parentOpacity = 255;
            locParent && locParent._cascadeOpacityEnabled && (parentOpacity = locParent.getDisplayedOpacity());
          }
          this._displayedOpacity = node._realOpacity * parentOpacity / 255;
          if (node._cascadeOpacityEnabled) {
            selChildren = node._children;
            for (i = 0, len = selChildren.length; i < len; i++) {
              item = selChildren[i];
              if (item && item._renderCmd) {
                item._renderCmd._updateDisplayOpacity(this._displayedOpacity);
                item._renderCmd._updateColor();
              }
            }
          }
        }
        this._dirtyFlag &= ~dirtyFlags.opacityDirty;
      },
      _syncDisplayColor: function(parentColor) {
        var node = this._node, locDispColor = this._displayedColor, locRealColor = node._realColor;
        if (void 0 === parentColor) {
          var locParent = node._parent;
          parentColor = locParent && locParent._cascadeColorEnabled ? locParent.getDisplayedColor() : cc.Color.WHITE;
        }
        locDispColor.r = 0 | locRealColor.r * parentColor.r / 255;
        locDispColor.g = 0 | locRealColor.g * parentColor.g / 255;
        locDispColor.b = 0 | locRealColor.b * parentColor.b / 255;
      },
      _syncDisplayOpacity: function(parentOpacity) {
        var node = this._node;
        if (void 0 === parentOpacity) {
          var locParent = node._parent;
          parentOpacity = 255;
          locParent && locParent._cascadeOpacityEnabled && (parentOpacity = locParent.getDisplayedOpacity());
        }
        this._displayedOpacity = node._realOpacity * parentOpacity / 255;
      },
      _updateColor: function() {},
      updateStatus: function() {
        var locFlag = this._dirtyFlag;
        var colorDirty = locFlag & dirtyFlags.colorDirty, opacityDirty = locFlag & dirtyFlags.opacityDirty;
        if (locFlag & dirtyFlags.contentDirty) {
          this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
          this._dirtyFlag &= ~dirtyFlags.contentDirty;
        }
        colorDirty && this._updateDisplayColor();
        opacityDirty && this._updateDisplayOpacity();
        (colorDirty || opacityDirty) && this._updateColor();
        if (locFlag & dirtyFlags.transformDirty) {
          var parentCmd = this.getParentRenderCmd();
          this.transform(parentCmd, true);
          this._dirtyFlag &= ~dirtyFlags.transformDirty;
          this._dirtyFlag &= ~dirtyFlags.cullingDirty;
        } else if (locFlag & dirtyFlags.cullingDirty) {
          this.culling(parentCmd, true);
          this._dirtyFlag &= ~dirtyFlags.cullingDirty;
        }
      },
      _syncStatus: function(parentCmd) {
        var locFlag = this._dirtyFlag;
        var colorDirty = locFlag & dirtyFlags.colorDirty, opacityDirty = locFlag & dirtyFlags.opacityDirty;
        colorDirty && this._syncDisplayColor();
        opacityDirty && this._syncDisplayOpacity();
        (colorDirty || opacityDirty) && this._updateColor();
        locFlag & dirtyFlags.transformDirty ? this.transform(parentCmd) : locFlag & dirtyFlags.cullingDirty && this.culling(parentCmd);
      }
    };
    _ccsg.Node.RenderCmd.prototype.originUpdateTransform = _ccsg.Node.RenderCmd.prototype.updateTransform;
    _ccsg.Node.RenderCmd.prototype.originTransform = _ccsg.Node.RenderCmd.prototype.transform;
    _ccsg.Node.RenderCmd.prototype.originCulling = _ccsg.Node.RenderCmd.prototype.culling;
    _ccsg.Node.RenderCmd.prototype.originUpdateStatus = _ccsg.Node.RenderCmd.prototype.updateStatus;
    _ccsg.Node.RenderCmd.prototype._originSyncStatus = _ccsg.Node.RenderCmd.prototype._syncStatus;
  }), {} ],
  34: [ (function(require, module, exports) {
    _ccsg.Node.CanvasRenderCmd = function(renderable) {
      this._ctor(renderable);
      this._currentRegion = new cc.Region();
      this._oldRegion = new cc.Region();
      this._regionFlag = 0;
    };
    _ccsg.Node.CanvasRenderCmd.RegionStatus = {
      NotDirty: 0,
      Dirty: 1,
      DirtyDouble: 2
    };
    var proto = _ccsg.Node.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.RenderCmd.prototype);
    proto.constructor = _ccsg.Node.CanvasRenderCmd;
    proto._rootCtor = _ccsg.Node.CanvasRenderCmd;
    proto._notifyRegionStatus = function(status) {
      this._needDraw && this._regionFlag < status && (this._regionFlag = status);
    };
    var localBB = new cc.Rect();
    proto.getLocalBB = function() {
      var node = this._node;
      localBB.x = localBB.y = 0;
      localBB.width = node._contentSize.width;
      localBB.height = node._contentSize.height;
      return localBB;
    };
    proto._updateCurrentRegions = function() {
      var temp = this._currentRegion;
      this._currentRegion = this._oldRegion;
      this._oldRegion = temp;
      _ccsg.Node.CanvasRenderCmd.RegionStatus.DirtyDouble !== this._regionFlag || this._currentRegion.isEmpty() || this._oldRegion.union(this._currentRegion);
      this._currentRegion.updateRegion(this.getLocalBB(), this._worldTransform);
    };
    proto.detachFromParent = function() {
      var selChildren = this._node._children, item;
      for (var i = 0, len = selChildren.length; i < len; i++) {
        item = selChildren[i];
        item && item._renderCmd && item._renderCmd.detachFromParent();
      }
    };
    proto.setShaderProgram = function(shaderProgram) {};
    proto.getShaderProgram = function() {
      return null;
    };
    _ccsg.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc = function(blendFunc) {
      return blendFunc ? blendFunc.src === cc.macro.SRC_ALPHA && blendFunc.dst === cc.macro.ONE || blendFunc.src === cc.macro.ONE && blendFunc.dst === cc.macro.ONE ? "lighter" : blendFunc.src === cc.macro.ZERO && blendFunc.dst === cc.macro.SRC_ALPHA ? "destination-in" : blendFunc.src === cc.macro.ZERO && blendFunc.dst === cc.macro.ONE_MINUS_SRC_ALPHA ? "destination-out" : "source-over" : "source-over";
    };
  }), {} ],
  35: [ (function(require, module, exports) {
    _ccsg.Node.WebGLRenderCmd = function(renderable) {
      this._ctor(renderable);
      this._shaderProgram = null;
    };
    var proto = _ccsg.Node.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.RenderCmd.prototype);
    proto.constructor = _ccsg.Node.WebGLRenderCmd;
    proto._rootCtor = _ccsg.Node.WebGLRenderCmd;
    proto._updateColor = function() {};
    proto.setShaderProgram = function(shaderProgram) {
      this._shaderProgram = shaderProgram;
    };
    proto.getShaderProgram = function() {
      return this._shaderProgram;
    };
  }), {} ],
  36: [ (function(require, module, exports) {
    var eventManager = require("../event-manager");
    var TOP = 1;
    var MID = 2;
    var BOT = 4;
    var LEFT = 8;
    var CENTER = 16;
    var RIGHT = 32;
    var HORIZONTAL = LEFT | CENTER | RIGHT;
    var VERTICAL = TOP | MID | BOT;
    var AlignMode = cc.Enum({
      ONCE: 0,
      ON_WINDOW_RESIZE: 1,
      ALWAYS: 2
    });
    function getReadonlyNodeSize(parent) {
      return parent instanceof cc.Scene ? cc.visibleRect : !parent._sizeProvider || parent._sizeProvider instanceof _ccsg.Node ? parent._contentSize : parent.getContentSize();
    }
    function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
      var scaleX = widgetNode._parent._scaleX;
      var scaleY = widgetNode._parent._scaleY;
      var translateX = 0;
      var translateY = 0;
      for (var node = widgetNode._parent; ;) {
        var pos = node._position;
        translateX += pos.x;
        translateY += pos.y;
        node = node._parent;
        if (!node) {
          out_inverseTranslate.x = out_inverseTranslate.y = 0;
          out_inverseScale.x = out_inverseScale.y = 1;
          return;
        }
        if (node === target) break;
        var sx = node._scaleX;
        var sy = node._scaleY;
        translateX *= sx;
        translateY *= sy;
        scaleX *= sx;
        scaleY *= sy;
      }
      out_inverseScale.x = 0 !== scaleX ? 1 / scaleX : 1;
      out_inverseScale.y = 0 !== scaleY ? 1 / scaleY : 1;
      out_inverseTranslate.x = -translateX;
      out_inverseTranslate.y = -translateY;
    }
    var tInverseTranslate = cc.Vec2.ZERO;
    var tInverseScale = cc.Vec2.ONE;
    function align(node, widget) {
      var hasTarget = widget._target;
      var target;
      var inverseTranslate, inverseScale;
      if (hasTarget) {
        target = hasTarget;
        inverseTranslate = tInverseTranslate;
        inverseScale = tInverseScale;
        computeInverseTransForTarget(node, target, inverseTranslate, inverseScale);
      } else target = node._parent;
      var targetSize = getReadonlyNodeSize(target);
      var targetAnchor = target._anchorPoint;
      var isRoot = (true, target instanceof cc.Scene);
      var x = node._position.x, y = node._position.y;
      var anchor = node._anchorPoint;
      if (widget._alignFlags & HORIZONTAL) {
        var localLeft, localRight, targetWidth = targetSize.width;
        if (isRoot) {
          localLeft = cc.visibleRect.left.x;
          localRight = cc.visibleRect.right.x;
        } else {
          localLeft = -targetAnchor.x * targetWidth;
          localRight = localLeft + targetWidth;
        }
        localLeft += widget._isAbsLeft ? widget._left : widget._left * targetWidth;
        localRight -= widget._isAbsRight ? widget._right : widget._right * targetWidth;
        if (hasTarget) {
          localLeft += inverseTranslate.x;
          localLeft *= inverseScale.x;
          localRight += inverseTranslate.x;
          localRight *= inverseScale.x;
        }
        var width, anchorX = anchor.x, scaleX = node._scaleX;
        if (scaleX < 0) {
          anchorX = 1 - anchorX;
          scaleX = -scaleX;
        }
        if (widget.isStretchWidth) {
          width = localRight - localLeft;
          0 !== scaleX && (node.width = width / scaleX);
          x = localLeft + anchorX * width;
        } else {
          width = node.width * scaleX;
          if (widget.isAlignHorizontalCenter) {
            var localHorizontalCenter = widget._isAbsHorizontalCenter ? widget._horizontalCenter : widget._horizontalCenter * targetWidth;
            var targetCenter = (.5 - targetAnchor.x) * targetSize.width;
            if (hasTarget) {
              localHorizontalCenter *= inverseScale.x;
              targetCenter += inverseTranslate.x;
              targetCenter *= inverseScale.x;
            }
            x = targetCenter + (anchorX - .5) * width + localHorizontalCenter;
          } else x = widget.isAlignLeft ? localLeft + anchorX * width : localRight + (anchorX - 1) * width;
        }
      }
      if (widget._alignFlags & VERTICAL) {
        var localTop, localBottom, targetHeight = targetSize.height;
        if (isRoot) {
          localBottom = cc.visibleRect.bottom.y;
          localTop = cc.visibleRect.top.y;
        } else {
          localBottom = -targetAnchor.y * targetHeight;
          localTop = localBottom + targetHeight;
        }
        localBottom += widget._isAbsBottom ? widget._bottom : widget._bottom * targetHeight;
        localTop -= widget._isAbsTop ? widget._top : widget._top * targetHeight;
        if (hasTarget) {
          localBottom += inverseTranslate.y;
          localBottom *= inverseScale.y;
          localTop += inverseTranslate.y;
          localTop *= inverseScale.y;
        }
        var height, anchorY = anchor.y, scaleY = node._scaleY;
        if (scaleY < 0) {
          anchorY = 1 - anchorY;
          scaleY = -scaleY;
        }
        if (widget.isStretchHeight) {
          height = localTop - localBottom;
          0 !== scaleY && (node.height = height / scaleY);
          y = localBottom + anchorY * height;
        } else {
          height = node.height * scaleY;
          if (widget.isAlignVerticalCenter) {
            var localVerticalCenter = widget._isAbsVerticalCenter ? widget._verticalCenter : widget._verticalCenter * targetHeight;
            var targetMiddle = (.5 - targetAnchor.y) * targetSize.height;
            if (hasTarget) {
              localVerticalCenter *= inverseScale.y;
              targetMiddle += inverseTranslate.y;
              targetMiddle *= inverseScale.y;
            }
            y = targetMiddle + (anchorY - .5) * height + localVerticalCenter;
          } else y = widget.isAlignBottom ? localBottom + anchorY * height : localTop + (anchorY - 1) * height;
        }
      }
      node.setPosition(x, y);
    }
    function visitNode(node) {
      var widget = node._widget;
      if (widget) {
        var target;
        var isParent;
        false;
        align(node, widget);
        true, widget.alignMode !== AlignMode.ALWAYS ? widget.enabled = false : activeWidgets.push(widget);
      }
      var children = node._children;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        child._active && visitNode(child);
      }
    }
    var animationState;
    false;
    function refreshScene() {
      var AnimUtils;
      var nowPreviewing;
      false;
      var scene = cc.director.getScene();
      if (scene) {
        widgetManager.isAligning = true;
        if (widgetManager._nodesOrderDirty) {
          activeWidgets.length = 0;
          visitNode(scene);
          widgetManager._nodesOrderDirty = false;
        } else {
          var i, widget, iterator = widgetManager._activeWidgetsIterator;
          var AnimUtils;
          var editingNode;
          var node;
          false;
          for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) {
            widget = activeWidgets[iterator.i];
            align(widget.node, widget);
          }
        }
        widgetManager.isAligning = false;
      }
      false;
    }
    var adjustWidgetToAllowMovingInEditor = false;
    var adjustWidgetToAllowResizingInEditor = false;
    var activeWidgets = [];
    function updateAlignment(node) {
      var parent = node._parent;
      cc.Node.isNode(parent) && updateAlignment(parent);
      var widget = node._widget || node.getComponent(cc.Widget);
      widget && align(node, widget);
    }
    var widgetManager = cc._widgetManager = module.exports = {
      _AlignFlags: {
        TOP: TOP,
        MID: MID,
        BOT: BOT,
        LEFT: LEFT,
        CENTER: CENTER,
        RIGHT: RIGHT
      },
      isAligning: false,
      _nodesOrderDirty: false,
      _activeWidgetsIterator: new cc.js.array.MutableForwardIterator(activeWidgets),
      init: function(director) {
        director.on(cc.Director.EVENT_BEFORE_VISIT, refreshScene);
        false;
        true;
        cc.sys.isMobile ? window.addEventListener("resize", this.onResized.bind(this)) : eventManager.addCustomListener("canvas-resize", this.onResized.bind(this));
      },
      add: function(widget) {
        widget.node._widget = widget;
        this._nodesOrderDirty = true;
        false;
      },
      remove: function(widget) {
        widget.node._widget = null;
        this._activeWidgetsIterator.remove(widget);
        false;
      },
      onResized: function() {
        var scene = cc.director.getScene();
        scene && this.refreshWidgetOnResized(scene);
      },
      refreshWidgetOnResized: function(node) {
        var widget = cc.Node.isNode(node) && node.getComponent(cc.Widget);
        widget && widget.alignMode === AlignMode.ON_WINDOW_RESIZE && (widget.enabled = true);
        var children = node._children;
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          this.refreshWidgetOnResized(child);
        }
      },
      updateAlignment: updateAlignment,
      AlignMode: AlignMode
    };
    false;
  }), {
    "../event-manager": 58
  } ],
  37: [ (function(require, module, exports) {
    require("./platform/CCClass");
    var Flags = require("./platform/CCObject").Flags;
    var JsArray = require("./platform/js").array;
    var IsStartCalled = Flags.IsStartCalled;
    var IsOnEnableCalled = Flags.IsOnEnableCalled;
    var IsEditorOnEnableCalled = Flags.IsEditorOnEnableCalled;
    var callerFunctor = false;
    var callOnEnableInTryCatch = false;
    var callStartInTryCatch = false;
    var callUpdateInTryCatch = false;
    var callLateUpdateInTryCatch = false;
    var callOnDisableInTryCatch = false;
    var callStart = function(c) {
      c.start();
      c._objFlags |= IsStartCalled;
    };
    var callUpdate = function(c, dt) {
      c.update(dt);
    };
    var callLateUpdate = function(c, dt) {
      c.lateUpdate(dt);
    };
    function sortedIndex(array, comp) {
      var order = comp.constructor._executionOrder;
      var id = comp.__instanceId;
      for (var l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
        var test = array[m];
        var testOrder = test.constructor._executionOrder;
        if (testOrder > order) h = m - 1; else if (testOrder < order) l = m + 1; else {
          var testId = test.__instanceId;
          if (testId > id) h = m - 1; else {
            if (!(testId < id)) return m;
            l = m + 1;
          }
        }
      }
      return ~l;
    }
    function stableRemoveInactive(iterator, flagToClear) {
      var array = iterator.array;
      var next = iterator.i + 1;
      while (next < array.length) {
        var comp = array[next];
        if (comp._enabled && comp.node._activeInHierarchy) ++next; else {
          iterator.removeAt(next);
          flagToClear && (comp._objFlags &= ~flagToClear);
        }
      }
    }
    var LifeCycleInvoker = cc.Class({
      __ctor__: function(invokeFunc) {
        var Iterator = JsArray.MutableForwardIterator;
        this._zero = new Iterator([]);
        this._neg = new Iterator([]);
        this._pos = new Iterator([]);
        false;
        this._invoke = invokeFunc;
      },
      statics: {
        stableRemoveInactive: stableRemoveInactive
      },
      add: null,
      remove: null,
      invoke: null
    });
    function compareOrder(a, b) {
      return a.constructor._executionOrder - b.constructor._executionOrder;
    }
    var OneOffInvoker = cc.Class({
      extends: LifeCycleInvoker,
      add: function(comp) {
        var order = comp.constructor._executionOrder;
        (0 === order ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
      },
      remove: function(comp) {
        var order = comp.constructor._executionOrder;
        (0 === order ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
      },
      cancelInactive: function(flagToClear) {
        stableRemoveInactive(this._zero, flagToClear);
        stableRemoveInactive(this._neg, flagToClear);
        stableRemoveInactive(this._pos, flagToClear);
      },
      invoke: function() {
        var compsNeg = this._neg;
        if (compsNeg.array.length > 0) {
          compsNeg.array.sort(compareOrder);
          this._invoke(compsNeg);
          compsNeg.array.length = 0;
        }
        this._invoke(this._zero);
        this._zero.array.length = 0;
        var compsPos = this._pos;
        if (compsPos.array.length > 0) {
          compsPos.array.sort(compareOrder);
          this._invoke(compsPos);
          compsPos.array.length = 0;
        }
      }
    });
    var ReusableInvoker = cc.Class({
      extends: LifeCycleInvoker,
      add: function(comp) {
        var order = comp.constructor._executionOrder;
        if (0 === order) this._zero.array.push(comp); else {
          var array = order < 0 ? this._neg.array : this._pos.array;
          var i = sortedIndex(array, comp);
          i < 0 && array.splice(~i, 0, comp);
        }
      },
      remove: function(comp) {
        var order = comp.constructor._executionOrder;
        if (0 === order) this._zero.fastRemove(comp); else {
          var iterator = order < 0 ? this._neg : this._pos;
          var i = sortedIndex(iterator.array, comp);
          i >= 0 && iterator.removeAt(i);
        }
      },
      invoke: function(dt) {
        this._neg.array.length > 0 && this._invoke(this._neg, dt);
        this._invoke(this._zero, dt);
        this._pos.array.length > 0 && this._invoke(this._pos, dt);
      }
    });
    function enableInEditor(comp) {
      if (!(comp._objFlags & IsEditorOnEnableCalled)) {
        cc.engine.emit("component-enabled", comp.uuid);
        comp._objFlags |= IsEditorOnEnableCalled;
      }
    }
    function createInvokeImpl(funcOrCode, useDt) {
      if ("function" === typeof funcOrCode) return useDt ? function(iterator, dt) {
        var array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
          var comp = array[iterator.i];
          funcOrCode(comp, dt);
        }
      } : function(iterator) {
        var array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
          var comp = array[iterator.i];
          funcOrCode(comp);
        }
      };
      var body = "var a=it.array;for(it.i=0;it.i<a.length;++it.i){var c=a[it.i];" + funcOrCode + "}";
      return useDt ? Function("it", "dt", body) : Function("it", body);
    }
    function ctor() {
      this.startInvoker = new OneOffInvoker(createInvokeImpl(callStart));
      this.updateInvoker = new ReusableInvoker(createInvokeImpl(callUpdate, true));
      this.lateUpdateInvoker = new ReusableInvoker(createInvokeImpl(callLateUpdate, true));
      this.scheduleInNextFrame = [];
      this._updating = false;
    }
    var ComponentScheduler = cc.Class({
      ctor: ctor,
      unscheduleAll: ctor,
      statics: {
        LifeCycleInvoker: LifeCycleInvoker,
        OneOffInvoker: OneOffInvoker,
        createInvokeImpl: createInvokeImpl,
        invokeOnEnable: function(iterator) {
          var compScheduler = cc.director._compScheduler;
          var array = iterator.array;
          for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
            var comp = array[iterator.i];
            if (comp._enabled) {
              comp.onEnable();
              var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;
              deactivatedDuringOnEnable || compScheduler._onEnabled(comp);
            }
          }
        }
      },
      _onEnabled: function(comp) {
        cc.director.getScheduler().resumeTarget(comp);
        comp._objFlags |= IsOnEnableCalled;
        this._updating ? this.scheduleInNextFrame.push(comp) : this._scheduleImmediate(comp);
      },
      _onDisabled: function(comp) {
        cc.director.getScheduler().pauseTarget(comp);
        comp._objFlags &= ~IsOnEnableCalled;
        var index = this.scheduleInNextFrame.indexOf(comp);
        if (index >= 0) {
          JsArray.fastRemoveAt(this.scheduleInNextFrame, index);
          return;
        }
        !comp.start || comp._objFlags & IsStartCalled || this.startInvoker.remove(comp);
        comp.update && this.updateInvoker.remove(comp);
        comp.lateUpdate && this.lateUpdateInvoker.remove(comp);
      },
      enableComp: function(comp, invoker) {
        if (!(comp._objFlags & IsOnEnableCalled)) {
          if (comp.onEnable) {
            if (invoker) {
              invoker.add(comp);
              return;
            }
            comp.onEnable();
            var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;
            if (deactivatedDuringOnEnable) return;
          }
          this._onEnabled(comp);
        }
      },
      disableComp: function(comp) {
        if (comp._objFlags & IsOnEnableCalled) {
          comp.onDisable && comp.onDisable();
          this._onDisabled(comp);
        }
      },
      _scheduleImmediate: function(comp) {
        !comp.start || comp._objFlags & IsStartCalled || this.startInvoker.add(comp);
        comp.update && this.updateInvoker.add(comp);
        comp.lateUpdate && this.lateUpdateInvoker.add(comp);
      },
      _deferredSchedule: function() {
        var comps = this.scheduleInNextFrame;
        for (var i = 0, len = comps.length; i < len; i++) {
          var comp = comps[i];
          this._scheduleImmediate(comp);
        }
        comps.length = 0;
      },
      startPhase: function() {
        this._updating = true;
        this.scheduleInNextFrame.length > 0 && this._deferredSchedule();
        this.startInvoker.invoke();
      },
      updatePhase: function(dt) {
        this.updateInvoker.invoke(dt);
      },
      lateUpdatePhase: function(dt) {
        this.lateUpdateInvoker.invoke(dt);
        this._updating = false;
      }
    });
    module.exports = ComponentScheduler;
  }), {
    "./platform/CCClass": 89,
    "./platform/CCObject": 95,
    "./platform/js": 109,
    "./utils/misc": 137
  } ],
  38: [ (function(require, module, exports) {
    var BlockEvents = [ "touchstart", "touchmove", "touchend", "mousedown", "mousemove", "mouseup", "mouseenter", "mouseleave", "mousewheel" ];
    function stopPropagation(event) {
      event.stopPropagation();
    }
    var BlockInputEvents = cc.Class({
      name: "cc.BlockInputEvents",
      extends: require("./CCComponent"),
      editor: {
        menu: "i18n:MAIN_MENU.component.ui/Block Input Events",
        inspector: "packages://inspector/inspectors/comps/block-input-events.js",
        help: "i18n:COMPONENT.help_url.block-input-events"
      },
      onEnable: function() {
        for (var i = 0; i < BlockEvents.length; i++) this.node.on(BlockEvents[i], stopPropagation, this);
      },
      onDisable: function() {
        for (var i = 0; i < BlockEvents.length; i++) this.node.off(BlockEvents[i], stopPropagation, this);
      }
    });
    cc.BlockInputEvents = module.exports = BlockInputEvents;
  }), {
    "./CCComponent": 40
  } ],
  39: [ (function(require, module, exports) {
    var eventManager = require("../event-manager");
    var designResolutionWrapper = {
      getContentSize: function() {
        return cc.visibleRect;
      },
      setContentSize: function(size) {},
      _getWidth: function() {
        return this.getContentSize().width;
      },
      _getHeight: function() {
        return this.getContentSize().height;
      }
    };
    var Canvas = cc.Class({
      name: "cc.Canvas",
      extends: require("./CCComponent"),
      editor: false,
      resetInEditor: false,
      statics: {
        instance: null
      },
      properties: {
        _designResolution: cc.size(960, 640),
        designResolution: {
          get: function() {
            return cc.size(this._designResolution);
          },
          set: function(value) {
            this._designResolution.width = value.width;
            this._designResolution.height = value.height;
            this.applySettings();
          },
          tooltip: false
        },
        _fitWidth: false,
        _fitHeight: true,
        fitHeight: {
          get: function() {
            return this._fitHeight;
          },
          set: function(value) {
            if (this._fitHeight !== value) {
              this._fitHeight = value;
              this.applySettings();
            }
          },
          tooltip: false
        },
        fitWidth: {
          get: function() {
            return this._fitWidth;
          },
          set: function(value) {
            if (this._fitWidth !== value) {
              this._fitWidth = value;
              this.applySettings();
            }
          },
          tooltip: false
        }
      },
      ctor: function() {
        false;
        this._thisOnResized = this.onResized.bind(this);
      },
      __preload: function() {
        var Flags;
        false;
        if (Canvas.instance) return cc.errorID(6700, this.node.name, Canvas.instance.node.name);
        Canvas.instance = this;
        if (this.node._sizeProvider) {
          var renderer;
          false;
        } else this.node._sizeProvider = designResolutionWrapper;
        cc.director.on(cc.Director.EVENT_BEFORE_VISIT, this.alignWithScreen, this);
        false;
        true;
        cc.sys.isMobile ? window.addEventListener("resize", this._thisOnResized) : eventManager.addCustomListener("canvas-resize", this._thisOnResized);
        this.applySettings();
        this.onResized();
      },
      onDestroy: function() {
        this.node._sizeProvider === designResolutionWrapper && (this.node._sizeProvider = null);
        cc.director.off(cc.Director.EVENT_BEFORE_VISIT, this.alignWithScreen, this);
        false;
        true;
        cc.sys.isMobile ? window.removeEventListener("resize", this._thisOnResized) : eventManager.removeCustomListeners("canvas-resize", this._thisOnResized);
        Canvas.instance === this && (Canvas.instance = null);
      },
      alignWithScreen: function() {
        var designSize;
        false;
        var canvasSize = cc.visibleRect;
        var clipTopRight = !this.fitHeight && !this.fitWidth;
        var offsetX = 0;
        var offsetY = 0;
        if (clipTopRight) {
          designSize = cc.view.getDesignResolutionSize();
          offsetX = .5 * (designSize.width - canvasSize.width);
          offsetY = .5 * (designSize.height - canvasSize.height);
        }
        this.node.setPosition(.5 * canvasSize.width + offsetX, .5 * canvasSize.height + offsetY);
      },
      onResized: function() {
        this.alignWithScreen();
      },
      applySettings: function() {
        var ResolutionPolicy = cc.ResolutionPolicy;
        var policy;
        policy = this.fitHeight && this.fitWidth ? ResolutionPolicy.SHOW_ALL : this.fitHeight || this.fitWidth ? this.fitWidth ? ResolutionPolicy.FIXED_WIDTH : ResolutionPolicy.FIXED_HEIGHT : ResolutionPolicy.NO_BORDER;
        var designRes = this._designResolution;
        false;
        cc.view.setDesignResolutionSize(designRes.width, designRes.height, policy);
      }
    });
    cc.Canvas = module.exports = Canvas;
  }), {
    "../event-manager": 58,
    "./CCComponent": 40
  } ],
  40: [ (function(require, module, exports) {
    var CCObject = require("../platform/CCObject");
    var JS = require("../platform/js");
    var idGenerater = new (require("../platform/id-generater"))("Comp");
    var IsOnEnableCalled = CCObject.Flags.IsOnEnableCalled;
    var IsOnLoadCalled = CCObject.Flags.IsOnLoadCalled;
    var Component = cc.Class({
      name: "cc.Component",
      extends: CCObject,
      ctor: function() {
        this.__instanceId = cc.ClassManager.getNewInstanceId();
        this.__eventTargets = [];
      },
      properties: {
        node: {
          default: null,
          visible: false
        },
        name: {
          get: function() {
            if (this._name) return this._name;
            var className = cc.js.getClassName(this);
            var trimLeft = className.lastIndexOf(".");
            trimLeft >= 0 && (className = className.slice(trimLeft + 1));
            return this.node.name + "<" + className + ">";
          },
          set: function(value) {
            this._name = value;
          },
          visible: false
        },
        _id: {
          default: "",
          serializable: false
        },
        uuid: {
          get: function() {
            var id = this._id;
            if (!id) {
              id = this._id = idGenerater.getNewId();
              false, false;
            }
            return id;
          },
          visible: false
        },
        __scriptAsset: false,
        _enabled: true,
        enabled: {
          get: function() {
            return this._enabled;
          },
          set: function(value) {
            if (this._enabled !== value) {
              this._enabled = value;
              if (this.node._activeInHierarchy) {
                var compScheduler = cc.director._compScheduler;
                value ? compScheduler.enableComp(this) : compScheduler.disableComp(this);
              }
            }
          },
          visible: false
        },
        enabledInHierarchy: {
          get: function() {
            return (this._objFlags & IsOnEnableCalled) > 0;
          },
          visible: false
        },
        _isOnLoadCalled: {
          get: function() {
            return this._objFlags & IsOnLoadCalled;
          }
        }
      },
      update: null,
      lateUpdate: null,
      __preload: null,
      onLoad: null,
      start: null,
      onEnable: null,
      onDisable: null,
      onDestroy: null,
      onFocusInEditor: null,
      onLostFocusInEditor: null,
      resetInEditor: null,
      addComponent: function(typeOrClassName) {
        return this.node.addComponent(typeOrClassName);
      },
      getComponent: function(typeOrClassName) {
        return this.node.getComponent(typeOrClassName);
      },
      getComponents: function(typeOrClassName) {
        return this.node.getComponents(typeOrClassName);
      },
      getComponentInChildren: function(typeOrClassName) {
        return this.node.getComponentInChildren(typeOrClassName);
      },
      getComponentsInChildren: function(typeOrClassName) {
        return this.node.getComponentsInChildren(typeOrClassName);
      },
      _getLocalBounds: null,
      onRestore: null,
      destroy: function() {
        var depend;
        false;
        this._super() && this._enabled && this.node._activeInHierarchy && cc.director._compScheduler.disableComp(this);
      },
      _onPreDestroy: function() {
        this.unscheduleAllCallbacks();
        var eventTargets = this.__eventTargets;
        for (var i = 0, l = eventTargets.length; i < l; ++i) {
          var target = eventTargets[i];
          target && target.targetOff(this);
        }
        eventTargets.length = 0;
        false;
        cc.director._nodeActivator.destroyComp(this);
        this.node._removeComponent(this);
        false, false;
      },
      _instantiate: function(cloned) {
        cloned || (cloned = cc.instantiate._clone(this, this));
        cloned.node = null;
        return cloned;
      },
      isRunning: function() {
        return this.enabledInHierarchy;
      },
      schedule: function(callback, interval, repeat, delay) {
        cc.assertID(callback, 1619);
        cc.assertID(interval >= 0, 1620);
        interval = interval || 0;
        repeat = isNaN(repeat) ? cc.macro.REPEAT_FOREVER : repeat;
        delay = delay || 0;
        var scheduler = cc.director.getScheduler();
        var paused = scheduler.isTargetPaused(this);
        scheduler.schedule(callback, this, interval, repeat, delay, paused);
      },
      scheduleOnce: function(callback, delay) {
        this.schedule(callback, 0, 0, delay);
      },
      unschedule: function(callback_fn) {
        if (!callback_fn) return;
        cc.director.getScheduler().unschedule(callback_fn, this);
      },
      unscheduleAllCallbacks: function() {
        cc.director.getScheduler().unscheduleAllForTarget(this);
      }
    });
    Component._requireComponent = null;
    Component._executionOrder = 0;
    false, false;
    JS.value(Component, "_registerEditorProps", (function(cls, props) {
      var reqComp = props.requireComponent;
      reqComp && (cls._requireComponent = reqComp);
      var order = props.executionOrder;
      order && "number" === typeof order && (cls._executionOrder = order);
      var name;
      var key;
      var val;
      var willExecuteInEditMode;
      false, false;
    }));
    Component.prototype.__scriptUuid = "";
    cc.Component = module.exports = Component;
  }), {
    "../platform/CCObject": 95,
    "../platform/id-generater": 105,
    "../platform/js": 109
  } ],
  41: [ (function(require, module, exports) {
    cc.Component.EventHandler = cc.Class({
      name: "cc.ClickEvent",
      properties: {
        target: {
          default: null,
          type: cc.Node
        },
        component: {
          default: ""
        },
        handler: {
          default: ""
        },
        customEventData: {
          default: ""
        }
      },
      statics: {
        emitEvents: function(events) {
          "use strict";
          var args, i, l;
          if (arguments.length > 0) {
            args = new Array(arguments.length - 1);
            for (i = 0, l = args.length; i < l; i++) args[i] = arguments[i + 1];
          }
          for (i = 0, l = events.length; i < l; i++) {
            var event = events[i];
            if (!(event instanceof cc.Component.EventHandler)) continue;
            event.emit(args);
          }
        }
      },
      emit: function(params) {
        var target = this.target;
        if (!cc.isValid(target)) return;
        var comp = target.getComponent(this.component);
        if (!cc.isValid(comp)) return;
        var handler = comp[this.handler];
        if ("function" !== typeof handler) return;
        if (null != this.customEventData && "" !== this.customEventData) {
          params = params.slice();
          params.push(this.customEventData);
        }
        handler.apply(comp, params);
      }
    });
  }), {} ],
  42: [ (function(require, module, exports) {
    require("../label/CCSGLabel");
    require("../label/CCSGLabelCanvasRenderCmd");
    require("../label/CCSGLabelWebGLRenderCmd");
    var HorizontalAlign = cc.TextAlignment;
    var VerticalAlign = cc.VerticalTextAlignment;
    var Overflow = _ccsg.Label.Overflow;
    function debounce(func, wait, immediate) {
      var timeout;
      return function() {
        var context = this;
        var later = function() {
          timeout = null;
          immediate || func.apply(context, arguments);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        callNow && func.apply(context, arguments);
      };
    }
    var Label = cc.Class({
      name: "cc.Label",
      extends: cc._RendererUnderSG,
      ctor: function() {
        false;
      },
      editor: false,
      _updateSgNodeString: function() {
        this._sgNode.setString(this.string);
        this._updateNodeSize();
      },
      _updateSgNodeFontSize: function() {
        if (this._sgNode) {
          this._sgNode.setFontSize(this._fontSize);
          this._updateNodeSize();
        }
      },
      properties: {
        _useOriginalSize: true,
        string: {
          default: "Label",
          multiline: true,
          tooltip: false,
          notify: function() {
            if (this._sgNode) {
              false;
              this._updateSgNodeString();
            }
          }
        },
        horizontalAlign: {
          default: HorizontalAlign.LEFT,
          type: HorizontalAlign,
          tooltip: false,
          notify: function() {
            this._sgNode && this._sgNode.setHorizontalAlign(this.horizontalAlign);
          },
          animatable: false
        },
        verticalAlign: {
          default: VerticalAlign.TOP,
          type: VerticalAlign,
          tooltip: false,
          notify: function() {
            this._sgNode && this._sgNode.setVerticalAlign(this.verticalAlign);
          },
          animatable: false
        },
        _actualFontSize: {
          default: 40
        },
        actualFontSize: {
          displayName: "Actual Font Size",
          animatable: false,
          readonly: true,
          get: function() {
            this._sgNode && (this._actualFontSize = this._sgNode.getFontSize());
            return this._actualFontSize;
          }
        },
        _fontSize: 40,
        fontSize: {
          get: function() {
            return this._fontSize;
          },
          set: function(value) {
            this._fontSize = value;
            false;
            this._updateSgNodeFontSize();
          },
          tooltip: false
        },
        fontFamily: {
          default: "Arial",
          tooltip: false,
          notify: function() {
            this._sgNode && this._sgNode.setFontFamily(this.fontFamily);
          },
          animatable: false
        },
        _lineHeight: 40,
        lineHeight: {
          get: function() {
            this._sgNode && (this._lineHeight = this._sgNode.getLineHeight());
            return this._lineHeight;
          },
          set: function(value) {
            this._lineHeight = value;
            if (this._sgNode) {
              this._sgNode.setLineHeight(value);
              this._updateNodeSize();
            }
          },
          tooltip: false
        },
        overflow: {
          default: Overflow.NONE,
          type: Overflow,
          tooltip: false,
          notify: function() {
            if (this._sgNode) {
              this._sgNode.setOverflow(this.overflow);
              this._updateNodeSize();
            }
          },
          animatable: false
        },
        _enableWrapText: true,
        enableWrapText: {
          get: function() {
            this._sgNode && (this._enableWrapText = this._sgNode.isWrapTextEnabled());
            return this._enableWrapText;
          },
          set: function(value) {
            this._enableWrapText = value;
            this._sgNode && this._sgNode.enableWrapText(value);
          },
          animatable: false,
          tooltip: false
        },
        _N$file: null,
        font: {
          get: function() {
            return this._N$file;
          },
          set: function(value) {
            value || (this._isSystemFontUsed = true);
            false;
            this._N$file = value;
            this._bmFontOriginalSize = -1;
            value && this._isSystemFontUsed && (this._isSystemFontUsed = false);
            if (this._sgNode) {
              "string" === typeof value && cc.warnID(4e3);
              var font = this.font;
              if (font instanceof cc.BitmapFont) if (font.spriteFrame) {
                true;
                this._sgNode.setFontAsset(font);
              } else {
                cc.warnID(4011, font.name);
                this._sgNode.setFontFamily("");
              } else this._sgNode.setFontAsset(font);
            }
            value instanceof cc.BitmapFont && (this._bmFontOriginalSize = value.fontSize);
          },
          type: cc.Font,
          tooltip: false,
          animatable: false
        },
        _isSystemFontUsed: true,
        useSystemFont: {
          get: function() {
            return this._isSystemFontUsed;
          },
          set: function(value) {
            false;
            this._isSystemFontUsed = !!value;
            if (value) {
              this.font = null;
              this._sgNode && this._sgNode.setFontFamily(this.fontFamily);
            }
          },
          animatable: false,
          tooltip: false
        },
        _bmFontOriginalSize: {
          displayName: "BMFont Original Size",
          default: -1,
          serializable: false,
          readonly: true,
          visible: true,
          animatable: false
        },
        _spacingX: 0,
        spacingX: {
          get: function() {
            return this._spacingX;
          },
          set: function(value) {
            this._spacingX = value;
            if (this._sgNode) {
              this._sgNode.setSpacingX(this.spacingX);
              this._updateNodeSize();
            }
          }
        }
      },
      statics: {
        HorizontalAlign: HorizontalAlign,
        VerticalAlign: VerticalAlign,
        Overflow: Overflow
      },
      __preload: function() {
        this._super();
        true;
        this._sgNode.on("load", this._updateNodeSize, this);
        this._updateNodeSize();
      },
      _createSgNode: function() {
        return null;
      },
      _initSgNode: function() {
        var font = this.font;
        "string" === typeof font && cc.warnID(4e3);
        var sgNode;
        if (font instanceof cc.BitmapFont) if (font.spriteFrame) {
          false;
          sgNode = this._sgNode = _ccsg.Label.pool.get(this.string, font);
        } else {
          cc.warnID(4011, font.name);
          sgNode = this._sgNode = _ccsg.Label.pool.get(this.string);
        } else sgNode = this._sgNode = _ccsg.Label.pool.get(this.string, font, null, this._fontSize);
        font instanceof cc.BitmapFont && (this._bmFontOriginalSize = font.fontSize);
        sgNode.setVisible(false);
        sgNode.setHorizontalAlign(this.horizontalAlign);
        sgNode.setVerticalAlign(this.verticalAlign);
        sgNode.setFontSize(this._fontSize);
        this.useSystemFont && sgNode.setFontFamily(this.fontFamily);
        sgNode.setOverflow(this.overflow);
        sgNode.enableWrapText(this._enableWrapText);
        sgNode.setLineHeight(this._lineHeight);
        sgNode.setString(this.string);
        font instanceof cc.BitmapFont && sgNode.setSpacingX(this.spacingX);
        false;
        false;
        sgNode.setContentSize(this.node.getContentSize());
        sgNode.setColor(this.node.color);
      },
      _updateNodeSize: function() {
        var initialized = this._sgNode && this._sgNode.parent;
        initialized && (this.overflow !== Overflow.NONE && this.overflow !== Overflow.RESIZE_HEIGHT || this.node.setContentSize(this._sgNode.getContentSize()));
      },
      onDestroy: function() {
        var sgNodeBeforeDestroy = this._sgNode;
        this._super();
        if (sgNodeBeforeDestroy) {
          sgNodeBeforeDestroy.removeFromParent(true);
          _ccsg.Label.pool.put(sgNodeBeforeDestroy);
        }
      }
    });
    cc.Label = module.exports = Label;
  }), {
    "../label/CCSGLabel": 65,
    "../label/CCSGLabelCanvasRenderCmd": 66,
    "../label/CCSGLabelWebGLRenderCmd": 67
  } ],
  43: [ (function(require, module, exports) {
    var Type = cc.Enum({
      NONE: 0,
      HORIZONTAL: 1,
      VERTICAL: 2,
      GRID: 3
    });
    var ResizeMode = cc.Enum({
      NONE: 0,
      CONTAINER: 1,
      CHILDREN: 2
    });
    var AxisDirection = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1
    });
    var VerticalDirection = cc.Enum({
      BOTTOM_TO_TOP: 0,
      TOP_TO_BOTTOM: 1
    });
    var HorizontalDirection = cc.Enum({
      LEFT_TO_RIGHT: 0,
      RIGHT_TO_LEFT: 1
    });
    var Layout = cc.Class({
      name: "cc.Layout",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _layoutSize: cc.size(300, 200),
        _layoutDirty: {
          default: true,
          serializable: false
        },
        _resize: ResizeMode.NONE,
        _N$layoutType: Type.NONE,
        type: {
          type: Type,
          get: function() {
            return this._N$layoutType;
          },
          set: function(value) {
            this._N$layoutType = value;
            var reLayouted;
            false;
            this._doLayoutDirty();
          },
          tooltip: false,
          animatable: false
        },
        resizeMode: {
          type: ResizeMode,
          tooltip: false,
          animatable: false,
          get: function() {
            return this._resize;
          },
          set: function(value) {
            if (this.type === Type.NONE && value === ResizeMode.CHILDREN) return;
            this._resize = value;
            var reLayouted;
            false;
            this._doLayoutDirty();
          }
        },
        cellSize: {
          default: cc.size(40, 40),
          tooltip: false,
          type: cc.Size,
          notify: function() {
            this._doLayoutDirty();
          }
        },
        startAxis: {
          default: AxisDirection.HORIZONTAL,
          tooltip: false,
          type: AxisDirection,
          notify: function() {
            var reLayouted;
            false;
            this._doLayoutDirty();
          },
          animatable: false
        },
        _N$padding: {
          default: 0
        },
        paddingLeft: {
          default: 0,
          tooltip: false,
          notify: function() {
            this._doLayoutDirty();
          }
        },
        paddingRight: {
          default: 0,
          tooltip: false,
          notify: function() {
            this._doLayoutDirty();
          }
        },
        paddingTop: {
          default: 0,
          tooltip: false,
          notify: function() {
            this._doLayoutDirty();
          }
        },
        paddingBottom: {
          default: 0,
          tooltip: false,
          notify: function() {
            this._doLayoutDirty();
          }
        },
        spacingX: {
          default: 0,
          notify: function() {
            this._doLayoutDirty();
          },
          tooltip: false
        },
        spacingY: {
          default: 0,
          notify: function() {
            this._doLayoutDirty();
          },
          tooltip: false
        },
        verticalDirection: {
          default: VerticalDirection.TOP_TO_BOTTOM,
          type: VerticalDirection,
          notify: function() {
            this._doLayoutDirty();
          },
          tooltip: false,
          animatable: false
        },
        horizontalDirection: {
          default: HorizontalDirection.LEFT_TO_RIGHT,
          type: HorizontalDirection,
          notify: function() {
            this._doLayoutDirty();
          },
          tooltip: false,
          animatable: false
        }
      },
      statics: {
        Type: Type,
        VerticalDirection: VerticalDirection,
        HorizontalDirection: HorizontalDirection,
        ResizeMode: ResizeMode,
        AxisDirection: AxisDirection
      },
      _migratePaddingData: function() {
        this.paddingLeft = this._N$padding;
        this.paddingRight = this._N$padding;
        this.paddingTop = this._N$padding;
        this.paddingBottom = this._N$padding;
        this._N$padding = 0;
      },
      onEnable: function() {
        this._addEventListeners();
        cc.sizeEqualToSize(this.node.getContentSize(), cc.size(0, 0)) && this.node.setContentSize(this._layoutSize);
        0 !== this._N$padding && this._migratePaddingData();
        this._doLayoutDirty();
      },
      onDisable: function() {
        this._removeEventListeners();
      },
      _doLayoutDirty: function() {
        this._layoutDirty = true;
      },
      _addEventListeners: function() {
        cc.director.on(cc.Director.EVENT_BEFORE_VISIT, this.updateLayout, this);
        this.node.on("size-changed", this._resized, this);
        this.node.on("anchor-changed", this._doLayoutDirty, this);
        this.node.on("child-added", this._childAdded, this);
        this.node.on("child-removed", this._childRemoved, this);
        this.node.on("child-reorder", this._doLayoutDirty, this);
        this._addChildrenEventListeners();
      },
      _removeEventListeners: function() {
        cc.director.off(cc.Director.EVENT_BEFORE_VISIT, this.updateLayout, this);
        this.node.off("size-changed", this._resized, this);
        this.node.off("anchor-changed", this._doLayoutDirty, this);
        this.node.off("child-added", this._childAdded, this);
        this.node.off("child-removed", this._childRemoved, this);
        this.node.off("child-reorder", this._doLayoutDirty, this);
        this._removeChildrenEventListeners();
      },
      _addChildrenEventListeners: function() {
        var children = this.node.children;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.on("size-changed", this._doLayoutDirty, this);
          child.on("position-changed", this._doLayoutDirty, this);
          child.on("anchor-changed", this._doLayoutDirty, this);
          child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
        }
      },
      _removeChildrenEventListeners: function() {
        var children = this.node.children;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.off("size-changed", this._doLayoutDirty, this);
          child.off("position-changed", this._doLayoutDirty, this);
          child.off("anchor-changed", this._doLayoutDirty, this);
          child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
        }
      },
      _childAdded: function(event) {
        var child = event.detail;
        child.on("size-changed", this._doLayoutDirty, this);
        child.on("position-changed", this._doLayoutDirty, this);
        child.on("anchor-changed", this._doLayoutDirty, this);
        child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
        this._doLayoutDirty();
      },
      _childRemoved: function(event) {
        var child = event.detail;
        child.off("size-changed", this._doLayoutDirty, this);
        child.off("position-changed", this._doLayoutDirty, this);
        child.off("anchor-changed", this._doLayoutDirty, this);
        child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
        this._doLayoutDirty();
      },
      _resized: function() {
        this._layoutSize = this.node.getContentSize();
        this._doLayoutDirty();
      },
      _doLayoutHorizontally: function(baseWidth, rowBreak, fnPositionY, applyChildren) {
        var layoutAnchor = this.node.getAnchorPoint();
        var children = this.node.children;
        var sign = 1;
        var paddingX = this.paddingLeft;
        var leftBoundaryOfLayout = -layoutAnchor.x * baseWidth;
        if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
          sign = -1;
          leftBoundaryOfLayout = (1 - layoutAnchor.x) * baseWidth;
          paddingX = this.paddingRight;
        }
        var nextX = leftBoundaryOfLayout + sign * paddingX - sign * this.spacingX;
        var rowMaxHeight = 0;
        var tempMaxHeight = 0;
        var secondMaxHeight = 0;
        var row = 0;
        var containerResizeBoundary = 0;
        var maxHeightChildAnchorY = 0;
        var activeChildCount = 0;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.activeInHierarchy && activeChildCount++;
        }
        var newChildWidth = this.cellSize.width;
        this.type !== Type.GRID && this.resizeMode === ResizeMode.CHILDREN && (newChildWidth = (baseWidth - (this.paddingLeft + this.paddingRight) - (activeChildCount - 1) * this.spacingX) / activeChildCount);
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          if (!child.activeInHierarchy) continue;
          if (this._resize === ResizeMode.CHILDREN) {
            child.width = newChildWidth;
            this.type === Type.GRID && (child.height = this.cellSize.height);
          }
          var anchorX = child.anchorX;
          secondMaxHeight > tempMaxHeight && (tempMaxHeight = secondMaxHeight);
          if (child.height >= tempMaxHeight) {
            secondMaxHeight = tempMaxHeight;
            tempMaxHeight = child.height;
            maxHeightChildAnchorY = child.getAnchorPoint().y;
          }
          this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (anchorX = 1 - child.anchorX);
          nextX = nextX + sign * anchorX * child.width + sign * this.spacingX;
          var rightBoundaryOfChild = sign * (1 - anchorX) * child.width;
          if (rowBreak) {
            var rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this.paddingRight : this.paddingLeft);
            var leftToRightRowBreak = this.horizontalDirection === HorizontalDirection.LEFT_TO_RIGHT && rowBreakBoundary > (1 - layoutAnchor.x) * baseWidth;
            var rightToLeftRowBreak = this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && rowBreakBoundary < -layoutAnchor.x * baseWidth;
            if (leftToRightRowBreak || rightToLeftRowBreak) {
              if (child.height >= tempMaxHeight) {
                0 === secondMaxHeight && (secondMaxHeight = tempMaxHeight);
                rowMaxHeight += secondMaxHeight;
                secondMaxHeight = tempMaxHeight;
              } else {
                rowMaxHeight += tempMaxHeight;
                secondMaxHeight = child.height;
                tempMaxHeight = 0;
              }
              nextX = leftBoundaryOfLayout + sign * (paddingX + anchorX * child.width);
              row++;
            }
          }
          var finalPositionY = fnPositionY(child, rowMaxHeight, row);
          baseWidth >= child.width + this.paddingLeft + this.paddingRight && applyChildren && child.setPosition(cc.p(nextX, finalPositionY));
          var signX = 1;
          var tempFinalPositionY;
          var topMarign = 0 === tempMaxHeight ? child.height : tempMaxHeight;
          if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            containerResizeBoundary = containerResizeBoundary || this.node._contentSize.height;
            signX = -1;
            tempFinalPositionY = finalPositionY + signX * (topMarign * maxHeightChildAnchorY + this.paddingBottom);
            tempFinalPositionY < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY);
          } else {
            containerResizeBoundary = containerResizeBoundary || -this.node._contentSize.height;
            tempFinalPositionY = finalPositionY + signX * (topMarign * maxHeightChildAnchorY + this.paddingTop);
            tempFinalPositionY > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY);
          }
          nextX += rightBoundaryOfChild;
        }
        return containerResizeBoundary;
      },
      _getVerticalBaseHeight: function(children) {
        var newHeight = 0;
        var activeChildCount = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            if (child.activeInHierarchy) {
              activeChildCount++;
              newHeight += child.height;
            }
          }
          newHeight += (activeChildCount - 1) * this.spacingY + this.paddingBottom + this.paddingTop;
        } else newHeight = this.node.getContentSize().height;
        return newHeight;
      },
      _doLayoutVertically: function(baseHeight, columnBreak, fnPositionX, applyChildren) {
        var layoutAnchor = this.node.getAnchorPoint();
        var children = this.node.children;
        var sign = 1;
        var paddingY = this.paddingBottom;
        var bottomBoundaryOfLayout = -layoutAnchor.y * baseHeight;
        if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
          sign = -1;
          bottomBoundaryOfLayout = (1 - layoutAnchor.y) * baseHeight;
          paddingY = this.paddingTop;
        }
        var nextY = bottomBoundaryOfLayout + sign * paddingY - sign * this.spacingY;
        var columnMaxWidth = 0;
        var tempMaxWidth = 0;
        var secondMaxWidth = 0;
        var column = 0;
        var containerResizeBoundary = 0;
        var maxWidthChildAnchorX = 0;
        var activeChildCount = 0;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.activeInHierarchy && activeChildCount++;
        }
        var newChildHeight = this.cellSize.height;
        this.type !== Type.GRID && this.resizeMode === ResizeMode.CHILDREN && (newChildHeight = (baseHeight - (this.paddingTop + this.paddingBottom) - (activeChildCount - 1) * this.spacingY) / activeChildCount);
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          if (!child.activeInHierarchy) continue;
          if (this.resizeMode === ResizeMode.CHILDREN) {
            child.height = newChildHeight;
            this.type === Type.GRID && (child.width = this.cellSize.width);
          }
          var anchorY = child.anchorY;
          secondMaxWidth > tempMaxWidth && (tempMaxWidth = secondMaxWidth);
          if (child.width >= tempMaxWidth) {
            secondMaxWidth = tempMaxWidth;
            tempMaxWidth = child.width;
            maxWidthChildAnchorX = child.getAnchorPoint().x;
          }
          this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (anchorY = 1 - child.anchorY);
          nextY = nextY + sign * anchorY * child.height + sign * this.spacingY;
          var topBoundaryOfChild = sign * (1 - anchorY) * child.height;
          if (columnBreak) {
            var columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this.paddingTop : this.paddingBottom);
            var bottomToTopColumnBreak = this.verticalDirection === VerticalDirection.BOTTOM_TO_TOP && columnBreakBoundary > (1 - layoutAnchor.y) * baseHeight;
            var topToBottomColumnBreak = this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM && columnBreakBoundary < -layoutAnchor.y * baseHeight;
            if (bottomToTopColumnBreak || topToBottomColumnBreak) {
              if (child.width >= tempMaxWidth) {
                0 === secondMaxWidth && (secondMaxWidth = tempMaxWidth);
                columnMaxWidth += secondMaxWidth;
                secondMaxWidth = tempMaxWidth;
              } else {
                columnMaxWidth += tempMaxWidth;
                secondMaxWidth = child.width;
                tempMaxWidth = 0;
              }
              nextY = bottomBoundaryOfLayout + sign * (paddingY + anchorY * child.height);
              column++;
            }
          }
          var finalPositionX = fnPositionX(child, columnMaxWidth, column);
          baseHeight >= child.height + (this.paddingTop + this.paddingBottom) && applyChildren && child.setPosition(cc.p(finalPositionX, nextY));
          var signX = 1;
          var tempFinalPositionX;
          var rightMarign = 0 === tempMaxWidth ? child.width : tempMaxWidth;
          if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            signX = -1;
            containerResizeBoundary = containerResizeBoundary || this.node._contentSize.width;
            tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this.paddingLeft);
            tempFinalPositionX < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX);
          } else {
            containerResizeBoundary = containerResizeBoundary || -this.node._contentSize.width;
            tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this.paddingRight);
            tempFinalPositionX > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX);
          }
          nextY += topBoundaryOfChild;
        }
        return containerResizeBoundary;
      },
      _doLayoutBasic: function() {
        var children = this.node.children;
        var allChildrenBoundingBox = null;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.activeInHierarchy && (allChildrenBoundingBox = allChildrenBoundingBox ? cc.rectUnion(allChildrenBoundingBox, child.getBoundingBoxToWorld()) : child.getBoundingBoxToWorld());
        }
        if (allChildrenBoundingBox) {
          var leftBottomInParentSpace = this.node.parent.convertToNodeSpaceAR(cc.p(allChildrenBoundingBox.x, allChildrenBoundingBox.y));
          leftBottomInParentSpace = cc.pAdd(leftBottomInParentSpace, cc.p(-this.paddingLeft, -this.paddingBottom));
          var rightTopInParentSpace = this.node.parent.convertToNodeSpaceAR(cc.p(allChildrenBoundingBox.x + allChildrenBoundingBox.width, allChildrenBoundingBox.y + allChildrenBoundingBox.height));
          rightTopInParentSpace = cc.pAdd(rightTopInParentSpace, cc.p(this.paddingRight, this.paddingTop));
          var newSize = cc.size(parseFloat((rightTopInParentSpace.x - leftBottomInParentSpace.x).toFixed(2)), parseFloat((rightTopInParentSpace.y - leftBottomInParentSpace.y).toFixed(2)));
          var layoutPosition = this.node.getPosition();
          var newAnchorX = (layoutPosition.x - leftBottomInParentSpace.x) / newSize.width;
          var newAnchorY = (layoutPosition.y - leftBottomInParentSpace.y) / newSize.height;
          var newAnchor = cc.p(parseFloat(newAnchorX.toFixed(2)), parseFloat(newAnchorY.toFixed(2)));
          this.node.setAnchorPoint(newAnchor);
          this.node.setContentSize(newSize);
        }
      },
      _doLayoutGridAxisHorizontal: function(layoutAnchor, layoutSize) {
        var baseWidth = layoutSize.width;
        var sign = 1;
        var bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height;
        var paddingY = this.paddingBottom;
        if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
          sign = -1;
          bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height;
          paddingY = this.paddingTop;
        }
        var fnPositionY = function(child, topOffset, row) {
          return bottomBoundaryOfLayout + sign * (topOffset + child.anchorY * child.height + paddingY + row * this.spacingY);
        }.bind(this);
        var newHeight = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          var boundary = this._doLayoutHorizontally(baseWidth, true, fnPositionY, false);
          newHeight = bottomBoundaryOfLayout - boundary;
          newHeight < 0 && (newHeight *= -1);
          bottomBoundaryOfLayout = -layoutAnchor.y * newHeight;
          if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            sign = -1;
            bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight;
          }
        }
        this._doLayoutHorizontally(baseWidth, true, fnPositionY, true);
        this.resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(baseWidth, newHeight);
      },
      _doLayoutGridAxisVertical: function(layoutAnchor, layoutSize) {
        var baseHeight = layoutSize.height;
        var sign = 1;
        var leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width;
        var paddingX = this.paddingLeft;
        if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
          sign = -1;
          leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width;
          paddingX = this.paddingRight;
        }
        var fnPositionX = function(child, leftOffset, column) {
          return leftBoundaryOfLayout + sign * (leftOffset + child.anchorX * child.width + paddingX + column * this.spacingX);
        }.bind(this);
        var newWidth = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          var boundary = this._doLayoutVertically(baseHeight, true, fnPositionX, false);
          newWidth = leftBoundaryOfLayout - boundary;
          newWidth < 0 && (newWidth *= -1);
          leftBoundaryOfLayout = -layoutAnchor.x * newWidth;
          if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            sign = -1;
            leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth;
          }
        }
        this._doLayoutVertically(baseHeight, true, fnPositionX, true);
        this.resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(newWidth, baseHeight);
      },
      _doLayoutGrid: function() {
        var layoutAnchor = this.node.getAnchorPoint();
        var layoutSize = this.node.getContentSize();
        this.startAxis === AxisDirection.HORIZONTAL ? this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) : this.startAxis === AxisDirection.VERTICAL && this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
      },
      _getHorizontalBaseWidth: function(children) {
        var newWidth = 0;
        var activeChildCount = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            if (child.activeInHierarchy) {
              activeChildCount++;
              newWidth += child.width;
            }
          }
          newWidth += (activeChildCount - 1) * this.spacingX + this.paddingLeft + this.paddingRight;
        } else newWidth = this.node.getContentSize().width;
        return newWidth;
      },
      _doLayout: function() {
        if (this.type === Type.HORIZONTAL) {
          var newWidth = this._getHorizontalBaseWidth(this.node.children);
          var fnPositionY = function(child) {
            return child.y;
          };
          this._doLayoutHorizontally(newWidth, false, fnPositionY, true);
          this.node.width = newWidth;
        } else if (this.type === Type.VERTICAL) {
          var newHeight = this._getVerticalBaseHeight(this.node.children);
          var fnPositionX = function(child) {
            return child.x;
          };
          this._doLayoutVertically(newHeight, false, fnPositionX, true);
          this.node.height = newHeight;
        } else this.type === Type.NONE ? this.resizeMode === ResizeMode.CONTAINER && this._doLayoutBasic() : this.type === Type.GRID && this._doLayoutGrid();
      },
      updateLayout: function() {
        if (this._layoutDirty && this.node.children.length > 0) {
          this._doLayout();
          this._layoutDirty = false;
        }
      }
    });
    Object.defineProperty(Layout.prototype, "padding", {
      get: function() {
        cc.warnID(4100);
        return this.paddingLeft;
      },
      set: function(value) {
        this._N$padding = value;
        this._migratePaddingData();
        this._doLayoutDirty();
      }
    });
    cc.Layout = module.exports = Layout;
  }), {
    "./CCComponent": 40
  } ],
  44: [ (function(require, module, exports) {
    require("../../clipping-nodes/CCClippingNode");
    require("../../clipping-nodes/CCClippingNodeCanvasRenderCmd");
    require("../../clipping-nodes/CCClippingNodeWebGLRenderCmd");
    require("../../shape-nodes/CCDrawNode");
    var Base = cc._RendererInSG;
    var MaskType = cc.Enum({
      RECT: 0,
      ELLIPSE: 1,
      IMAGE_STENCIL: 2
    });
    var SEGEMENTS_MIN = 3;
    var SEGEMENTS_MAX = 1e4;
    var Mask = cc.Class({
      name: "cc.Mask",
      extends: Base,
      editor: false,
      properties: {
        _clippingStencil: {
          default: null,
          serializable: false
        },
        _type: MaskType.RECT,
        type: {
          get: function() {
            return this._type;
          },
          set: function(value) {
            this._type = value;
            this._refreshStencil();
          },
          type: MaskType,
          tooltip: false
        },
        spriteFrame: {
          default: null,
          type: cc.SpriteFrame,
          tooltip: false,
          notify: function() {
            this._refreshStencil();
          }
        },
        alphaThreshold: {
          default: 1,
          type: cc.Float,
          range: [ 0, 1, .1 ],
          slide: true,
          tooltip: false,
          notify: function() {
            if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
              cc.warnID(4201);
              return;
            }
            this._sgNode.setAlphaThreshold(this.alphaThreshold);
          }
        },
        inverted: {
          default: false,
          type: cc.Boolean,
          tooltip: false,
          notify: function() {
            if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
              cc.warnID(4202);
              return;
            }
            this._sgNode.setInverted(this.inverted);
          }
        },
        _segements: 64,
        segements: {
          get: function() {
            return this._segements;
          },
          set: function(value) {
            this._segements = cc.clampf(value, SEGEMENTS_MIN, SEGEMENTS_MAX);
            this._refreshStencil();
          },
          tooltip: false
        },
        _resizeToTarget: {
          animatable: false,
          set: function(value) {
            value && this._resizeNodeToTargetNode();
          }
        }
      },
      statics: {
        Type: MaskType
      },
      _resizeNodeToTargetNode: false,
      _initSgNode: function() {},
      _createSgNode: function() {
        return new cc.ClippingNode();
      },
      _hitTest: function(point) {
        var size = this.node.getContentSize(), w = size.width, h = size.height, trans = this.node.getNodeToWorldTransform();
        if (this.type === MaskType.RECT || this.type === MaskType.IMAGE_STENCIL) {
          var rect = cc.rect(0, 0, w, h);
          cc._rectApplyAffineTransformIn(rect, trans);
          var left = point.x - rect.x, right = rect.x + rect.width - point.x, bottom = point.y - rect.y, top = rect.y + rect.height - point.y;
          return left >= 0 && right >= 0 && top >= 0 && bottom >= 0;
        }
        if (this.type === MaskType.ELLIPSE) {
          var a = w / 2, b = h / 2;
          var cx = trans.a * a + trans.c * b + trans.tx;
          var cy = trans.b * a + trans.d * b + trans.ty;
          var px = point.x - cx, py = point.y - cy;
          return px * px / (a * a) + py * py / (b * b) < 1;
        }
      },
      onEnable: function() {
        this._super();
        this.spriteFrame && this.spriteFrame.ensureLoadTexture();
        this._refreshStencil();
        this.node.on("size-changed", this._refreshStencil, this);
        this.node.on("anchor-changed", this._refreshStencil, this);
      },
      onDisable: function() {
        this._super();
        this.node.off("size-changed", this._refreshStencil, this);
        this.node.off("anchor-changed", this._refreshStencil, this);
      },
      _calculateCircle: function(center, radius, segements) {
        var polies = [];
        var anglePerStep = 2 * Math.PI / segements;
        for (var step = 0; step < segements; ++step) polies.push(cc.v2(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y));
        return polies;
      },
      _refreshStencil: function() {
        if (this.type === MaskType.IMAGE_STENCIL && cc._renderType !== cc.game.RENDER_TYPE_WEBGL && true) {
          cc.warnID(4200);
          return;
        }
        var contentSize = this.node.getContentSize();
        var anchorPoint = this.node.getAnchorPoint();
        var stencil = this._clippingStencil;
        if (this._type === MaskType.IMAGE_STENCIL) {
          var isSgSprite = stencil instanceof cc.Scale9Sprite;
          if (!isSgSprite || stencil._spriteFrame !== this.spriteFrame) {
            stencil = new cc.Scale9Sprite();
            stencil.setSpriteFrame(this.spriteFrame);
            this._sgNode.setStencil(stencil);
          }
          stencil.setContentSize(contentSize);
          stencil.setAnchorPoint(anchorPoint);
          this._sgNode.setAlphaThreshold(this.alphaThreshold);
        } else {
          var isDrawNode = stencil instanceof cc.DrawNode;
          if (!isDrawNode) {
            stencil = new cc.DrawNode();
            this._sgNode.setStencil(stencil);
          }
          var width = contentSize.width;
          var height = contentSize.height;
          var x = -width * anchorPoint.x;
          var y = -height * anchorPoint.y;
          var color = cc.color(255, 255, 255, 0);
          stencil.clear();
          if (this._type === MaskType.RECT) {
            var rectangle = [ cc.v2(x, y), cc.v2(x + width, y), cc.v2(x + width, y + height), cc.v2(x, y + height) ];
            stencil.drawPoly(rectangle, color, 0, color);
          } else if (this._type === MaskType.ELLIPSE) {
            var center = cc.v2(x + width / 2, y + height / 2);
            var radius = {
              x: width / 2,
              y: height / 2
            };
            stencil.drawPoly(this._calculateCircle(center, radius, this._segements), color, 0, color);
          }
        }
        this._sgNode.setInverted(this.inverted);
        this._clippingStencil = stencil;
        true;
        cc.renderer.childrenOrderDirty = true;
      }
    });
    false;
    cc.Mask = module.exports = Mask;
  }), {
    "../../clipping-nodes/CCClippingNode": 4,
    "../../clipping-nodes/CCClippingNodeCanvasRenderCmd": 5,
    "../../clipping-nodes/CCClippingNodeWebGLRenderCmd": 6,
    "../../shape-nodes/CCDrawNode": 171
  } ],
  45: [ (function(require, module, exports) {
    var RendererInSG = cc.Class({
      extends: require("./CCSGComponent"),
      name: "cc._RendererInSG",
      ctor: function() {
        var sgNode = this._sgNode = this._createSgNode();
        sgNode.setVisible(false);
        false;
        this._plainNode = new _ccsg.Node();
      },
      __preload: function() {
        this._initSgNode();
        var sgSize;
        false;
      },
      onEnable: function() {
        false;
        this._replaceSgNode(this._sgNode);
      },
      onDisable: function() {
        this._replaceSgNode(this._plainNode);
      },
      onDestroy: function() {
        this._removeSgNode();
        var releasedByNode;
        false;
      },
      _replaceSgNode: function(sgNode) {
        false;
        var node = this.node;
        var replaced = node._sgNode;
        replaced._entity = null;
        false;
        var children = replaced.getChildren().slice();
        replaced.removeAllChildren(false);
        if (sgNode.getChildrenCount() > 0) {
          false;
          sgNode.removeAllChildren(false);
        }
        for (var i = 0, len = children.length; i < len; ++i) sgNode.addChild(children[i]);
        var parentNode = replaced.getParent();
        if (parentNode) {
          true;
          parentNode.removeChild(replaced, false);
          parentNode.addChild(sgNode);
          sgNode._arrivalOrder = replaced._arrivalOrder;
          cc.renderer.childrenOrderDirty = parentNode._reorderChildDirty = true;
        }
        node._sgNode = sgNode;
        node._sgNode._entity = node;
        node._updateSgNode();
      }
    });
    cc._RendererInSG = module.exports = RendererInSG;
  }), {
    "./CCSGComponent": 47
  } ],
  46: [ (function(require, module, exports) {
    var RendererUnderSG = cc.Class({
      extends: require("./CCSGComponent"),
      name: "cc._RendererUnderSG",
      ctor: function() {
        var sgNode = this._sgNode = this._createSgNode();
        if (sgNode) {
          false;
          sgNode.setVisible(false);
        }
      },
      __preload: function() {
        this._initSgNode();
        this._registSizeProvider();
        this._appendSgNode(this._sgNode);
      },
      onEnable: function() {
        this._sgNode && this._sgNode.setVisible(true);
      },
      onDisable: function() {
        this._sgNode && this._sgNode.setVisible(false);
      },
      onDestroy: function() {
        this.node._sizeProvider === this._sgNode && (this.node._sizeProvider = null);
        this._removeSgNode();
      },
      _appendSgNode: function(sgNode) {
        if (!sgNode) return;
        var node = this.node;
        sgNode.setColor(node._color);
        node._cascadeOpacityEnabled || sgNode.setOpacity(node._opacity);
        sgNode.setAnchorPoint(node._anchorPoint);
        sgNode.setOpacityModifyRGB(node._opacityModifyRGB);
        sgNode.setLocalZOrder(-1);
        var sgParent = node._sgNode;
        sgParent.addChild(sgNode);
      }
    });
    cc._RendererUnderSG = module.exports = RendererUnderSG;
  }), {
    "./CCSGComponent": 47
  } ],
  47: [ (function(require, module, exports) {
    var SceneGraphHelper = require("../utils/scene-graph-helper");
    var SGComponent = cc.Class({
      extends: require("./CCComponent"),
      name: "cc._SGComponent",
      editor: false,
      properties: {
        _sgNode: {
          default: null,
          serializable: false
        }
      },
      _createSgNode: null,
      _initSgNode: null,
      _removeSgNode: SceneGraphHelper.removeSgNode,
      _registSizeProvider: function() {
        if (this.node._sizeProvider) {
          var name;
          false;
        } else this.node._sizeProvider = this._sgNode;
      }
    });
    cc._SGComponent = module.exports = SGComponent;
  }), {
    "../utils/scene-graph-helper": 140,
    "./CCComponent": 40
  } ],
  48: [ (function(require, module, exports) {
    var NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED = 5;
    var OUT_OF_BOUNDARY_BREAKING_FACTOR = .05;
    var EPSILON = 1e-4;
    var MOVEMENT_FACTOR = .7;
    var quintEaseOut = function(time) {
      time -= 1;
      return time * time * time * time * time + 1;
    };
    var getTimeInMilliseconds = function() {
      var currentTime = new Date();
      return currentTime.getMilliseconds();
    };
    var EventType = cc.Enum({
      SCROLL_TO_TOP: 0,
      SCROLL_TO_BOTTOM: 1,
      SCROLL_TO_LEFT: 2,
      SCROLL_TO_RIGHT: 3,
      SCROLLING: 4,
      BOUNCE_TOP: 5,
      BOUNCE_BOTTOM: 6,
      BOUNCE_LEFT: 7,
      BOUNCE_RIGHT: 8,
      SCROLL_ENDED: 9,
      TOUCH_UP: 10,
      AUTOSCROLL_ENDED_WITH_THRESHOLD: 11,
      SCROLL_BEGAN: 12
    });
    var eventMap = {
      "scroll-to-top": EventType.SCROLL_TO_TOP,
      "scroll-to-bottom": EventType.SCROLL_TO_BOTTOM,
      "scroll-to-left": EventType.SCROLL_TO_LEFT,
      "scroll-to-right": EventType.SCROLL_TO_RIGHT,
      scrolling: EventType.SCROLLING,
      "bounce-bottom": EventType.BOUNCE_BOTTOM,
      "bounce-left": EventType.BOUNCE_LEFT,
      "bounce-right": EventType.BOUNCE_RIGHT,
      "bounce-top": EventType.BOUNCE_TOP,
      "scroll-ended": EventType.SCROLL_ENDED,
      "touch-up": EventType.TOUCH_UP,
      "scroll-ended-with-threshold": EventType.AUTOSCROLL_ENDED_WITH_THRESHOLD,
      "scroll-began": EventType.SCROLL_BEGAN
    };
    var ScrollView = cc.Class({
      name: "cc.ScrollView",
      extends: require("./CCViewGroup"),
      editor: false,
      ctor: function() {
        this._topBoundary = 0;
        this._bottomBoundary = 0;
        this._leftBoundary = 0;
        this._rightBoundary = 0;
        this._touchMoveDisplacements = [];
        this._touchMoveTimeDeltas = [];
        this._touchMovePreviousTimestamp = 0;
        this._touchMoved = false;
        this._autoScrolling = false;
        this._autoScrollAttenuate = false;
        this._autoScrollStartPosition = cc.p(0, 0);
        this._autoScrollTargetDelta = cc.p(0, 0);
        this._autoScrollTotalTime = 0;
        this._autoScrollAccumulatedTime = 0;
        this._autoScrollCurrentlyOutOfBoundary = false;
        this._autoScrollBraking = false;
        this._autoScrollBrakingStartPosition = cc.p(0, 0);
        this._outOfBoundaryAmount = cc.p(0, 0);
        this._outOfBoundaryAmountDirty = true;
        this._stopMouseWheel = false;
        this._mouseWheelEventElapsedTime = 0;
        this._isScrollEndedWithThresholdEventFired = false;
        this._scrollEventEmitMask = 0;
        this._isBouncing = false;
        this._scrolling = false;
        this.__mdolls_touchStarted = false;
      },
      properties: {
        content: {
          default: void 0,
          type: cc.Node,
          tooltip: false
        },
        horizontal: {
          default: true,
          animatable: false,
          tooltip: false
        },
        vertical: {
          default: true,
          animatable: false,
          tooltip: false
        },
        inertia: {
          default: true,
          tooltip: false
        },
        brake: {
          default: .5,
          type: "Float",
          range: [ 0, 1, .1 ],
          tooltip: false
        },
        elastic: {
          default: true,
          animatable: false,
          tooltip: false
        },
        bounceDuration: {
          default: 1,
          range: [ 0, 10 ],
          tooltip: false
        },
        horizontalScrollBar: {
          default: void 0,
          type: cc.Scrollbar,
          tooltip: false,
          notify: function() {
            if (this.horizontalScrollBar) {
              this.horizontalScrollBar.setTargetScrollView(this);
              this._updateScrollBar(0);
            }
          },
          animatable: false
        },
        verticalScrollBar: {
          default: void 0,
          type: cc.Scrollbar,
          tooltip: false,
          notify: function() {
            if (this.verticalScrollBar) {
              this.verticalScrollBar.setTargetScrollView(this);
              this._updateScrollBar(0);
            }
          },
          animatable: false
        },
        scrollEvents: {
          default: [],
          type: cc.Component.EventHandler,
          tooltip: false
        },
        cancelInnerEvents: {
          default: true,
          animatable: false,
          tooltip: false
        }
      },
      statics: {
        EventType: EventType
      },
      scrollToBottom: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.p(0, 0),
          applyToHorizontal: false,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta, true);
      },
      scrollToTop: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.p(0, 1),
          applyToHorizontal: false,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToLeft: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.p(0, 0),
          applyToHorizontal: true,
          applyToVertical: false
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToRight: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.p(1, 0),
          applyToHorizontal: true,
          applyToVertical: false
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToTopLeft: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.p(0, 1),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToTopRight: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.p(1, 1),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToBottomLeft: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.p(0, 0),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToBottomRight: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.p(1, 0),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToOffset: function(offset, timeInSecond, attenuated) {
        var maxScrollOffset = this.getMaxScrollOffset();
        var anchor = cc.p(0, 0);
        0 === maxScrollOffset.x ? anchor.x = 0 : anchor.x = offset.x / maxScrollOffset.x;
        0 === maxScrollOffset.y ? anchor.y = 1 : anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y;
        this.scrollTo(anchor, timeInSecond, attenuated);
      },
      getScrollOffset: function() {
        var topDelta = this._getContentTopBoundary() - this._topBoundary;
        var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
        return cc.p(leftDeta, topDelta);
      },
      getMaxScrollOffset: function() {
        var scrollSize = this.node.getContentSize();
        var contentSize = this.content.getContentSize();
        var horizontalMaximizeOffset = contentSize.width - scrollSize.width;
        var verticalMaximizeOffset = contentSize.height - scrollSize.height;
        horizontalMaximizeOffset = horizontalMaximizeOffset >= 0 ? horizontalMaximizeOffset : 0;
        verticalMaximizeOffset = verticalMaximizeOffset >= 0 ? verticalMaximizeOffset : 0;
        return cc.p(horizontalMaximizeOffset, verticalMaximizeOffset);
      },
      scrollToPercentHorizontal: function(percent, timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.p(percent, 0),
          applyToHorizontal: true,
          applyToVertical: false
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollTo: function(anchor, timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: anchor,
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToPercentVertical: function(percent, timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.p(0, percent),
          applyToHorizontal: false,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      stopAutoScroll: function() {
        this._autoScrolling = false;
        this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
      },
      setContentPosition: function(position) {
        if (cc.pFuzzyEqual(position, this.getContentPosition(), EPSILON)) return;
        this.content.setPosition(position);
        this._outOfBoundaryAmountDirty = true;
      },
      getContentPosition: function() {
        return this.content.getPosition();
      },
      isScrolling: function() {
        return this._scrolling;
      },
      isAutoScrolling: function() {
        return this._autoScrolling;
      },
      _registerEvent: function() {
        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this, true);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this, true);
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this, true);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
        this.node.on(cc.Node.EventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
      },
      _unregisterEvent: function() {
        this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this, true);
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this, true);
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this, true);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
        this.node.off(cc.Node.EventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
      },
      _onMouseWheel: function(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this._hasNestedViewGroup(event, captureListeners)) return;
        var deltaMove = cc.p(0, 0);
        var wheelPrecision = -.1;
        false;
        this.vertical ? deltaMove = cc.p(0, event.getScrollY() * wheelPrecision) : this.horizontal && (deltaMove = cc.p(event.getScrollY() * wheelPrecision, 0));
        this._mouseWheelEventElapsedTime = 0;
        this._processDeltaMove(deltaMove);
        if (!this._stopMouseWheel) {
          this._handlePressLogic();
          this.schedule(this._checkMouseWheel, 1 / 60);
          this._stopMouseWheel = true;
        }
        this._stopPropagationIfTargetIsMe(event);
      },
      _checkMouseWheel: function(dt) {
        var currentOutOfBoundary = this._getHowMuchOutOfBoundary();
        var maxElapsedTime = .1;
        if (!cc.pFuzzyEqual(currentOutOfBoundary, cc.p(0, 0), EPSILON)) {
          this._processInertiaScroll();
          this.unschedule(this._checkMouseWheel);
          this._stopMouseWheel = false;
          return;
        }
        this._mouseWheelEventElapsedTime += dt;
        if (this._mouseWheelEventElapsedTime > maxElapsedTime) {
          this._onScrollBarTouchEnded();
          this.unschedule(this._checkMouseWheel);
          this._stopMouseWheel = false;
        }
      },
      _calculateMovePercentDelta: function(options) {
        var anchor = options.anchor;
        var applyToHorizontal = options.applyToHorizontal;
        var applyToVertical = options.applyToVertical;
        this._calculateBoundary();
        anchor = cc.pClamp(anchor, cc.p(0, 0), cc.p(1, 1));
        var scrollSize = this.node.getContentSize();
        var contentSize = this.content.getContentSize();
        var bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
        bottomDeta = -bottomDeta;
        var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
        leftDeta = -leftDeta;
        var moveDelta = cc.p(0, 0);
        var totalScrollDelta = 0;
        if (applyToHorizontal) {
          totalScrollDelta = contentSize.width - scrollSize.width;
          moveDelta.x = leftDeta - totalScrollDelta * anchor.x;
        }
        if (applyToVertical) {
          totalScrollDelta = contentSize.height - scrollSize.height;
          moveDelta.y = bottomDeta - totalScrollDelta * anchor.y;
        }
        return moveDelta;
      },
      _moveContentToTopLeft: function(scrollViewSize) {
        var contentSize = this.content.getContentSize();
        var bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
        bottomDeta = -bottomDeta;
        var moveDelta = cc.p(0, 0);
        var totalScrollDelta = 0;
        var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
        leftDeta = -leftDeta;
        if (contentSize.height < scrollViewSize.height) {
          totalScrollDelta = contentSize.height - scrollViewSize.height;
          moveDelta.y = bottomDeta - totalScrollDelta;
          this.verticalScrollBar && this.verticalScrollBar.hide();
        } else this.verticalScrollBar && this.verticalScrollBar.show();
        if (contentSize.width < scrollViewSize.width) {
          totalScrollDelta = contentSize.width - scrollViewSize.width;
          moveDelta.x = leftDeta;
          this.horizontalScrollBar && this.horizontalScrollBar.hide();
        } else this.horizontalScrollBar && this.horizontalScrollBar.show();
        this._moveContent(moveDelta);
        this._adjustContentOutOfBoundary();
      },
      _calculateBoundary: function() {
        if (this.content) {
          var layout = this.content.getComponent(cc.Layout);
          layout && layout.enabledInHierarchy && layout.updateLayout();
          var scrollViewSize = this.node.getContentSize();
          var leftBottomPosition = this._convertToContentParentSpace(cc.p(0, 0));
          this._leftBoundary = leftBottomPosition.x;
          this._bottomBoundary = leftBottomPosition.y;
          var topRightPosition = this._convertToContentParentSpace(cc.p(scrollViewSize.width, scrollViewSize.height));
          this._rightBoundary = topRightPosition.x;
          this._topBoundary = topRightPosition.y;
          true;
          this._moveContentToTopLeft(scrollViewSize);
        }
      },
      _convertToContentParentSpace: function(position) {
        var scrollViewPositionInWorldSpace = this.node.convertToWorldSpace(position);
        var contentParent = this.content.parent;
        return contentParent.convertToNodeSpaceAR(scrollViewPositionInWorldSpace);
      },
      _hasNestedViewGroup: function(event, captureListeners) {
        if (event.eventPhase !== cc.Event.CAPTURING_PHASE) return;
        if (captureListeners) for (var i = 0; i < captureListeners.length; ++i) {
          var item = captureListeners[i];
          if (this.node === item) {
            if (event.target.getComponent(cc.ViewGroup)) return true;
            return false;
          }
          if (item.getComponent(cc.ViewGroup)) return true;
        }
        return false;
      },
      _stopPropagationIfTargetIsMe: function(event) {
        event.eventPhase === cc.Event.AT_TARGET && event.target === this.node && event.stopPropagation();
      },
      _onTouchBegan: function(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this._hasNestedViewGroup(event, captureListeners)) return;
        var touch = event.touch;
        this.content && this._handlePressLogic(touch);
        this._touchMoved = false;
        this._stopPropagationIfTargetIsMe(event);
      },
      _onTouchMoved: function(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this._hasNestedViewGroup(event, captureListeners)) return;
        var touch = event.touch;
        var deltaMove = cc.pSub(touch.getLocation(), touch.getStartLocation());
        !this.__mdolls_touchStarted && cc.pLength(deltaMove) > 7 && (this.__mdolls_touchStarted = true);
        this.__mdolls_touchStarted && this.content && this._handleMoveLogic(touch);
        if (!this.cancelInnerEvents) return;
        if (cc.pLength(deltaMove) > 7 && !this._touchMoved && event.target !== this.node) {
          var cancelEvent = new cc.Event.EventTouch(event.getTouches(), event.bubbles);
          cancelEvent.type = cc.Node.EventType.TOUCH_CANCEL;
          cancelEvent.touch = event.touch;
          cancelEvent.simulate = true;
          event.target.dispatchEvent(cancelEvent);
          this._touchMoved = true;
        }
        this._stopPropagationIfTargetIsMe(event);
      },
      _onTouchEnded: function(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this._hasNestedViewGroup(event, captureListeners)) return;
        this.__mdolls_touchStarted = false;
        this._dispatchEvent("touch-up");
        var touch = event.touch;
        this.content && this._handleReleaseLogic(touch);
        this._touchMoved ? event.stopPropagation() : this._stopPropagationIfTargetIsMe(event);
      },
      _onTouchCancelled: function(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this._hasNestedViewGroup(event, captureListeners)) return;
        if (!event.simulate) {
          var touch = event.touch;
          this.content && this._handleReleaseLogic(touch);
        }
        this._stopPropagationIfTargetIsMe(event);
      },
      _processDeltaMove: function(deltaMove) {
        this._scrollChildren(deltaMove);
        this._gatherTouchMove(deltaMove);
      },
      _handleMoveLogic: function(touch) {
        var deltaMove = touch.getDelta();
        this._processDeltaMove(deltaMove);
      },
      _scrollChildren: function(deltaMove) {
        deltaMove = this._clampDelta(deltaMove);
        var realMove = deltaMove;
        var outOfBoundary;
        if (this.elastic) {
          outOfBoundary = this._getHowMuchOutOfBoundary();
          realMove.x *= 0 === outOfBoundary.x ? 1 : .5;
          realMove.y *= 0 === outOfBoundary.y ? 1 : .5;
        }
        if (!this.elastic) {
          outOfBoundary = this._getHowMuchOutOfBoundary(realMove);
          realMove = cc.pAdd(realMove, outOfBoundary);
        }
        var scrollEventType = -1;
        if (realMove.y > 0) {
          var icBottomPos = this.content.y - this.content.anchorY * this.content.height;
          icBottomPos + realMove.y > this._bottomBoundary && (scrollEventType = "scroll-to-bottom");
        } else if (realMove.y < 0) {
          var icTopPos = this.content.y - this.content.anchorY * this.content.height + this.content.height;
          icTopPos + realMove.y <= this._topBoundary && (scrollEventType = "scroll-to-top");
        } else if (realMove.x < 0) {
          var icRightPos = this.content.x - this.content.anchorX * this.content.width + this.content.width;
          icRightPos + realMove.x <= this._rightBoundary && (scrollEventType = "scroll-to-right");
        } else if (realMove.x > 0) {
          var icLeftPos = this.content.x - this.content.anchorX * this.content.width;
          icLeftPos + realMove.x >= this._leftBoundary && (scrollEventType = "scroll-to-left");
        }
        this._moveContent(realMove, false);
        if (0 !== realMove.x || 0 !== realMove.y) {
          if (!this._scrolling) {
            this._scrolling = true;
            this._dispatchEvent("scroll-began");
          }
          this._dispatchEvent("scrolling");
        }
        -1 !== scrollEventType && this._dispatchEvent(scrollEventType);
      },
      _handlePressLogic: function() {
        this._autoScrolling && this._dispatchEvent("scroll-ended");
        this._autoScrolling = false;
        this._isBouncing = false;
        this._touchMovePreviousTimestamp = getTimeInMilliseconds();
        this._touchMoveDisplacements.length = 0;
        this._touchMoveTimeDeltas.length = 0;
        this._onScrollBarTouchBegan();
      },
      _clampDelta: function(delta) {
        var contentSize = this.content.getContentSize();
        var scrollViewSize = this.node.getContentSize();
        contentSize.width < scrollViewSize.width && (delta.x = 0);
        contentSize.height < scrollViewSize.height && (delta.y = 0);
        return delta;
      },
      _gatherTouchMove: function(delta) {
        delta = this._clampDelta(delta);
        while (this._touchMoveDisplacements.length >= NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED) {
          this._touchMoveDisplacements.shift();
          this._touchMoveTimeDeltas.shift();
        }
        this._touchMoveDisplacements.push(delta);
        var timeStamp = getTimeInMilliseconds();
        this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1e3);
        this._touchMovePreviousTimestamp = timeStamp;
      },
      _startBounceBackIfNeeded: function() {
        if (!this.elastic) return false;
        var bounceBackAmount = this._getHowMuchOutOfBoundary();
        bounceBackAmount = this._clampDelta(bounceBackAmount);
        if (cc.pFuzzyEqual(bounceBackAmount, cc.p(0, 0), EPSILON)) return false;
        var bounceBackTime = Math.max(this.bounceDuration, 0);
        this._startAutoScroll(bounceBackAmount, bounceBackTime, true);
        if (!this._isBouncing) {
          bounceBackAmount.y > 0 && this._dispatchEvent("bounce-top");
          bounceBackAmount.y < 0 && this._dispatchEvent("bounce-bottom");
          bounceBackAmount.x > 0 && this._dispatchEvent("bounce-right");
          bounceBackAmount.x < 0 && this._dispatchEvent("bounce-left");
          this._isBouncing = true;
        }
        return true;
      },
      _processInertiaScroll: function() {
        var bounceBackStarted = this._startBounceBackIfNeeded();
        if (!bounceBackStarted && this.inertia) {
          var touchMoveVelocity = this._calculateTouchMoveVelocity();
          !cc.pFuzzyEqual(touchMoveVelocity, cc.p(0, 0), EPSILON) && this.brake < 1 && this._startInertiaScroll(touchMoveVelocity);
        }
        this._onScrollBarTouchEnded();
      },
      _handleReleaseLogic: function(touch) {
        var delta = touch.getDelta();
        this._gatherTouchMove(delta);
        this._processInertiaScroll();
        if (this._scrolling) {
          this._scrolling = false;
          this._autoScrolling || this._dispatchEvent("scroll-ended");
        }
      },
      _isOutOfBoundary: function() {
        var outOfBoundary = this._getHowMuchOutOfBoundary();
        return !cc.pFuzzyEqual(outOfBoundary, cc.p(0, 0), EPSILON);
      },
      _isNecessaryAutoScrollBrake: function() {
        if (this._autoScrollBraking) return true;
        if (this._isOutOfBoundary()) {
          if (!this._autoScrollCurrentlyOutOfBoundary) {
            this._autoScrollCurrentlyOutOfBoundary = true;
            this._autoScrollBraking = true;
            this._autoScrollBrakingStartPosition = this.getContentPosition();
            return true;
          }
        } else this._autoScrollCurrentlyOutOfBoundary = false;
        return false;
      },
      getScrollEndedEventTiming: function() {
        return EPSILON;
      },
      _processAutoScrolling: function(dt) {
        var isAutoScrollBrake = this._isNecessaryAutoScrollBrake();
        var brakingFactor = isAutoScrollBrake ? OUT_OF_BOUNDARY_BREAKING_FACTOR : 1;
        this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
        var percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
        this._autoScrollAttenuate && (percentage = quintEaseOut(percentage));
        var newPosition = cc.pAdd(this._autoScrollStartPosition, cc.pMult(this._autoScrollTargetDelta, percentage));
        var reachedEnd = Math.abs(percentage - 1) <= EPSILON;
        var fireEvent = Math.abs(percentage - 1) <= this.getScrollEndedEventTiming();
        if (fireEvent && !this._isScrollEndedWithThresholdEventFired) {
          this._dispatchEvent("scroll-ended-with-threshold");
          this._isScrollEndedWithThresholdEventFired = true;
        }
        if (this.elastic) {
          var brakeOffsetPosition = cc.pSub(newPosition, this._autoScrollBrakingStartPosition);
          isAutoScrollBrake && (brakeOffsetPosition = cc.pMult(brakeOffsetPosition, brakingFactor));
          newPosition = cc.pAdd(this._autoScrollBrakingStartPosition, brakeOffsetPosition);
        } else {
          var moveDelta = cc.pSub(newPosition, this.getContentPosition());
          var outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);
          if (!cc.pFuzzyEqual(outOfBoundary, cc.p(0, 0), EPSILON)) {
            newPosition = cc.pAdd(newPosition, outOfBoundary);
            reachedEnd = true;
          }
        }
        reachedEnd && (this._autoScrolling = false);
        var deltaMove = cc.pSub(newPosition, this.getContentPosition());
        this._moveContent(this._clampDelta(deltaMove), reachedEnd);
        this._dispatchEvent("scrolling");
        if (!this._autoScrolling) {
          this._isBouncing = false;
          this._dispatchEvent("scroll-ended");
        }
      },
      _startInertiaScroll: function(touchMoveVelocity) {
        var inertiaTotalMovement = cc.pMult(touchMoveVelocity, MOVEMENT_FACTOR);
        this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
      },
      _calculateAttenuatedFactor: function(distance) {
        if (this.brake <= 0) return 1 - this.brake;
        var attenuatedFactor = (1 - this.brake) * (1 / (1 + 14e-6 * distance + distance * distance * 8e-9));
        return attenuatedFactor;
      },
      _startAttenuatingAutoScroll: function(deltaMove, initialVelocity) {
        var time = this._calculateAutoScrollTimeByInitalSpeed(cc.pLength(initialVelocity));
        var targetDelta = cc.pNormalize(deltaMove);
        var contentSize = this.content.getContentSize();
        var scrollviewSize = this.node.getContentSize();
        var totalMoveWidth = contentSize.width - scrollviewSize.width;
        var totalMoveHeight = contentSize.height - scrollviewSize.height;
        var attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth);
        var attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);
        targetDelta = cc.p(targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX, targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake));
        var originalMoveLength = cc.pLength(deltaMove);
        var factor = cc.pLength(targetDelta) / originalMoveLength;
        targetDelta = cc.pAdd(targetDelta, deltaMove);
        if (this.brake > 0 && factor > 7) {
          factor = Math.sqrt(factor);
          targetDelta = cc.pAdd(cc.pMult(deltaMove, factor), deltaMove);
        }
        if (this.brake > 0 && factor > 3) {
          factor = 3;
          time *= factor;
        }
        0 === this.brake && factor > 1 && (time *= factor);
        this._startAutoScroll(targetDelta, time, true);
      },
      _calculateAutoScrollTimeByInitalSpeed: function(initalSpeed) {
        var time = Math.sqrt(Math.sqrt(initalSpeed / 5));
        return time;
      },
      _startAutoScroll: function(deltaMove, timeInSecond, attenuated) {
        var adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);
        this._autoScrolling = true;
        this._autoScrollTargetDelta = adjustedDeltaMove;
        this._autoScrollAttenuate = attenuated;
        this._autoScrollStartPosition = this.getContentPosition();
        this._autoScrollTotalTime = timeInSecond;
        this._autoScrollAccumulatedTime = 0;
        this._autoScrollBraking = false;
        this._isScrollEndedWithThresholdEventFired = false;
        this._autoScrollBrakingStartPosition = cc.p(0, 0);
        var currentOutOfBoundary = this._getHowMuchOutOfBoundary();
        if (!cc.pFuzzyEqual(currentOutOfBoundary, cc.p(0, 0), EPSILON)) {
          this._autoScrollCurrentlyOutOfBoundary = true;
          var afterOutOfBoundary = this._getHowMuchOutOfBoundary(adjustedDeltaMove);
          (currentOutOfBoundary.x * afterOutOfBoundary.x > 0 || currentOutOfBoundary.y * afterOutOfBoundary.y > 0) && (this._autoScrollBraking = true);
        }
      },
      _calculateTouchMoveVelocity: function() {
        var totalTime = 0;
        totalTime = this._touchMoveTimeDeltas.reduce((function(a, b) {
          return a + b;
        }), totalTime);
        if (totalTime <= 0 || totalTime >= .5) return cc.p(0, 0);
        var totalMovement = cc.p(0, 0);
        totalMovement = this._touchMoveDisplacements.reduce((function(a, b) {
          return cc.pAdd(a, b);
        }), totalMovement);
        return cc.p(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime);
      },
      _flattenVectorByDirection: function(vector) {
        var result = vector;
        result.x = this.horizontal ? result.x : 0;
        result.y = this.vertical ? result.y : 0;
        return result;
      },
      _moveContent: function(deltaMove, canStartBounceBack) {
        var adjustedMove = this._flattenVectorByDirection(deltaMove);
        var newPosition = cc.pAdd(this.getContentPosition(), adjustedMove);
        this.setContentPosition(newPosition);
        var outOfBoundary = this._getHowMuchOutOfBoundary();
        this._updateScrollBar(outOfBoundary);
        this.elastic && canStartBounceBack && this._startBounceBackIfNeeded();
      },
      _getContentLeftBoundary: function() {
        var contentPos = this.getContentPosition();
        var leftBoundary = contentPos.x - this.content.getAnchorPoint().x * this.content.getContentSize().width;
        return leftBoundary;
      },
      _getContentRightBoundary: function() {
        var contentSize = this.content.getContentSize();
        return this._getContentLeftBoundary() + contentSize.width;
      },
      _getContentTopBoundary: function() {
        var contentSize = this.content.getContentSize();
        return this._getContentBottomBoundary() + contentSize.height;
      },
      _getContentBottomBoundary: function() {
        var contentPos = this.getContentPosition();
        var bottomBoundary = contentPos.y - this.content.getAnchorPoint().y * this.content.getContentSize().height;
        return bottomBoundary;
      },
      _getHowMuchOutOfBoundary: function(addition) {
        addition = addition || cc.p(0, 0);
        if (cc.pFuzzyEqual(addition, cc.p(0, 0), EPSILON) && !this._outOfBoundaryAmountDirty) return this._outOfBoundaryAmount;
        var outOfBoundaryAmount = cc.p(0, 0);
        this._getContentLeftBoundary() + addition.x > this._leftBoundary ? outOfBoundaryAmount.x = this._leftBoundary - (this._getContentLeftBoundary() + addition.x) : this._getContentRightBoundary() + addition.x < this._rightBoundary && (outOfBoundaryAmount.x = this._rightBoundary - (this._getContentRightBoundary() + addition.x));
        this._getContentTopBoundary() + addition.y < this._topBoundary ? outOfBoundaryAmount.y = this._topBoundary - (this._getContentTopBoundary() + addition.y) : this._getContentBottomBoundary() + addition.y > this._bottomBoundary && (outOfBoundaryAmount.y = this._bottomBoundary - (this._getContentBottomBoundary() + addition.y));
        if (cc.pFuzzyEqual(addition, cc.p(0, 0), EPSILON)) {
          this._outOfBoundaryAmount = outOfBoundaryAmount;
          this._outOfBoundaryAmountDirty = false;
        }
        outOfBoundaryAmount = this._clampDelta(outOfBoundaryAmount);
        return outOfBoundaryAmount;
      },
      _updateScrollBar: function(outOfBoundary) {
        this.horizontalScrollBar && this.horizontalScrollBar._onScroll(outOfBoundary);
        this.verticalScrollBar && this.verticalScrollBar._onScroll(outOfBoundary);
      },
      _onScrollBarTouchBegan: function() {
        this.horizontalScrollBar && this.horizontalScrollBar._onTouchBegan();
        this.verticalScrollBar && this.verticalScrollBar._onTouchBegan();
      },
      _onScrollBarTouchEnded: function() {
        this.horizontalScrollBar && this.horizontalScrollBar._onTouchEnded();
        this.verticalScrollBar && this.verticalScrollBar._onTouchEnded();
      },
      _dispatchEvent: function(event) {
        if ("scroll-ended" === event) this._scrollEventEmitMask = 0; else if ("scroll-to-top" === event || "scroll-to-bottom" === event || "scroll-to-left" === event || "scroll-to-right" === event) {
          var flag = 1 << eventMap[event];
          if (this._scrollEventEmitMask & flag) return;
          this._scrollEventEmitMask |= flag;
        }
        cc.Component.EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]);
        this.node.emit(event, this);
      },
      _adjustContentOutOfBoundary: function() {
        this._outOfBoundaryAmountDirty = true;
        if (this._isOutOfBoundary()) {
          var outOfBoundary = this._getHowMuchOutOfBoundary(cc.p(0, 0));
          var newPosition = cc.pAdd(this.getContentPosition(), outOfBoundary);
          if (this.content) {
            this.content.setPosition(newPosition);
            this._updateScrollBar(0);
          }
        }
      },
      start: function() {
        this._calculateBoundary();
        this.content && cc.director.once(cc.Director.EVENT_AFTER_VISIT, this._adjustContentOutOfBoundary, this);
      },
      _hideScrollbar: function() {
        this.horizontalScrollBar && this.horizontalScrollBar.hide();
        this.verticalScrollBar && this.verticalScrollBar.hide();
      },
      _showScrollbar: function() {
        this.horizontalScrollBar && this.horizontalScrollBar.show();
        this.verticalScrollBar && this.verticalScrollBar.show();
      },
      onDisable: function() {
        true;
        this._unregisterEvent();
        this.node.off("size-changed", this._calculateBoundary, this);
        this.node.off("scale-changed", this._calculateBoundary, this);
        if (this.content) {
          this.content.off("size-changed", this._calculateBoundary, this);
          this.content.off("scale-changed", this._calculateBoundary, this);
        }
        this._hideScrollbar();
        this.stopAutoScroll();
      },
      onEnable: function() {
        true;
        this._registerEvent();
        this.node.on("size-changed", this._calculateBoundary, this);
        this.node.on("scale-changed", this._calculateBoundary, this);
        if (this.content) {
          this.content.on("size-changed", this._calculateBoundary, this);
          this.content.on("scale-changed", this._calculateBoundary, this);
        }
        this._showScrollbar();
      },
      update: function(dt) {
        this._autoScrolling && this._processAutoScrolling(dt);
      }
    });
    cc.ScrollView = module.exports = ScrollView;
  }), {
    "./CCViewGroup": 50
  } ],
  49: [ (function(require, module, exports) {
    var Base = require("./CCRendererUnderSG");
    var SpriteType = cc.Scale9Sprite.RenderingType;
    var FillType = cc.Scale9Sprite.FillType;
    var BlendFactor = cc.BlendFunc.BlendFactor;
    var SizeMode = cc.Enum({
      CUSTOM: 0,
      TRIMMED: 1,
      RAW: 2
    });
    var Sprite = cc.Class({
      name: "cc.Sprite",
      extends: Base,
      editor: false,
      ctor: function() {
        this._blendFunc = new cc.BlendFunc(this._srcBlendFactor, this._dstBlendFactor);
      },
      properties: {
        _spriteFrame: {
          default: null,
          type: cc.SpriteFrame
        },
        _type: SpriteType.SIMPLE,
        _sizeMode: SizeMode.TRIMMED,
        _fillType: 0,
        _fillCenter: cc.v2(0, 0),
        _fillStart: 0,
        _fillRange: 0,
        _isTrimmedMode: true,
        _srcBlendFactor: BlendFactor.SRC_ALPHA,
        _dstBlendFactor: BlendFactor.ONE_MINUS_SRC_ALPHA,
        _atlas: {
          default: null,
          type: cc.SpriteAtlas,
          tooltip: false,
          editorOnly: true,
          visible: true,
          animatable: false
        },
        spriteFrame: {
          get: function() {
            return this._spriteFrame;
          },
          set: function(value, force) {
            var lastSprite = this._spriteFrame;
            false;
            if (lastSprite === value) return;
            this._spriteFrame = value;
            this._applySpriteFrame(lastSprite);
            false;
          },
          type: cc.SpriteFrame
        },
        type: {
          get: function() {
            return this._type;
          },
          set: function(value) {
            this._type = value;
            this._sgNode.setRenderingType(value);
          },
          type: SpriteType,
          animatable: false,
          tooltip: false
        },
        fillType: {
          get: function() {
            return this._fillType;
          },
          set: function(value) {
            this._fillType = value;
            this._sgNode && this._sgNode.setFillType(value);
          },
          type: FillType,
          tooltip: false
        },
        fillCenter: {
          get: function() {
            return this._fillCenter;
          },
          set: function(value) {
            this._fillCenter = cc.v2(value);
            this._sgNode && this._sgNode.setFillCenter(this._fillCenter);
          },
          tooltip: false
        },
        fillStart: {
          get: function() {
            return this._fillStart;
          },
          set: function(value) {
            this._fillStart = cc.clampf(value, -1, 1);
            this._sgNode && this._sgNode.setFillStart(value);
          },
          tooltip: false
        },
        fillRange: {
          get: function() {
            return this._fillRange;
          },
          set: function(value) {
            this._fillRange = cc.clampf(value, -1, 1);
            this._sgNode && this._sgNode.setFillRange(value);
          },
          tooltip: false
        },
        trim: {
          get: function() {
            return this._isTrimmedMode;
          },
          set: function(value) {
            if (this._isTrimmedMode !== value) {
              this._isTrimmedMode = value;
              this._sgNode.enableTrimmedContentSize(value);
            }
          },
          animatable: false,
          tooltip: false
        },
        srcBlendFactor: {
          get: function() {
            return this._srcBlendFactor;
          },
          set: function(value) {
            this._srcBlendFactor = value;
            this._blendFunc.src = value;
            this._sgNode.setBlendFunc(this._blendFunc);
          },
          animatable: false,
          type: BlendFactor,
          tooltip: false
        },
        dstBlendFactor: {
          get: function() {
            return this._dstBlendFactor;
          },
          set: function(value) {
            this._dstBlendFactor = value;
            this._blendFunc.dst = value;
            this._sgNode.setBlendFunc(this._blendFunc);
          },
          animatable: false,
          type: BlendFactor,
          tooltip: false
        },
        sizeMode: {
          get: function() {
            return this._sizeMode;
          },
          set: function(value) {
            this._sizeMode = value;
            value !== SizeMode.CUSTOM && this._applySpriteSize();
          },
          animatable: false,
          type: SizeMode,
          tooltip: false
        }
      },
      statics: {
        FillType: FillType,
        Type: SpriteType,
        SizeMode: SizeMode
      },
      setVisible: function(visible) {
        this.enabled = visible;
      },
      setInsetLeft: function(insetLeft) {
        this._sgNode.setInsetLeft(insetLeft);
      },
      getInsetLeft: function() {
        return this._sgNode.getInsetLeft();
      },
      setInsetTop: function(insetTop) {
        this._sgNode.setInsetTop(insetTop);
      },
      getInsetTop: function() {
        return this._sgNode.getInsetTop();
      },
      setInsetRight: function(insetRight) {
        this._sgNode.setInsetRight(insetRight);
      },
      getInsetRight: function() {
        return this._sgNode.getInsetRight();
      },
      setInsetBottom: function(insetBottom) {
        this._sgNode.setInsetBottom(insetBottom);
      },
      getInsetBottom: function() {
        return this._sgNode.getInsetBottom();
      },
      onEnable: function() {
        this._sgNode && this._spriteFrame && this._spriteFrame.textureLoaded() && this._sgNode.setVisible(true);
      },
      _applyAtlas: false,
      _applySpriteFrameInsets: function() {
        var spriteFrame = this._spriteFrame;
        var sgNode = this._sgNode;
        sgNode.setInsetTop(spriteFrame.insetTop);
        sgNode.setInsetBottom(spriteFrame.insetBottom);
        sgNode.setInsetRight(spriteFrame.insetRight);
        sgNode.setInsetLeft(spriteFrame.insetLeft);
      },
      _applySpriteSize: function() {
        if (this._spriteFrame) if (SizeMode.RAW === this._sizeMode) {
          var size = this._spriteFrame.getOriginalSize();
          this.node.setContentSize(size);
        } else if (SizeMode.TRIMMED === this._sizeMode) {
          var rect = this._spriteFrame.getRect();
          this.node.setContentSize(rect.width, rect.height);
        }
      },
      _onTextureLoaded: function(event) {
        var self = this;
        if (!self.isValid) return;
        var sgNode = self._sgNode;
        sgNode.setSpriteFrame(self._spriteFrame);
        self._applySpriteSize();
        self.enabledInHierarchy && !sgNode.isVisible() && sgNode.setVisible(true);
      },
      _applySpriteFrame: function(oldFrame, keepInsets) {
        var sgNode = this._sgNode;
        oldFrame && oldFrame.off && oldFrame.off("load", this._onTextureLoaded, this);
        var spriteFrame = this._spriteFrame;
        if (spriteFrame) {
          keepInsets || this._applySpriteFrameInsets();
          if (spriteFrame.textureLoaded()) this._onTextureLoaded(null); else {
            spriteFrame.once("load", this._onTextureLoaded, this);
            spriteFrame.ensureLoadTexture();
          }
        } else {
          sgNode.setSpriteFrame(null);
          sgNode.setVisible(false);
        }
        false;
      },
      _createSgNode: function() {
        return new cc.Scale9Sprite();
      },
      _initSgNode: function() {
        var sgNode = this._sgNode;
        var insetsChangedViaAPI = 0 !== sgNode.getInsetLeft() || 0 !== sgNode.getInsetRight() || 0 !== sgNode.getInsetTop() || 0 !== sgNode.getInsetBottom();
        this._applySpriteFrame(null, insetsChangedViaAPI);
        sgNode.setContentSize(this.node.getContentSize(true));
        this._applySpriteSize();
        sgNode.setRenderingType(this._type);
        sgNode.setFillType(this._fillType);
        sgNode.setFillCenter(this._fillCenter);
        sgNode.setFillStart(this._fillStart);
        sgNode.setFillRange(this._fillRange);
        sgNode.enableTrimmedContentSize(this._isTrimmedMode);
        this._blendFunc.src = this._srcBlendFactor;
        this._blendFunc.dst = this._dstBlendFactor;
        sgNode.setBlendFunc(this._blendFunc);
      },
      _resized: false
    });
    false;
    var misc = require("../utils/misc");
    var SameNameGetSets = [ "insetLeft", "insetTop", "insetRight", "insetBottom" ];
    var DiffNameGetSets = {
      type: [ null, "setRenderingType" ]
    };
    misc.propertyDefine(Sprite, SameNameGetSets, DiffNameGetSets);
    cc.Sprite = module.exports = Sprite;
  }), {
    "../utils/misc": 137,
    "./CCRendererUnderSG": 46
  } ],
  50: [ (function(require, module, exports) {
    var ViewGroup = cc.Class({
      name: "cc.ViewGroup",
      extends: require("./CCComponent")
    });
    cc.ViewGroup = module.exports = ViewGroup;
  }), {
    "./CCComponent": 40
  } ],
  51: [ (function(require, module, exports) {
    var WidgetManager = require("../base-ui/CCWidgetManager");
    var AlignMode = WidgetManager.AlignMode;
    var AlignFlags = WidgetManager._AlignFlags;
    var TOP = AlignFlags.TOP;
    var MID = AlignFlags.MID;
    var BOT = AlignFlags.BOT;
    var LEFT = AlignFlags.LEFT;
    var CENTER = AlignFlags.CENTER;
    var RIGHT = AlignFlags.RIGHT;
    var TOP_BOT = TOP | BOT;
    var LEFT_RIGHT = LEFT | RIGHT;
    var Widget = cc.Class({
      name: "cc.Widget",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        target: {
          get: function() {
            return this._target;
          },
          set: function(value) {
            this._target = value;
            false;
          },
          type: cc.Node,
          tooltip: false
        },
        isAlignTop: {
          get: function() {
            return (this._alignFlags & TOP) > 0;
          },
          set: function(value) {
            this._setAlign(TOP, value);
          },
          animatable: false,
          tooltip: false
        },
        isAlignVerticalCenter: {
          get: function() {
            return (this._alignFlags & MID) > 0;
          },
          set: function(value) {
            if (value) {
              this.isAlignTop = false;
              this.isAlignBottom = false;
              this._alignFlags |= MID;
            } else this._alignFlags &= ~MID;
          },
          animatable: false,
          tooltip: false
        },
        isAlignBottom: {
          get: function() {
            return (this._alignFlags & BOT) > 0;
          },
          set: function(value) {
            this._setAlign(BOT, value);
          },
          animatable: false,
          tooltip: false
        },
        isAlignLeft: {
          get: function() {
            return (this._alignFlags & LEFT) > 0;
          },
          set: function(value) {
            this._setAlign(LEFT, value);
          },
          animatable: false,
          tooltip: false
        },
        isAlignHorizontalCenter: {
          get: function() {
            return (this._alignFlags & CENTER) > 0;
          },
          set: function(value) {
            if (value) {
              this.isAlignLeft = false;
              this.isAlignRight = false;
              this._alignFlags |= CENTER;
            } else this._alignFlags &= ~CENTER;
          },
          animatable: false,
          tooltip: false
        },
        isAlignRight: {
          get: function() {
            return (this._alignFlags & RIGHT) > 0;
          },
          set: function(value) {
            this._setAlign(RIGHT, value);
          },
          animatable: false,
          tooltip: false
        },
        isStretchWidth: {
          get: function() {
            return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
          },
          visible: false
        },
        isStretchHeight: {
          get: function() {
            return (this._alignFlags & TOP_BOT) === TOP_BOT;
          },
          visible: false
        },
        top: {
          get: function() {
            return this._top;
          },
          set: function(value) {
            this._top = value;
          },
          tooltip: false
        },
        bottom: {
          get: function() {
            return this._bottom;
          },
          set: function(value) {
            this._bottom = value;
          },
          tooltip: false
        },
        left: {
          get: function() {
            return this._left;
          },
          set: function(value) {
            this._left = value;
          },
          tooltip: false
        },
        right: {
          get: function() {
            return this._right;
          },
          set: function(value) {
            this._right = value;
          },
          tooltip: false
        },
        horizontalCenter: {
          get: function() {
            return this._horizontalCenter;
          },
          set: function(value) {
            this._horizontalCenter = value;
          },
          tooltip: false
        },
        verticalCenter: {
          get: function() {
            return this._verticalCenter;
          },
          set: function(value) {
            this._verticalCenter = value;
          },
          tooltip: false
        },
        isAbsoluteHorizontalCenter: {
          get: function() {
            return this._isAbsHorizontalCenter;
          },
          set: function(value) {
            this._isAbsHorizontalCenter = value;
          },
          animatable: false
        },
        isAbsoluteVerticalCenter: {
          get: function() {
            return this._isAbsVerticalCenter;
          },
          set: function(value) {
            this._isAbsVerticalCenter = value;
          },
          animatable: false
        },
        isAbsoluteTop: {
          get: function() {
            return this._isAbsTop;
          },
          set: function(value) {
            this._isAbsTop = value;
          },
          animatable: false
        },
        isAbsoluteBottom: {
          get: function() {
            return this._isAbsBottom;
          },
          set: function(value) {
            this._isAbsBottom = value;
          },
          animatable: false
        },
        isAbsoluteLeft: {
          get: function() {
            return this._isAbsLeft;
          },
          set: function(value) {
            this._isAbsLeft = value;
          },
          animatable: false
        },
        isAbsoluteRight: {
          get: function() {
            return this._isAbsRight;
          },
          set: function(value) {
            this._isAbsRight = value;
          },
          animatable: false
        },
        alignMode: {
          default: AlignMode.ON_WINDOW_RESIZE,
          type: AlignMode,
          tooltip: false
        },
        _wasAlignOnce: {
          default: void 0,
          formerlySerializedAs: "isAlignOnce"
        },
        _target: null,
        _alignFlags: 0,
        _left: 0,
        _right: 0,
        _top: 0,
        _bottom: 0,
        _verticalCenter: 0,
        _horizontalCenter: 0,
        _isAbsLeft: true,
        _isAbsRight: true,
        _isAbsTop: true,
        _isAbsBottom: true,
        _isAbsHorizontalCenter: true,
        _isAbsVerticalCenter: true,
        _originalWidth: 0,
        _originalHeight: 0
      },
      statics: {
        AlignMode: AlignMode
      },
      onLoad: function() {
        if (void 0 !== this._wasAlignOnce) {
          this.alignMode = this._wasAlignOnce ? AlignMode.ONCE : AlignMode.ALWAYS;
          this._wasAlignOnce = void 0;
        }
      },
      onEnable: function() {
        WidgetManager.add(this);
      },
      onDisable: function() {
        WidgetManager.remove(this);
      },
      _setAlign: function(flag, isAlign) {
        var current = (this._alignFlags & flag) > 0;
        if (isAlign == current) return;
        var isHorizontal = (flag & LEFT_RIGHT) > 0;
        if (isAlign) {
          this._alignFlags |= flag;
          if (isHorizontal) {
            this.isAlignHorizontalCenter = false;
            if (this.isStretchWidth) {
              this._originalWidth = this.node.width;
              false;
            }
          } else {
            this.isAlignVerticalCenter = false;
            if (this.isStretchHeight) {
              this._originalHeight = this.node.height;
              false;
            }
          }
          false;
        } else {
          isHorizontal ? this.isStretchWidth && (this.node.width = this._originalWidth) : this.isStretchHeight && (this.node.height = this._originalHeight);
          this._alignFlags &= ~flag;
        }
      },
      updateAlignment: function() {
        WidgetManager.updateAlignment(this.node);
      }
    });
    Object.defineProperty(Widget.prototype, "isAlignOnce", {
      get: function() {
        true;
        cc.warn("`widget.isAlignOnce` is deprecated, use `widget.alignMode === cc.Widget.AlignMode.ONCE` instead please.");
        return this.alignMode === AlignMode.ONCE;
      },
      set: function(value) {
        true;
        cc.warn("`widget.isAlignOnce` is deprecated, use `widget.alignMode = cc.Widget.AlignMode.*` instead please.");
        this.alignMode = value ? AlignMode.ONCE : AlignMode.ALWAYS;
      }
    });
    cc.Widget = module.exports = Widget;
  }), {
    "../base-ui/CCWidgetManager": 36,
    "./CCComponent": 40
  } ],
  52: [ (function(require, module, exports) {
    require("./CCComponent");
    require("./CCRendererInSG");
    require("./CCRendererUnderSG");
    require("./CCComponentEventHandler");
    require("./missing-script");
    module.exports = [ require("./CCSprite"), require("./CCWidget"), require("./CCCanvas"), require("./CCAudioSource"), require("./CCAnimation"), require("./CCButton"), require("./CCLabel"), require("./CCProgressBar"), require("./CCMask"), require("./CCScrollBar"), require("./CCScrollView"), require("./CCPageViewIndicator"), require("./CCPageView"), require("./CCSlider"), require("./CCLayout"), require("./CCEditBox"), require("./CCVideoPlayer"), require("./CCWebView"), require("./CCSpriteDistortion"), require("./CCLabelOutline"), require("./CCRichText"), require("./CCToggleContainer"), require("./CCToggleGroup"), require("./CCToggle"), require("./CCBlockInputEvents") ];
  }), {
    "./CCAnimation": 179,
    "./CCAudioSource": 179,
    "./CCBlockInputEvents": 38,
    "./CCButton": 179,
    "./CCCanvas": 39,
    "./CCComponent": 40,
    "./CCComponentEventHandler": 41,
    "./CCEditBox": 179,
    "./CCLabel": 42,
    "./CCLabelOutline": 179,
    "./CCLayout": 43,
    "./CCMask": 44,
    "./CCPageView": 179,
    "./CCPageViewIndicator": 179,
    "./CCProgressBar": 179,
    "./CCRendererInSG": 45,
    "./CCRendererUnderSG": 46,
    "./CCRichText": 179,
    "./CCScrollBar": 179,
    "./CCScrollView": 48,
    "./CCSlider": 179,
    "./CCSprite": 49,
    "./CCSpriteDistortion": 179,
    "./CCToggle": 179,
    "./CCToggleContainer": 179,
    "./CCToggleGroup": 179,
    "./CCVideoPlayer": 179,
    "./CCWebView": 179,
    "./CCWidget": 51,
    "./missing-script": 53
  } ],
  53: [ (function(require, module, exports) {
    var JS = cc.js;
    var BUILTIN_CLASSID_RE = require("../utils/misc").BUILTIN_CLASSID_RE;
    var MissingClass = cc.Class({
      name: "cc.MissingClass",
      properties: {
        _$erialized: {
          default: null,
          visible: false,
          editorOnly: true
        }
      }
    });
    var MissingScript = cc.Class({
      name: "cc.MissingScript",
      extends: cc.Component,
      editor: {
        inspector: "packages://inspector/inspectors/comps/missing-script.js"
      },
      properties: {
        compiled: {
          default: false,
          serializable: false
        },
        _$erialized: {
          default: null,
          visible: false,
          editorOnly: true
        }
      },
      ctor: false,
      statics: {
        safeFindClass: function(id, data) {
          var cls = JS._getClassById(id);
          if (cls) return cls;
          if (id) {
            cc.deserialize.reportMissingClass(id);
            return MissingScript.getMissingWrapper(id, data);
          }
          return null;
        },
        getMissingWrapper: function(id, data) {
          return data.node && (/^[0-9a-zA-Z+/]{23}$/.test(id) || BUILTIN_CLASSID_RE.test(id)) ? MissingScript : MissingClass;
        }
      },
      onLoad: function() {
        cc.warnID(4600, this.node.name);
      }
    });
    cc._MissingScript = module.exports = MissingScript;
  }), {
    "../utils/misc": 137
  } ],
  54: [ (function(require, module, exports) {
    var JS = cc.js;
    require("../event/event");
    var EventMouse = function(eventType, bubbles) {
      cc.Event.call(this, cc.Event.MOUSE, bubbles);
      this._eventType = eventType;
      this._button = 0;
      this._x = 0;
      this._y = 0;
      this._prevX = 0;
      this._prevY = 0;
      this._scrollX = 0;
      this._scrollY = 0;
    };
    JS.extend(EventMouse, cc.Event);
    var proto = EventMouse.prototype;
    proto.setScrollData = function(scrollX, scrollY) {
      this._scrollX = scrollX;
      this._scrollY = scrollY;
    };
    proto.getScrollX = function() {
      return this._scrollX;
    };
    proto.getScrollY = function() {
      return this._scrollY;
    };
    proto.setLocation = function(x, y) {
      this._x = x;
      this._y = y;
    };
    proto.getLocation = function() {
      return cc.v2(this._x, this._y);
    };
    proto.getLocationInView = function() {
      return cc.v2(this._x, cc.view._designResolutionSize.height - this._y);
    };
    proto._setPrevCursor = function(x, y) {
      this._prevX = x;
      this._prevY = y;
    };
    proto.getPreviousLocation = function() {
      return cc.v2(this._prevX, this._prevY);
    };
    proto.getDelta = function() {
      return cc.v2(this._x - this._prevX, this._y - this._prevY);
    };
    proto.getDeltaX = function() {
      return this._x - this._prevX;
    };
    proto.getDeltaY = function() {
      return this._y - this._prevY;
    };
    proto.setButton = function(button) {
      this._button = button;
    };
    proto.getButton = function() {
      return this._button;
    };
    proto.getLocationX = function() {
      return this._x;
    };
    proto.getLocationY = function() {
      return this._y;
    };
    EventMouse.NONE = 0;
    EventMouse.DOWN = 1;
    EventMouse.UP = 2;
    EventMouse.MOVE = 3;
    EventMouse.SCROLL = 4;
    EventMouse.BUTTON_LEFT = 0;
    EventMouse.BUTTON_RIGHT = 2;
    EventMouse.BUTTON_MIDDLE = 1;
    EventMouse.BUTTON_4 = 3;
    EventMouse.BUTTON_5 = 4;
    EventMouse.BUTTON_6 = 5;
    EventMouse.BUTTON_7 = 6;
    EventMouse.BUTTON_8 = 7;
    var EventTouch = function(touchArr, bubbles) {
      cc.Event.call(this, cc.Event.TOUCH, bubbles);
      this._eventCode = 0;
      this._touches = touchArr || [];
      this.touch = null;
      this.currentTouch = null;
    };
    JS.extend(EventTouch, cc.Event);
    proto = EventTouch.prototype;
    proto.getEventCode = function() {
      return this._eventCode;
    };
    proto.getTouches = function() {
      return this._touches;
    };
    proto._setEventCode = function(eventCode) {
      this._eventCode = eventCode;
    };
    proto._setTouches = function(touches) {
      this._touches = touches;
    };
    proto.setLocation = function(x, y) {
      this.touch && this.touch.setTouchInfo(this.touch.getID(), x, y);
    };
    proto.getLocation = function() {
      return this.touch ? this.touch.getLocation() : cc.v2();
    };
    proto.getLocationInView = function() {
      return this.touch ? this.touch.getLocationInView() : cc.v2();
    };
    proto.getPreviousLocation = function() {
      return this.touch ? this.touch.getPreviousLocation() : cc.v2();
    };
    proto.getStartLocation = function() {
      return this.touch ? this.touch.getStartLocation() : cc.v2();
    };
    proto.getID = function() {
      return this.touch ? this.touch.getID() : null;
    };
    proto.getDelta = function() {
      return this.touch ? this.touch.getDelta() : cc.v2();
    };
    proto.getDeltaX = function() {
      return this.touch ? this.touch.getDelta().x : 0;
    };
    proto.getDeltaY = function() {
      return this.touch ? this.touch.getDelta().y : 0;
    };
    proto.getLocationX = function() {
      return this.touch ? this.touch.getLocationX() : 0;
    };
    proto.getLocationY = function() {
      return this.touch ? this.touch.getLocationY() : 0;
    };
    EventTouch.MAX_TOUCHES = 5;
    EventTouch.BEGAN = 0;
    EventTouch.MOVED = 1;
    EventTouch.ENDED = 2;
    EventTouch.CANCELED = 3;
    var EventAcceleration = function(acc, bubbles) {
      cc.Event.call(this, cc.Event.ACCELERATION, bubbles);
      this.acc = acc;
    };
    JS.extend(EventAcceleration, cc.Event);
    var EventKeyboard = function(keyCode, isPressed, bubbles) {
      cc.Event.call(this, cc.Event.KEYBOARD, bubbles);
      this.keyCode = keyCode;
      this.isPressed = isPressed;
    };
    JS.extend(EventKeyboard, cc.Event);
    cc.Event.EventMouse = EventMouse;
    cc.Event.EventTouch = EventTouch;
    cc.Event.EventAcceleration = EventAcceleration;
    cc.Event.EventKeyboard = EventKeyboard;
    module.exports = cc.Event;
  }), {
    "../event/event": 61
  } ],
  55: [ (function(require, module, exports) {
    cc.EventListener = cc._Class.extend({
      ctor: function(type, listenerID, callback) {
        this._onEvent = callback;
        this._type = type || 0;
        this._listenerID = listenerID || "";
        this._registered = false;
        this._fixedPriority = 0;
        this._node = null;
        this._target = null;
        this._paused = true;
        this._isEnabled = true;
      },
      _setPaused: function(paused) {
        this._paused = paused;
      },
      _isPaused: function() {
        return this._paused;
      },
      _setRegistered: function(registered) {
        this._registered = registered;
      },
      _isRegistered: function() {
        return this._registered;
      },
      _getType: function() {
        return this._type;
      },
      _getListenerID: function() {
        return this._listenerID;
      },
      _setFixedPriority: function(fixedPriority) {
        this._fixedPriority = fixedPriority;
      },
      _getFixedPriority: function() {
        return this._fixedPriority;
      },
      _setSceneGraphPriority: function(node) {
        this._target = node;
        this._node = node;
      },
      _getSceneGraphPriority: function() {
        return this._node;
      },
      checkAvailable: function() {
        return null !== this._onEvent;
      },
      clone: function() {
        return null;
      },
      setEnabled: function(enabled) {
        this._isEnabled = enabled;
      },
      isEnabled: function() {
        return this._isEnabled;
      },
      retain: function() {},
      release: function() {}
    });
    cc.EventListener.UNKNOWN = 0;
    cc.EventListener.TOUCH_ONE_BY_ONE = 1;
    cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
    cc.EventListener.KEYBOARD = 3;
    cc.EventListener.MOUSE = 4;
    cc.EventListener.ACCELERATION = 6;
    cc.EventListener.CUSTOM = 8;
    cc._EventListenerCustom = cc.EventListener.extend({
      _onCustomEvent: null,
      ctor: function(listenerId, callback) {
        this._onCustomEvent = callback;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, listenerId, this._callback);
      },
      _callback: function(event) {
        null !== this._onCustomEvent && this._onCustomEvent(event);
      },
      checkAvailable: function() {
        return cc.EventListener.prototype.checkAvailable.call(this) && null !== this._onCustomEvent;
      },
      clone: function() {
        return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent);
      }
    });
    cc._EventListenerMouse = cc.EventListener.extend({
      onMouseDown: null,
      onMouseUp: null,
      onMouseMove: null,
      onMouseScroll: null,
      ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, this._callback);
      },
      _callback: function(event) {
        var eventType = cc.Event.EventMouse;
        switch (event._eventType) {
         case eventType.DOWN:
          this.onMouseDown && this.onMouseDown(event);
          break;

         case eventType.UP:
          this.onMouseUp && this.onMouseUp(event);
          break;

         case eventType.MOVE:
          this.onMouseMove && this.onMouseMove(event);
          break;

         case eventType.SCROLL:
          this.onMouseScroll && this.onMouseScroll(event);
        }
      },
      clone: function() {
        var eventListener = new cc._EventListenerMouse();
        eventListener.onMouseDown = this.onMouseDown;
        eventListener.onMouseUp = this.onMouseUp;
        eventListener.onMouseMove = this.onMouseMove;
        eventListener.onMouseScroll = this.onMouseScroll;
        return eventListener;
      },
      checkAvailable: function() {
        return true;
      }
    });
    cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
    cc._EventListenerTouchOneByOne = cc.EventListener.extend({
      _claimedTouches: null,
      swallowTouches: false,
      onTouchBegan: null,
      onTouchMoved: null,
      onTouchEnded: null,
      onTouchCancelled: null,
      ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null);
        this._claimedTouches = [];
      },
      setSwallowTouches: function(needSwallow) {
        this.swallowTouches = needSwallow;
      },
      isSwallowTouches: function() {
        return this.swallowTouches;
      },
      clone: function() {
        var eventListener = new cc._EventListenerTouchOneByOne();
        eventListener.onTouchBegan = this.onTouchBegan;
        eventListener.onTouchMoved = this.onTouchMoved;
        eventListener.onTouchEnded = this.onTouchEnded;
        eventListener.onTouchCancelled = this.onTouchCancelled;
        eventListener.swallowTouches = this.swallowTouches;
        return eventListener;
      },
      checkAvailable: function() {
        if (!this.onTouchBegan) {
          cc.logID(1801);
          return false;
        }
        return true;
      }
    });
    cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
    cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
      onTouchesBegan: null,
      onTouchesMoved: null,
      onTouchesEnded: null,
      onTouchesCancelled: null,
      ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null);
      },
      clone: function() {
        var eventListener = new cc._EventListenerTouchAllAtOnce();
        eventListener.onTouchesBegan = this.onTouchesBegan;
        eventListener.onTouchesMoved = this.onTouchesMoved;
        eventListener.onTouchesEnded = this.onTouchesEnded;
        eventListener.onTouchesCancelled = this.onTouchesCancelled;
        return eventListener;
      },
      checkAvailable: function() {
        if (null === this.onTouchesBegan && null === this.onTouchesMoved && null === this.onTouchesEnded && null === this.onTouchesCancelled) {
          cc.logID(1802);
          return false;
        }
        return true;
      }
    });
    cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
    cc.EventListener.create = function(argObj) {
      cc.assertID(argObj && argObj.event, 1900);
      var listenerType = argObj.event;
      delete argObj.event;
      var listener = null;
      if (listenerType === cc.EventListener.TOUCH_ONE_BY_ONE) listener = new cc._EventListenerTouchOneByOne(); else if (listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE) listener = new cc._EventListenerTouchAllAtOnce(); else if (listenerType === cc.EventListener.MOUSE) listener = new cc._EventListenerMouse(); else if (listenerType === cc.EventListener.CUSTOM) {
        listener = new cc._EventListenerCustom(argObj.eventName, argObj.callback);
        delete argObj.eventName;
        delete argObj.callback;
      } else if (listenerType === cc.EventListener.KEYBOARD) listener = new cc._EventListenerKeyboard(); else if (listenerType === cc.EventListener.ACCELERATION) {
        listener = new cc._EventListenerAcceleration(argObj.callback);
        delete argObj.callback;
      }
      for (var key in argObj) listener[key] = argObj[key];
      return listener;
    };
    cc._EventListenerAcceleration = cc.EventListener.extend({
      _onAccelerationEvent: null,
      ctor: function(callback) {
        this._onAccelerationEvent = callback;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, this._callback);
      },
      _callback: function(event) {
        this._onAccelerationEvent(event.acc, event);
      },
      checkAvailable: function() {
        cc.assertID(this._onAccelerationEvent, 1803);
        return true;
      },
      clone: function() {
        return new cc._EventListenerAcceleration(this._onAccelerationEvent);
      }
    });
    cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration";
    cc._EventListenerKeyboard = cc.EventListener.extend({
      onKeyPressed: null,
      onKeyReleased: null,
      ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, this._callback);
      },
      _callback: function(event) {
        event.isPressed ? this.onKeyPressed && this.onKeyPressed(event.keyCode, event) : this.onKeyReleased && this.onKeyReleased(event.keyCode, event);
      },
      clone: function() {
        var eventListener = new cc._EventListenerKeyboard();
        eventListener.onKeyPressed = this.onKeyPressed;
        eventListener.onKeyReleased = this.onKeyReleased;
        return eventListener;
      },
      checkAvailable: function() {
        if (null === this.onKeyPressed && null === this.onKeyReleased) {
          cc.logID(1800);
          return false;
        }
        return true;
      }
    });
    cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard";
  }), {} ],
  56: [ (function(require, module, exports) {
    var js = require("../platform/js");
    var _EventListenerVector = cc._Class.extend({
      ctor: function() {
        this._fixedListeners = [];
        this._sceneGraphListeners = [];
        this.gt0Index = 0;
      },
      size: function() {
        return this._fixedListeners.length + this._sceneGraphListeners.length;
      },
      empty: function() {
        return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length;
      },
      push: function(listener) {
        0 === listener._getFixedPriority() ? this._sceneGraphListeners.push(listener) : this._fixedListeners.push(listener);
      },
      clearSceneGraphListeners: function() {
        this._sceneGraphListeners.length = 0;
      },
      clearFixedListeners: function() {
        this._fixedListeners.length = 0;
      },
      clear: function() {
        this._sceneGraphListeners.length = 0;
        this._fixedListeners.length = 0;
      },
      getFixedPriorityListeners: function() {
        return this._fixedListeners;
      },
      getSceneGraphPriorityListeners: function() {
        return this._sceneGraphListeners;
      }
    });
    var __getListenerID = function(event) {
      var eventType = cc.Event, type = event.type;
      if (type === eventType.ACCELERATION) return cc._EventListenerAcceleration.LISTENER_ID;
      if (type === eventType.KEYBOARD) return cc._EventListenerKeyboard.LISTENER_ID;
      if (type.startsWith(eventType.MOUSE)) return cc._EventListenerMouse.LISTENER_ID;
      type.startsWith(eventType.TOUCH) && cc.logID(2e3);
      return "";
    };
    var eventManager = {
      DIRTY_NONE: 0,
      DIRTY_FIXED_PRIORITY: 1,
      DIRTY_SCENE_GRAPH_PRIORITY: 2,
      DIRTY_ALL: 3,
      _listenersMap: {},
      _priorityDirtyFlagMap: {},
      _nodeListenersMap: {},
      _nodePriorityMap: {},
      _globalZOrderNodeMap: {},
      _toAddedListeners: [],
      _toRemovedListeners: [],
      _dirtyNodes: [],
      _inDispatch: 0,
      _isEnabled: false,
      _nodePriorityIndex: 0,
      _internalCustomListenerIDs: [],
      _setDirtyForNode: function(node) {
        void 0 !== this._nodeListenersMap[node.__instanceId] && this._dirtyNodes.push(node);
        if (node.getChildren) {
          var _children = node.getChildren();
          for (var i = 0, len = _children ? _children.length : 0; i < len; i++) this._setDirtyForNode(_children[i]);
        }
      },
      pauseTarget: function(node, recursive) {
        if (!(node instanceof cc._BaseNode || node instanceof _ccsg.Node)) {
          cc.warnID(3506);
          return;
        }
        var listeners = this._nodeListenersMap[node.__instanceId], i, len;
        if (listeners) for (i = 0, len = listeners.length; i < len; i++) listeners[i]._setPaused(true);
        if (true === recursive) {
          var locChildren = node.getChildren();
          for (i = 0, len = locChildren ? locChildren.length : 0; i < len; i++) this.pauseTarget(locChildren[i], true);
        }
      },
      resumeTarget: function(node, recursive) {
        if (!(node instanceof cc._BaseNode || node instanceof _ccsg.Node)) {
          cc.warnID(3506);
          return;
        }
        var listeners = this._nodeListenersMap[node.__instanceId], i, len;
        if (listeners) for (i = 0, len = listeners.length; i < len; i++) listeners[i]._setPaused(false);
        this._setDirtyForNode(node);
        if (true === recursive && node.getChildren) {
          var locChildren = node.getChildren();
          for (i = 0, len = locChildren ? locChildren.length : 0; i < len; i++) this.resumeTarget(locChildren[i], true);
        }
      },
      _addListener: function(listener) {
        0 === this._inDispatch ? this._forceAddEventListener(listener) : this._toAddedListeners.push(listener);
      },
      _forceAddEventListener: function(listener) {
        var listenerID = listener._getListenerID();
        var listeners = this._listenersMap[listenerID];
        if (!listeners) {
          listeners = new _EventListenerVector();
          this._listenersMap[listenerID] = listeners;
        }
        listeners.push(listener);
        if (0 === listener._getFixedPriority()) {
          this._setDirty(listenerID, this.DIRTY_SCENE_GRAPH_PRIORITY);
          var node = listener._getSceneGraphPriority();
          null === node && cc.logID(3507);
          this._associateNodeAndEventListener(node, listener);
          node.isRunning() && this.resumeTarget(node);
        } else this._setDirty(listenerID, this.DIRTY_FIXED_PRIORITY);
      },
      _getListeners: function(listenerID) {
        return this._listenersMap[listenerID];
      },
      _updateDirtyFlagForSceneGraph: function() {
        if (0 === this._dirtyNodes.length) return;
        var locDirtyNodes = this._dirtyNodes, selListeners, selListener, locNodeListenersMap = this._nodeListenersMap;
        for (var i = 0, len = locDirtyNodes.length; i < len; i++) {
          selListeners = locNodeListenersMap[locDirtyNodes[i].__instanceId];
          if (selListeners) for (var j = 0, listenersLen = selListeners.length; j < listenersLen; j++) {
            selListener = selListeners[j];
            selListener && this._setDirty(selListener._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
          }
        }
        this._dirtyNodes.length = 0;
      },
      _removeAllListenersInVector: function(listenerVector) {
        if (!listenerVector) return;
        var selListener;
        for (var i = 0; i < listenerVector.length; ) {
          selListener = listenerVector[i];
          selListener._setRegistered(false);
          if (null != selListener._getSceneGraphPriority()) {
            this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
            selListener._setSceneGraphPriority(null);
          }
          0 === this._inDispatch ? cc.js.array.remove(listenerVector, selListener) : ++i;
        }
      },
      _removeListenersForListenerID: function(listenerID) {
        var listeners = this._listenersMap[listenerID], i;
        if (listeners) {
          var fixedPriorityListeners = listeners.getFixedPriorityListeners();
          var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
          this._removeAllListenersInVector(sceneGraphPriorityListeners);
          this._removeAllListenersInVector(fixedPriorityListeners);
          delete this._priorityDirtyFlagMap[listenerID];
          if (!this._inDispatch) {
            listeners.clear();
            delete this._listenersMap[listenerID];
          }
        }
        var locToAddedListeners = this._toAddedListeners, listener;
        for (i = 0; i < locToAddedListeners.length; ) {
          listener = locToAddedListeners[i];
          listener && listener._getListenerID() === listenerID ? cc.js.array.remove(locToAddedListeners, listener) : ++i;
        }
      },
      _sortEventListeners: function(listenerID) {
        var dirtyFlag = this.DIRTY_NONE, locFlagMap = this._priorityDirtyFlagMap;
        locFlagMap[listenerID] && (dirtyFlag = locFlagMap[listenerID]);
        if (dirtyFlag !== this.DIRTY_NONE) {
          locFlagMap[listenerID] = this.DIRTY_NONE;
          dirtyFlag & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(listenerID);
          if (dirtyFlag & this.DIRTY_SCENE_GRAPH_PRIORITY) {
            var rootEntity = cc.director.getScene();
            rootEntity && this._sortListenersOfSceneGraphPriority(listenerID, rootEntity);
          }
        }
      },
      _sortListenersOfSceneGraphPriority: function(listenerID, rootNode) {
        var listeners = this._getListeners(listenerID);
        if (!listeners) return;
        var sceneGraphListener = listeners.getSceneGraphPriorityListeners();
        if (!sceneGraphListener || 0 === sceneGraphListener.length) return;
        this._nodePriorityIndex = 0;
        this._nodePriorityMap = {};
        this._visitTarget(rootNode, true);
        listeners.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes);
      },
      _sortEventListenersOfSceneGraphPriorityDes: function(l1, l2) {
        var locNodePriorityMap = eventManager._nodePriorityMap, node1 = l1._getSceneGraphPriority(), node2 = l2._getSceneGraphPriority();
        if (!(l2 && node2 && locNodePriorityMap[node2.__instanceId])) return -1;
        if (!l1 || !node1 || !locNodePriorityMap[node1.__instanceId]) return 1;
        return locNodePriorityMap[node2.__instanceId] - locNodePriorityMap[node1.__instanceId];
      },
      _sortListenersOfFixedPriority: function(listenerID) {
        var listeners = this._listenersMap[listenerID];
        if (!listeners) return;
        var fixedListeners = listeners.getFixedPriorityListeners();
        if (!fixedListeners || 0 === fixedListeners.length) return;
        fixedListeners.sort(this._sortListenersOfFixedPriorityAsc);
        var index = 0;
        for (var len = fixedListeners.length; index < len; ) {
          if (fixedListeners[index]._getFixedPriority() >= 0) break;
          ++index;
        }
        listeners.gt0Index = index;
      },
      _sortListenersOfFixedPriorityAsc: function(l1, l2) {
        return l1._getFixedPriority() - l2._getFixedPriority();
      },
      _onUpdateListeners: function(listeners) {
        var fixedPriorityListeners = listeners.getFixedPriorityListeners();
        var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
        var i, selListener, idx, toRemovedListeners = this._toRemovedListeners;
        if (sceneGraphPriorityListeners) for (i = 0; i < sceneGraphPriorityListeners.length; ) {
          selListener = sceneGraphPriorityListeners[i];
          if (selListener._isRegistered()) ++i; else {
            cc.js.array.remove(sceneGraphPriorityListeners, selListener);
            idx = toRemovedListeners.indexOf(selListener);
            -1 !== idx && toRemovedListeners.splice(idx, 1);
          }
        }
        if (fixedPriorityListeners) for (i = 0; i < fixedPriorityListeners.length; ) {
          selListener = fixedPriorityListeners[i];
          if (selListener._isRegistered()) ++i; else {
            cc.js.array.remove(fixedPriorityListeners, selListener);
            idx = toRemovedListeners.indexOf(selListener);
            -1 !== idx && toRemovedListeners.splice(idx, 1);
          }
        }
        sceneGraphPriorityListeners && 0 === sceneGraphPriorityListeners.length && listeners.clearSceneGraphListeners();
        fixedPriorityListeners && 0 === fixedPriorityListeners.length && listeners.clearFixedListeners();
      },
      frameUpdateListeners: function() {
        var locListenersMap = this._listenersMap, locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;
        for (var selKey in locListenersMap) if (locListenersMap[selKey].empty()) {
          delete locPriorityDirtyFlagMap[selKey];
          delete locListenersMap[selKey];
        }
        var locToAddedListeners = this._toAddedListeners;
        if (0 !== locToAddedListeners.length) {
          for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
          locToAddedListeners.length = 0;
        }
        0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
      },
      _updateTouchListeners: function(event) {
        var locInDispatch = this._inDispatch;
        cc.assertID(locInDispatch > 0, 3508);
        if (locInDispatch > 1) return;
        var listeners;
        listeners = this._listenersMap[cc._EventListenerTouchOneByOne.LISTENER_ID];
        listeners && this._onUpdateListeners(listeners);
        listeners = this._listenersMap[cc._EventListenerTouchAllAtOnce.LISTENER_ID];
        listeners && this._onUpdateListeners(listeners);
        cc.assertID(1 === locInDispatch, 3509);
        var locToAddedListeners = this._toAddedListeners;
        if (0 !== locToAddedListeners.length) {
          for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
          this._toAddedListeners.length = 0;
        }
        0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
      },
      _cleanToRemovedListeners: function() {
        var toRemovedListeners = this._toRemovedListeners;
        for (var i = 0; i < toRemovedListeners.length; i++) {
          var selListener = toRemovedListeners[i];
          var listeners = this._listenersMap[selListener._getListenerID()];
          if (!listeners) continue;
          var idx, fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
          if (sceneGraphPriorityListeners) {
            idx = sceneGraphPriorityListeners.indexOf(selListener);
            -1 !== idx && sceneGraphPriorityListeners.splice(idx, 1);
          }
          if (fixedPriorityListeners) {
            idx = fixedPriorityListeners.indexOf(selListener);
            -1 !== idx && fixedPriorityListeners.splice(idx, 1);
          }
        }
        toRemovedListeners.length = 0;
      },
      _onTouchEventCallback: function(listener, argsObj) {
        if (!listener._isRegistered) return false;
        var event = argsObj.event, selTouch = event.currentTouch;
        event.currentTarget = listener._node;
        var isClaimed = false, removedIdx;
        var getCode = event.getEventCode(), EventTouch = cc.Event.EventTouch;
        if (getCode === EventTouch.BEGAN) {
          if (listener.onTouchBegan) {
            isClaimed = listener.onTouchBegan(selTouch, event);
            isClaimed && listener._registered && listener._claimedTouches.push(selTouch);
          }
        } else if (listener._claimedTouches.length > 0 && -1 !== (removedIdx = listener._claimedTouches.indexOf(selTouch))) {
          isClaimed = true;
          if (getCode === EventTouch.MOVED && listener.onTouchMoved) listener.onTouchMoved(selTouch, event); else if (getCode === EventTouch.ENDED) {
            listener.onTouchEnded && listener.onTouchEnded(selTouch, event);
            listener._registered && listener._claimedTouches.splice(removedIdx, 1);
          } else if (getCode === EventTouch.CANCELLED) {
            listener.onTouchCancelled && listener.onTouchCancelled(selTouch, event);
            listener._registered && listener._claimedTouches.splice(removedIdx, 1);
          }
        }
        if (event.isStopped()) {
          eventManager._updateTouchListeners(event);
          return true;
        }
        if (isClaimed && listener._registered && listener.swallowTouches) {
          argsObj.needsMutableSet && argsObj.touches.splice(selTouch, 1);
          return true;
        }
        return false;
      },
      _dispatchTouchEvent: function(event) {
        this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
        this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        var oneByOneListeners = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
        var allAtOnceListeners = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        if (null === oneByOneListeners && null === allAtOnceListeners) return;
        var originalTouches = event.getTouches(), mutableTouches = cc.js.array.copy(originalTouches);
        var oneByOneArgsObj = {
          event: event,
          needsMutableSet: oneByOneListeners && allAtOnceListeners,
          touches: mutableTouches,
          selTouch: null
        };
        if (oneByOneListeners) for (var i = 0; i < originalTouches.length; i++) {
          event.currentTouch = originalTouches[i];
          event._propagationStopped = event._propagationImmediateStopped = false;
          this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
        }
        if (allAtOnceListeners && mutableTouches.length > 0) {
          this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {
            event: event,
            touches: mutableTouches
          });
          if (event.isStopped()) return;
        }
        this._updateTouchListeners(event);
      },
      _onTouchesEventCallback: function(listener, callbackParams) {
        if (!listener._registered) return false;
        var EventTouch = cc.Event.EventTouch, event = callbackParams.event, touches = callbackParams.touches, getCode = event.getEventCode();
        event.currentTarget = listener._node;
        getCode === EventTouch.BEGAN && listener.onTouchesBegan ? listener.onTouchesBegan(touches, event) : getCode === EventTouch.MOVED && listener.onTouchesMoved ? listener.onTouchesMoved(touches, event) : getCode === EventTouch.ENDED && listener.onTouchesEnded ? listener.onTouchesEnded(touches, event) : getCode === EventTouch.CANCELLED && listener.onTouchesCancelled && listener.onTouchesCancelled(touches, event);
        if (event.isStopped()) {
          eventManager._updateTouchListeners(event);
          return true;
        }
        return false;
      },
      _associateNodeAndEventListener: function(node, listener) {
        var listeners = this._nodeListenersMap[node.__instanceId];
        if (!listeners) {
          listeners = [];
          this._nodeListenersMap[node.__instanceId] = listeners;
        }
        listeners.push(listener);
      },
      _dissociateNodeAndEventListener: function(node, listener) {
        var listeners = this._nodeListenersMap[node.__instanceId];
        if (listeners) {
          cc.js.array.remove(listeners, listener);
          0 === listeners.length && delete this._nodeListenersMap[node.__instanceId];
        }
      },
      _dispatchEventToListeners: function(listeners, onEvent, eventOrArgs) {
        var shouldStopPropagation = false;
        var fixedPriorityListeners = listeners.getFixedPriorityListeners();
        var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
        var i = 0, j, selListener;
        if (fixedPriorityListeners && 0 !== fixedPriorityListeners.length) for (;i < listeners.gt0Index; ++i) {
          selListener = fixedPriorityListeners[i];
          if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
            shouldStopPropagation = true;
            break;
          }
        }
        if (sceneGraphPriorityListeners && !shouldStopPropagation) for (j = 0; j < sceneGraphPriorityListeners.length; j++) {
          selListener = sceneGraphPriorityListeners[j];
          if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
            shouldStopPropagation = true;
            break;
          }
        }
        if (fixedPriorityListeners && !shouldStopPropagation) for (;i < fixedPriorityListeners.length; ++i) {
          selListener = fixedPriorityListeners[i];
          if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
            shouldStopPropagation = true;
            break;
          }
        }
      },
      _setDirty: function(listenerID, flag) {
        var locDirtyFlagMap = this._priorityDirtyFlagMap;
        null == locDirtyFlagMap[listenerID] ? locDirtyFlagMap[listenerID] = flag : locDirtyFlagMap[listenerID] = flag | locDirtyFlagMap[listenerID];
      },
      _visitTarget: function(node, isRootNode) {
        node._reorderChildDirty && node.sortAllChildren();
        var children = node.getChildren(), i = 0;
        var childrenCount = children.length, locGlobalZOrderNodeMap = this._globalZOrderNodeMap, locNodeListenersMap = this._nodeListenersMap;
        if (childrenCount > 0) {
          var child;
          for (;i < childrenCount; i++) {
            child = children[i];
            if (!(child && child.getLocalZOrder() < 0)) break;
            this._visitTarget(child, false);
          }
          if (void 0 !== locNodeListenersMap[node.__instanceId]) {
            locGlobalZOrderNodeMap[node.getGlobalZOrder()] || (locGlobalZOrderNodeMap[node.getGlobalZOrder()] = []);
            locGlobalZOrderNodeMap[node.getGlobalZOrder()].push(node.__instanceId);
          }
          for (;i < childrenCount; i++) {
            child = children[i];
            child && this._visitTarget(child, false);
          }
        } else if (void 0 !== locNodeListenersMap[node.__instanceId]) {
          locGlobalZOrderNodeMap[node.getGlobalZOrder()] || (locGlobalZOrderNodeMap[node.getGlobalZOrder()] = []);
          locGlobalZOrderNodeMap[node.getGlobalZOrder()].push(node.__instanceId);
        }
        if (isRootNode) {
          var globalZOrders = [];
          for (var selKey in locGlobalZOrderNodeMap) globalZOrders.push(selKey);
          globalZOrders.sort(this._sortNumberAsc);
          var zOrdersLen = globalZOrders.length, selZOrders, j, locNodePriorityMap = this._nodePriorityMap;
          for (i = 0; i < zOrdersLen; i++) {
            selZOrders = locGlobalZOrderNodeMap[globalZOrders[i]];
            for (j = 0; j < selZOrders.length; j++) locNodePriorityMap[selZOrders[j]] = ++this._nodePriorityIndex;
          }
          this._globalZOrderNodeMap = {};
        }
      },
      _sortNumberAsc: function(a, b) {
        return a - b;
      },
      hasEventListener: function(listenerID) {
        return !!this._getListeners(listenerID);
      },
      addListener: function(listener, nodeOrPriority) {
        cc.assertID(listener && nodeOrPriority, 3503);
        if (!(cc.js.isNumber(nodeOrPriority) || nodeOrPriority instanceof cc._BaseNode || nodeOrPriority instanceof _ccsg.Node)) {
          cc.warnID(3506);
          return;
        }
        if (listener instanceof cc.EventListener) {
          if (listener._isRegistered()) {
            cc.logID(3505);
            return;
          }
        } else {
          cc.assertID(!cc.js.isNumber(nodeOrPriority), 3504);
          listener = cc.EventListener.create(listener);
        }
        if (!listener.checkAvailable()) return;
        if (cc.js.isNumber(nodeOrPriority)) {
          if (0 === nodeOrPriority) {
            cc.logID(3500);
            return;
          }
          listener._setSceneGraphPriority(null);
          listener._setFixedPriority(nodeOrPriority);
          listener._setRegistered(true);
          listener._setPaused(false);
          this._addListener(listener);
        } else {
          listener._setSceneGraphPriority(nodeOrPriority);
          listener._setFixedPriority(0);
          listener._setRegistered(true);
          this._addListener(listener);
        }
        return listener;
      },
      addCustomListener: function(eventName, callback) {
        var listener = new cc._EventListenerCustom(eventName, callback);
        this.addListener(listener, 1);
        return listener;
      },
      removeListener: function(listener) {
        if (null == listener) return;
        var isFound, locListener = this._listenersMap;
        for (var selKey in locListener) {
          var listeners = locListener[selKey];
          var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
          isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener);
          if (isFound) this._setDirty(listener._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY); else {
            isFound = this._removeListenerInVector(fixedPriorityListeners, listener);
            isFound && this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
          }
          if (listeners.empty()) {
            delete this._priorityDirtyFlagMap[listener._getListenerID()];
            delete locListener[selKey];
          }
          if (isFound) break;
        }
        if (!isFound) {
          var locToAddedListeners = this._toAddedListeners;
          for (var i = 0, len = locToAddedListeners.length; i < len; i++) {
            var selListener = locToAddedListeners[i];
            if (selListener === listener) {
              cc.js.array.remove(locToAddedListeners, selListener);
              selListener._setRegistered(false);
              break;
            }
          }
        }
      },
      _removeListenerInCallback: function(listeners, callback) {
        if (null == listeners) return false;
        for (var i = 0, len = listeners.length; i < len; i++) {
          var selListener = listeners[i];
          if (selListener._onCustomEvent === callback || selListener._onEvent === callback) {
            selListener._setRegistered(false);
            if (null != selListener._getSceneGraphPriority()) {
              this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
              selListener._setSceneGraphPriority(null);
            }
            0 === this._inDispatch ? cc.js.array.remove(listeners, selListener) : this._toRemovedListeners.push(selListener);
            return true;
          }
        }
        return false;
      },
      _removeListenerInVector: function(listeners, listener) {
        if (null == listeners) return false;
        for (var i = 0, len = listeners.length; i < len; i++) {
          var selListener = listeners[i];
          if (selListener === listener) {
            selListener._setRegistered(false);
            if (null != selListener._getSceneGraphPriority()) {
              this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
              selListener._setSceneGraphPriority(null);
            }
            0 === this._inDispatch ? cc.js.array.remove(listeners, selListener) : this._toRemovedListeners.push(selListener);
            return true;
          }
        }
        return false;
      },
      removeListeners: function(listenerType, recursive) {
        var i, _t = this;
        if (!(cc.js.isNumber(listenerType) || listenerType instanceof cc._BaseNode || listenerType instanceof _ccsg.Node)) {
          cc.warnID(3506);
          return;
        }
        if (void 0 !== listenerType.__instanceId) {
          delete _t._nodePriorityMap[listenerType.__instanceId];
          cc.js.array.remove(_t._dirtyNodes, listenerType);
          var listeners = _t._nodeListenersMap[listenerType.__instanceId], i;
          if (listeners) {
            var listenersCopy = cc.js.array.copy(listeners);
            for (i = 0; i < listenersCopy.length; i++) _t.removeListener(listenersCopy[i]);
            delete _t._nodeListenersMap[listenerType.__instanceId];
          }
          var locToAddedListeners = _t._toAddedListeners;
          for (i = 0; i < locToAddedListeners.length; ) {
            var listener = locToAddedListeners[i];
            if (listener._getSceneGraphPriority() === listenerType) {
              listener._setSceneGraphPriority(null);
              listener._setRegistered(false);
              locToAddedListeners.splice(i, 1);
            } else ++i;
          }
          if (true === recursive) {
            var locChildren = listenerType.getChildren(), len;
            for (i = 0, len = locChildren.length; i < len; i++) _t.removeListeners(locChildren[i], true);
          }
        } else listenerType === cc.EventListener.TOUCH_ONE_BY_ONE ? _t._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE ? _t._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) : listenerType === cc.EventListener.MOUSE ? _t._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : listenerType === cc.EventListener.ACCELERATION ? _t._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : listenerType === cc.EventListener.KEYBOARD ? _t._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.logID(3501);
      },
      removeCustomListeners: function(customEventName) {
        this._removeListenersForListenerID(customEventName);
      },
      removeAllListeners: function() {
        var locListeners = this._listenersMap, locInternalCustomEventIDs = this._internalCustomListenerIDs;
        for (var selKey in locListeners) -1 === locInternalCustomEventIDs.indexOf(selKey) && this._removeListenersForListenerID(selKey);
      },
      setPriority: function(listener, fixedPriority) {
        if (null == listener) return;
        var locListeners = this._listenersMap;
        for (var selKey in locListeners) {
          var selListeners = locListeners[selKey];
          var fixedPriorityListeners = selListeners.getFixedPriorityListeners();
          if (fixedPriorityListeners) {
            var found = fixedPriorityListeners.indexOf(listener);
            if (-1 !== found) {
              null != listener._getSceneGraphPriority() && cc.logID(3502);
              if (listener._getFixedPriority() !== fixedPriority) {
                listener._setFixedPriority(fixedPriority);
                this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
              }
              return;
            }
          }
        }
      },
      setEnabled: function(enabled) {
        this._isEnabled = enabled;
      },
      isEnabled: function() {
        return this._isEnabled;
      },
      dispatchEvent: function(event) {
        if (!this._isEnabled) return;
        this._updateDirtyFlagForSceneGraph();
        this._inDispatch++;
        if (!event || !event.getType) throw new Error(cc._getError(3511));
        if (event.getType().startsWith(cc.Event.TOUCH)) {
          this._dispatchTouchEvent(event);
          this._inDispatch--;
          return;
        }
        var listenerID = __getListenerID(event);
        this._sortEventListeners(listenerID);
        var selListeners = this._listenersMap[listenerID];
        if (null != selListeners) {
          this._dispatchEventToListeners(selListeners, this._onListenerCallback, event);
          this._onUpdateListeners(selListeners);
        }
        this._inDispatch--;
      },
      _onListenerCallback: function(listener, event) {
        event.currentTarget = listener._target;
        listener._onEvent(event);
        return event.isStopped();
      },
      dispatchCustomEvent: function(eventName, optionalUserData) {
        var ev = new cc.Event.EventCustom(eventName);
        ev.setUserData(optionalUserData);
        this.dispatchEvent(ev);
      }
    };
    js.get(cc, "eventManager", (function() {
      cc.warnID(1405, "cc.eventManager", "cc.EventTarget or cc.systemEvent");
      return eventManager;
    }));
    module.exports = eventManager;
  }), {
    "../platform/js": 109
  } ],
  57: [ (function(require, module, exports) {
    cc.Touch = cc._Class.extend({
      ctor: function(x, y, id) {
        this._lastModified = 0;
        this.setTouchInfo(id, x, y);
      },
      getLocation: function() {
        return {
          x: this._point.x,
          y: this._point.y
        };
      },
      getLocationX: function() {
        return this._point.x;
      },
      getLocationY: function() {
        return this._point.y;
      },
      getPreviousLocation: function() {
        return {
          x: this._prevPoint.x,
          y: this._prevPoint.y
        };
      },
      getStartLocation: function() {
        return {
          x: this._startPoint.x,
          y: this._startPoint.y
        };
      },
      getDelta: function() {
        return cc.pSub(this._point, this._prevPoint);
      },
      getLocationInView: function() {
        return {
          x: this._point.x,
          y: cc.view._designResolutionSize.height - this._point.y
        };
      },
      getPreviousLocationInView: function() {
        return {
          x: this._prevPoint.x,
          y: cc.view._designResolutionSize.height - this._prevPoint.y
        };
      },
      getStartLocationInView: function() {
        return {
          x: this._startPoint.x,
          y: cc.view._designResolutionSize.height - this._startPoint.y
        };
      },
      getID: function() {
        return this._id;
      },
      setTouchInfo: function(id, x, y) {
        this._prevPoint = this._point;
        this._point = cc.p(x || 0, y || 0);
        this._id = id;
        if (!this._startPointCaptured) {
          this._startPoint = cc.p(this._point);
          cc.view._convertPointWithScale(this._startPoint);
          this._startPointCaptured = true;
        }
      },
      _setPoint: function(x, y) {
        if (void 0 === y) {
          this._point.x = x.x;
          this._point.y = x.y;
        } else {
          this._point.x = x;
          this._point.y = y;
        }
      },
      _setPrevPoint: function(x, y) {
        this._prevPoint = void 0 === y ? cc.p(x.x, x.y) : cc.p(x || 0, y || 0);
      }
    });
  }), {} ],
  58: [ (function(require, module, exports) {
    require("./CCEvent");
    var eventManager;
    false;
    require("./CCTouch");
    require("./CCEventListener");
    eventManager = require("./CCEventManager");
    module.exports = eventManager;
    false;
  }), {
    "./CCEvent": 54,
    "./CCEventListener": 55,
    "./CCEventManager": 56,
    "./CCTouch": 57
  } ],
  59: [ (function(require, module, exports) {
    var JS = cc.js;
    var CallbacksHandler = require("../platform/callbacks-invoker").CallbacksHandler;
    function EventListeners() {
      CallbacksHandler.call(this);
    }
    JS.extend(EventListeners, CallbacksHandler);
    EventListeners.prototype.invoke = function(event, captureListeners) {
      var key = event.type;
      var list = this._callbackTable[key];
      if (list) {
        var rootInvoker = !list.isInvoking;
        list.isInvoking = true;
        var callbacks = list.callbacks;
        var targets = list.targets;
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          var callback = callbacks[i];
          if (callback) {
            var target = targets[i] || event.currentTarget;
            callback.call(target, event, captureListeners);
            if (event._propagationImmediateStopped) break;
          }
        }
        if (rootInvoker) {
          list.isInvoking = false;
          list.containCanceled && list.purgeCanceled();
        }
      }
    };
    module.exports = EventListeners;
    false;
  }), {
    "../platform/callbacks-invoker": 102
  } ],
  60: [ (function(require, module, exports) {
    var EventListeners = require("./event-listeners");
    require("./event");
    var JS = cc.js;
    var fastRemove = JS.array.fastRemove;
    var cachedArray = new Array(16);
    cachedArray.length = 0;
    var CAPTURING_FLAG = 2;
    var BUBBLING_FLAG = 4;
    var _doDispatchEvent = function(owner, event) {
      var target, i;
      event.target = owner;
      cachedArray.length = 0;
      owner._getCapturingTargets(event.type, cachedArray);
      event.eventPhase = 1;
      for (i = cachedArray.length - 1; i >= 0; --i) {
        target = cachedArray[i];
        if (target._isTargetActive(event.type) && target._capturingListeners) {
          event.currentTarget = target;
          target._capturingListeners.invoke(event, cachedArray);
          if (event._propagationStopped) {
            cachedArray.length = 0;
            return;
          }
        }
      }
      cachedArray.length = 0;
      if (owner._isTargetActive(event.type)) {
        event.eventPhase = 2;
        event.currentTarget = owner;
        owner._capturingListeners && owner._capturingListeners.invoke(event);
        !event._propagationImmediateStopped && owner._bubblingListeners && owner._bubblingListeners.invoke(event);
      }
      if (!event._propagationStopped && event.bubbles) {
        owner._getBubblingTargets(event.type, cachedArray);
        event.eventPhase = 3;
        for (i = 0; i < cachedArray.length; ++i) {
          target = cachedArray[i];
          if (target._isTargetActive(event.type) && target._bubblingListeners) {
            event.currentTarget = target;
            target._bubblingListeners.invoke(event);
            if (event._propagationStopped) {
              cachedArray.length = 0;
              return;
            }
          }
        }
      }
      cachedArray.length = 0;
    };
    function EventTarget() {
      this._capturingListeners = null;
      this._bubblingListeners = null;
      this._hasListenerCache = null;
    }
    var proto = EventTarget.prototype;
    proto._addEventFlag = function(type, listeners, useCapture) {
      var cache = this._hasListenerCache;
      cache || (cache = this._hasListenerCache = cc.js.createMap());
      void 0 === cache[type] && (cache[type] = 0);
      var flag = useCapture ? CAPTURING_FLAG : BUBBLING_FLAG;
      cache[type] |= flag;
    };
    proto._purgeEventFlag = function(type, listeners, useCapture) {
      var cache = this._hasListenerCache;
      if (!cache || listeners.has(type)) return;
      var flag = useCapture ? CAPTURING_FLAG : BUBBLING_FLAG;
      cache[type] &= ~flag;
      0 === cache[type] && delete cache[type];
    };
    proto._resetFlagForTarget = function(target, listeners, useCapture) {
      var cache = this._hasListenerCache;
      if (!cache) return;
      var flag = useCapture ? CAPTURING_FLAG : BUBBLING_FLAG;
      for (var key in cache) if (!listeners.has(key)) {
        cache[key] &= ~flag;
        0 === cache[key] && delete cache[key];
      }
    };
    proto.hasEventListener = function(type, checkCapture) {
      var cache = this._hasListenerCache;
      if (!cache) return false;
      var flag = checkCapture ? CAPTURING_FLAG : BUBBLING_FLAG;
      return (cache[type] & flag) > 0;
    };
    proto.on = function(type, callback, target, useCapture) {
      if ("boolean" === typeof target) {
        useCapture = target;
        target = void 0;
      } else useCapture = !!useCapture;
      if (!callback) {
        cc.errorID(6800);
        return;
      }
      var listeners = null;
      listeners = useCapture ? this._capturingListeners = this._capturingListeners || new EventListeners() : this._bubblingListeners = this._bubblingListeners || new EventListeners();
      if (!listeners.has(type, callback, target)) {
        listeners.add(type, callback, target);
        target && target.__eventTargets && target.__eventTargets.push(this);
        this._addEventFlag(type, listeners, useCapture);
      }
      return callback;
    };
    proto.off = function(type, callback, target, useCapture) {
      if ("boolean" === typeof target) {
        useCapture = target;
        target = void 0;
      } else useCapture = !!useCapture;
      if (callback) {
        var listeners = useCapture ? this._capturingListeners : this._bubblingListeners;
        if (listeners) {
          listeners.remove(type, callback, target);
          target && target.__eventTargets && fastRemove(target.__eventTargets, this);
          this._purgeEventFlag(type, listeners, useCapture);
        }
      } else {
        this._capturingListeners && this._capturingListeners.removeAll(type);
        this._bubblingListeners && this._bubblingListeners.removeAll(type);
        this._hasListenerCache && delete this._hasListenerCache[type];
      }
    };
    proto.targetOff = function(target) {
      if (this._capturingListeners) {
        this._capturingListeners.removeAll(target);
        this._resetFlagForTarget(target, this._capturingListeners, true);
      }
      if (this._bubblingListeners) {
        this._bubblingListeners.removeAll(target);
        this._resetFlagForTarget(target, this._bubblingListeners, false);
      }
    };
    proto.once = function(type, callback, target, useCapture) {
      var eventType_hasOnceListener = "__ONCE_FLAG:" + type;
      var listeners = useCapture ? this._capturingListeners : this._bubblingListeners;
      var hasOnceListener = listeners && listeners.has(eventType_hasOnceListener, callback, target);
      if (!hasOnceListener) {
        var self = this;
        var onceWrapper = function(event) {
          self.off(type, onceWrapper, target, useCapture);
          listeners.remove(eventType_hasOnceListener, callback, target);
          callback.call(this, event);
        };
        this.on(type, onceWrapper, target, useCapture);
        listeners || (listeners = useCapture ? this._capturingListeners : this._bubblingListeners);
        listeners.add(eventType_hasOnceListener, callback, target);
      }
    };
    proto.dispatchEvent = function(event) {
      _doDispatchEvent(this, event);
      cachedArray.length = 0;
    };
    proto.emit = function(message, detail) {
      false;
      var cache = this._hasListenerCache;
      if (!cache) return;
      var flag = cache[message];
      if (!flag) return;
      var event = cc.Event.EventCustom.get(message);
      event.detail = detail;
      event.eventPhase = 2;
      event.target = event.currentTarget = this;
      var capturingListeners = this._capturingListeners;
      capturingListeners && flag & CAPTURING_FLAG && capturingListeners.invoke(event);
      var bubblingListeners = this._bubblingListeners;
      bubblingListeners && flag & BUBBLING_FLAG && !event._propagationImmediateStopped && bubblingListeners.invoke(event);
      event.detail = null;
      cc.Event.EventCustom.put(event);
    };
    proto._isTargetActive = function(type) {
      return true;
    };
    proto._getCapturingTargets = function(type, array) {};
    proto._getBubblingTargets = function(type, array) {};
    EventTarget.prototype._EventTargetOn = EventTarget.prototype.on;
    EventTarget.prototype._EventTargetOnce = EventTarget.prototype.once;
    EventTarget.prototype._EventTargetOff = EventTarget.prototype.off;
    EventTarget.prototype._EventTargetTargetOff = EventTarget.prototype.targetOff;
    cc.EventTarget = module.exports = EventTarget;
  }), {
    "./event": 61,
    "./event-listeners": 59
  } ],
  61: [ (function(require, module, exports) {
    var JS = require("../platform/js");
    cc.Event = function(type, bubbles) {
      this.type = type;
      this.bubbles = !!bubbles;
      this.target = null;
      this.currentTarget = null;
      this.eventPhase = 0;
      this._propagationStopped = false;
      this._propagationImmediateStopped = false;
    };
    cc.Event.prototype = {
      constructor: cc.Event,
      unuse: function() {
        this.type = cc.Event.NO_TYPE;
        this.target = null;
        this.currentTarget = null;
        this.eventPhase = cc.Event.NONE;
        this._propagationStopped = false;
        this._propagationImmediateStopped = false;
      },
      reuse: function(type, bubbles) {
        this.type = type;
        this.bubbles = bubbles || false;
      },
      stopPropagation: function() {
        this._propagationStopped = true;
      },
      stopPropagationImmediate: function() {
        this._propagationImmediateStopped = true;
      },
      isStopped: function() {
        return this._propagationStopped || this._propagationImmediateStopped;
      },
      getCurrentTarget: function() {
        return this.currentTarget;
      },
      getType: function() {
        return this.type;
      }
    };
    cc.Event.NO_TYPE = "no_type";
    cc.Event.TOUCH = "touch";
    cc.Event.MOUSE = "mouse";
    cc.Event.KEYBOARD = "keyboard";
    cc.Event.ACCELERATION = "acceleration";
    cc.Event.NONE = 0;
    cc.Event.CAPTURING_PHASE = 1;
    cc.Event.AT_TARGET = 2;
    cc.Event.BUBBLING_PHASE = 3;
    var EventCustom = function(type, bubbles) {
      cc.Event.call(this, type, bubbles);
      this.detail = null;
    };
    JS.extend(EventCustom, cc.Event);
    EventCustom.prototype.reset = EventCustom;
    EventCustom.prototype.setUserData = function(data) {
      this.detail = data;
    };
    EventCustom.prototype.getUserData = function() {
      return this.detail;
    };
    EventCustom.prototype.getEventName = cc.Event.prototype.getType;
    var MAX_POOL_SIZE = 10;
    var _eventPool = new JS.Pool(MAX_POOL_SIZE);
    EventCustom.put = function(event) {
      _eventPool.put(event);
    };
    EventCustom.get = function(type, bubbles) {
      var event = _eventPool._get();
      event ? event.reset(type, bubbles) : event = new EventCustom(type, bubbles);
      return event;
    };
    cc.Event.EventCustom = EventCustom;
    module.exports = cc.Event;
  }), {
    "../platform/js": 109
  } ],
  62: [ (function(require, module, exports) {
    require("./event");
    require("./event-listeners");
    require("./event-target");
    require("./system-event");
  }), {
    "./event": 61,
    "./event-listeners": 59,
    "./event-target": 60,
    "./system-event": 63
  } ],
  63: [ (function(require, module, exports) {
    var EventTarget = require("../event/event-target");
    var eventManager = require("../event-manager");
    var inputManger;
    false;
    inputManger = require("../platform/CCInputManager");
    var EventType = cc.Enum({
      KEY_DOWN: "keydown",
      KEY_UP: "keyup",
      DEVICEMOTION: "devicemotion"
    });
    var keyboardListener = null;
    var accelerationListener = null;
    var keyboardListenerAddFrame = 0;
    var SystemEvent = cc.Class({
      name: "SystemEvent",
      extends: EventTarget,
      statics: {
        EventType: EventType
      },
      setAccelerometerEnabled: function(isEnable) {
        inputManger.setAccelerometerEnabled(isEnable);
      },
      setAccelerometerInterval: function(interval) {
        inputManger.setAccelerometerInterval(interval);
      },
      on: function(type, callback, target, useCapture) {
        this._super(type, callback, target, useCapture);
        if (type === EventType.KEY_DOWN || type === EventType.KEY_UP) {
          keyboardListener || (keyboardListener = cc.EventListener.create({
            event: cc.EventListener.KEYBOARD,
            onKeyPressed: function(keyCode, event) {
              event.type = EventType.KEY_DOWN;
              false;
              cc.systemEvent.dispatchEvent(event);
            },
            onKeyReleased: function(keyCode, event) {
              event.type = EventType.KEY_UP;
              false;
              cc.systemEvent.dispatchEvent(event);
            }
          }));
          if (!eventManager.hasEventListener(cc._EventListenerKeyboard.LISTENER_ID)) {
            var currentFrame = cc.director.getTotalFrames();
            if (currentFrame !== keyboardListenerAddFrame) {
              eventManager.addListener(keyboardListener, 1);
              keyboardListenerAddFrame = currentFrame;
            }
          }
        }
        if (type === EventType.DEVICEMOTION) {
          accelerationListener || (accelerationListener = cc.EventListener.create({
            event: cc.EventListener.ACCELERATION,
            callback: function(acc, event) {
              event.type = EventType.DEVICEMOTION;
              false;
              cc.systemEvent.dispatchEvent(event);
            }
          }));
          eventManager.hasEventListener(cc._EventListenerAcceleration.LISTENER_ID) || eventManager.addListener(accelerationListener, 1);
        }
      },
      off: function(type, callback, target, useCapture) {
        this._super(type, callback, target, useCapture);
        if (keyboardListener && (type === EventType.KEY_DOWN || type === EventType.KEY_UP)) {
          var hasKeyDownEventListener = this.hasEventListener(EventType.KEY_DOWN);
          var hasKeyUpEventListener = this.hasEventListener(EventType.KEY_UP);
          hasKeyDownEventListener || hasKeyUpEventListener || eventManager.removeListener(keyboardListener);
        }
        accelerationListener && type === EventType.DEVICEMOTION && eventManager.removeListener(accelerationListener);
      }
    });
    cc.SystemEvent = module.exports = SystemEvent;
    true;
    cc.systemEvent = new cc.SystemEvent();
  }), {
    "../event-manager": 58,
    "../event/event-target": 60,
    "../platform/CCInputManager": 93
  } ],
  64: [ (function(require, module, exports) {
    require("./platform");
    require("./assets");
    true;
    require("./CCNode");
    require("./CCScene");
    require("./components");
    require("./graphics");
    require("./collider");
    require("./collider/CCIntersection");
    require("./physics");
    require("./camera/CCCamera");
    require("./base-ui/CCWidgetManager");
  }), {
    "./CCNode": 15,
    "./CCScene": 16,
    "./assets": 31,
    "./base-ui/CCWidgetManager": 36,
    "./camera/CCCamera": 179,
    "./collider": 179,
    "./collider/CCIntersection": 179,
    "./components": 52,
    "./graphics": 179,
    "./physics": 179,
    "./platform": 106
  } ],
  65: [ (function(require, module, exports) {
    require("./CCTextUtils");
    var EventTarget = require("../event/event-target");
    var JS = require("../platform/js");
    var FontLetterDefinition = function() {
      this._u = 0;
      this._v = 0;
      this._width = 0;
      this._height = 0;
      this._offsetX = 0;
      this._offsetY = 0;
      this._textureID = 0;
      this._validDefinition = false;
      this._xAdvance = 0;
    };
    cc.FontAtlas = function(fntConfig) {
      this._lineHeight = fntConfig.commonHeight;
      this._fontSize = fntConfig.fontSize;
      this._letterDefinitions = {};
      this._fntConfig = fntConfig;
    };
    cc.FontAtlas.prototype = {
      constructor: cc.FontAtlas,
      setFontSize: function(fontSize) {
        this._fontSize = fontSize;
      },
      getOriginalFontSize: function() {
        return this._fntConfig.fontSize;
      },
      addLetterDefinitions: function(letter, letterDefinition) {
        this._letterDefinitions[letter] = letterDefinition;
      },
      cloneLetterDefinition: function() {
        var copyLetterDefinitions = {};
        for (var key in this._letterDefinitions) {
          var value = new FontLetterDefinition();
          cc.js.mixin(value, this._letterDefinitions[key]);
          copyLetterDefinitions[key] = value;
        }
        return copyLetterDefinitions;
      },
      assignLetterDefinitions: function(letterDefinition) {
        for (var key in this._letterDefinitions) {
          var newValue = letterDefinition[key];
          var oldValue = this._letterDefinitions[key];
          cc.js.mixin(oldValue, newValue);
        }
      },
      scaleFontLetterDefinition: function(scaleFactor) {
        for (var fontDefinition in this._letterDefinitions) {
          var letterDefinitions = this._letterDefinitions[fontDefinition];
          letterDefinitions._width *= scaleFactor;
          letterDefinitions._height *= scaleFactor;
          letterDefinitions._offsetX *= scaleFactor;
          letterDefinitions._offsetY *= scaleFactor;
          letterDefinitions._xAdvance *= scaleFactor;
        }
      },
      getLetterDefinitionForChar: function(char) {
        var hasKey = this._letterDefinitions.hasOwnProperty(char.charCodeAt(0));
        var letterDefinition;
        letterDefinition = hasKey ? this._letterDefinitions[char.charCodeAt(0)] : null;
        return letterDefinition;
      }
    };
    var LetterInfo = function() {
      this._char = "";
      this._valid = true;
      this._positionX = 0;
      this._positionY = 0;
      this._lineIndex = 0;
    };
    _ccsg.Label = _ccsg.Node.extend({
      _hAlign: cc.TextAlignment.LEFT,
      _vAlign: cc.VerticalTextAlignment.TOP,
      _string: "",
      _fontSize: 40,
      _drawFontsize: 40,
      _overFlow: 0,
      _isWrapText: true,
      _spacingX: 0,
      _blendFunc: null,
      _labelType: 0,
      _fontHandle: "",
      _lineSpacing: 0,
      _maxLineWidth: 0,
      _labelDimensions: cc.size(0, 0),
      _labelWidth: 0,
      _labelHeight: 0,
      _lineHeight: 40,
      _outlined: false,
      _outlineColor: null,
      _outlineWidth: 1,
      _gradientEnabled: false,
      _gradientStartColor: cc.color(255, 255, 255, 255),
      _gradientEndColor: cc.color(255, 255, 255, 255),
      _gradientDirection: 0,
      _className: "Label",
      _margin: 0,
      _isBold: false,
      _isItalic: false,
      _isUnderline: false,
      _fontAsset: null,
      onExit: function() {
        this._super();
        this._renderCmd._texture._releaseTexture();
        this._notifyLabelSkinDirty();
      },
      ctor: function(string, fontAsset) {
        EventTarget.call(this);
        var isAsset = fontAsset instanceof cc.Font;
        var fontHandle = isAsset ? fontAsset.nativeUrl : "";
        this._fontHandle = fontHandle;
        "string" !== typeof string && (string = "" + string);
        this._string = string;
        _ccsg.Node.prototype.ctor.call(this);
        this.setAnchorPoint(.5, .5);
        _ccsg.Node.prototype.setContentSize.call(this, 10, 10);
        this._blendFunc = cc.BlendFunc._alphaNonPremultiplied();
        this._imageOffset = cc.p(0, 0);
        this._numberOfLines = 0;
        this._lettersInfo = [];
        this._linesWidth = [];
        this._linesOffsetX = [];
        this._horizontalKernings = [];
        this._reusedRect = cc.rect(0, 0, 0, 0);
        isAsset ? this.setFontAsset(fontAsset) : this.setFontFamily(fontHandle);
        this.setString(this._string);
      },
      _resetBMFont: function() {
        this._imageOffset.x = this._imageOffset.y = 0;
        this._cascadeColorEnabled = true;
        this._cascadeOpacityEnabled = true;
        this._fontAtlas = null;
        this._config = null;
        this._numberOfLines = 0;
        this._lettersInfo.length = 0;
        this._linesWidth.length = 0;
        this._linesOffsetX.length = 0;
        this._textDesiredHeight = 0;
        this._letterOffsetY = 0;
        this._tailoredTopY = 0;
        this._tailoredBottomY = 0;
        this._bmfontScale = 1;
        this._horizontalKernings.length = 0;
        this._lineBreakWithoutSpaces = false;
        this._reusedRect.x = this._reusedRect.y = this._reusedRect.width = this._reusedRect.height = 0;
        this._textureLoaded = false;
        if (this._spriteBatchNode) {
          this.removeChild(this._spriteBatchNode);
          this._spriteBatchNode = null;
        }
      },
      setHorizontalAlign: function(align) {
        if (this._hAlign === align) return;
        this._hAlign = align;
        this._notifyLabelSkinDirty();
      },
      getHorizontalAlign: function() {
        return this._hAlign;
      },
      setVerticalAlign: function(align) {
        if (this._vAlign === align) return;
        this._vAlign = align;
        this._notifyLabelSkinDirty();
      },
      getVerticalAlign: function() {
        return this._vAlign;
      },
      setString: function(string) {
        "string" !== typeof string && (string = "" + string);
        if (this._string === string) return;
        this._string = string;
        this._notifyLabelSkinDirty();
      },
      setMargin: function(value) {
        if (this._margin === value) return;
        this._margin = value;
        this._notifyLabelSkinDirty();
      },
      getString: function() {
        return this._string;
      },
      getStringLength: function() {
        return this._string.length;
      },
      enableWrapText: function(enabled) {
        if (this._isWrapText === enabled) return;
        if (this._overFlow === _ccsg.Label.Overflow.RESIZE_HEIGHT || this._overFlow === _ccsg.Label.Overflow.NONE) return;
        this._isWrapText = enabled;
        this._rescaleWithOriginalFontSize();
        this._notifyLabelSkinDirty();
      },
      enableItalics: function(enabled) {
        this._isItalic = enabled;
        enabled ? this.setSkewX(12) : this.setSkewX(0);
      },
      enableBold: function(enabled) {
        if (this._isBold === enabled) return;
        this._isBold = enabled;
        this._notifyLabelSkinDirty();
      },
      enableUnderline: function(enabled) {
        if (this._isUnderline === enabled) return;
        this._isUnderline = enabled;
        this._notifyLabelSkinDirty();
      },
      isWrapTextEnabled: function() {
        return this._isWrapText;
      },
      getFontName: function() {
        return this._fontHandle;
      },
      setFontSize: function(fntSize) {
        if (this._fontSize === fntSize) return;
        this._fontSize = fntSize;
        this._drawFontsize = fntSize;
        this._notifyLabelSkinDirty();
      },
      getFontSize: function() {
        return this._fontSize;
      },
      isOutlined: function() {
        return this._outlined;
      },
      setOutlined: function(value) {
        if (this._outlined === value) return;
        this._outlined = !!value;
        this._notifyLabelSkinDirty();
      },
      setFillColorGradientEnabled: function(value) {
        if (this._gradientEnabled === value) return;
        this._gradientEnabled = !!value;
        this._notifyLabelSkinDirty();
      },
      getFillColorGradientEnabled: function() {
        return this._gradientEnabled;
      },
      setGradientStartColor: function(value) {
        if (this._gradientStartColor === value) return;
        this._gradientStartColor = value;
        this._notifyLabelSkinDirty();
      },
      getGradientStartColor: function() {
        return this._gradientStartColor;
      },
      setGradientEndColor: function(value) {
        if (this._gradientEndColor === value) return;
        this._gradientEndColor = value;
        this._notifyLabelSkinDirty();
      },
      getGradientEndColor: function() {
        return this._gradientEndColor;
      },
      setFillColorGradientDirection: function(direction) {
        this._gradientDirection = direction;
        this._notifyLabelSkinDirty();
      },
      getFillColorGradientDirection: function() {
        return this._gradientDirection;
      },
      getOutlineColor: function() {
        return this._outlineColor;
      },
      setOutlineColor: function(value) {
        if (this._outlineColor === value) return;
        this._outlineColor = cc.color(value);
        this._notifyLabelSkinDirty();
      },
      setOutlineWidth: function(value) {
        if (this._outlineWidth === value) return;
        this._outlineWidth = value;
        this._notifyLabelSkinDirty();
      },
      getOutlineWidth: function() {
        return this._outlineWidth;
      },
      _updateWrapText: function(overflow) {
        overflow === _ccsg.Label.Overflow.RESIZE_HEIGHT && (this._isWrapText = true);
        overflow === _ccsg.Label.Overflow.NONE && (this._isWrapText = false);
      },
      _setOverflowBMFont: function() {
        if (this._labelType === _ccsg.Label.Type.BMFont) {
          this._overFlow === _ccsg.Label.Overflow.RESIZE_HEIGHT && this._setDimensions(this._labelDimensions.width, 0);
          this._overFlow === _ccsg.Label.Overflow.NONE && this._setDimensions(0, 0);
          this._rescaleWithOriginalFontSize();
        }
      },
      setOverflow: function(overflow) {
        if (this._overFlow === overflow) return;
        this._overFlow = overflow;
        this._updateWrapText(this._overFlow);
        this._setOverflowBMFont();
        this._notifyLabelSkinDirty();
      },
      getOverflow: function() {
        return this._overFlow;
      },
      setSpacingX: function(spacing) {
        if (this._spacingX === spacing) return;
        this._spacingX = spacing;
        this._notifyLabelSkinDirty();
      },
      setLineHeight: function(lineHeight) {
        if (this._lineHeight === lineHeight) return;
        this._lineHeight = lineHeight;
        this._notifyLabelSkinDirty();
      },
      setLineBreakWithoutSpace: function(lineBreakFlag) {
        if (this._lineBreakWithoutSpaces === lineBreakFlag) return;
        this._lineBreakWithoutSpaces = lineBreakFlag;
        this._notifyLabelSkinDirty();
      },
      getSpacingX: function() {
        return this._spacingX;
      },
      getLineHeight: function() {
        return this._lineHeight;
      },
      getBMFontLineHeight: function() {
        if (this._fontAtlas) return this._fontAtlas._lineHeight;
      },
      setFontFamily: function(fontFamily) {
        this._resetBMFont();
        this._fontHandle = fontFamily || "Arial";
        this._labelType = _ccsg.Label.Type.SystemFont;
        this._blendFunc = cc.BlendFunc._alphaPremultiplied();
        this._renderCmd._needDraw = true;
        this._notifyLabelSkinDirty();
        this.emit("load");
      },
      setFontAsset: function(fontAsset) {
        this._fontAsset = fontAsset;
        var isAsset = fontAsset instanceof cc.Font;
        if (!isAsset) {
          this.setFontFamily("");
          return;
        }
        var fontHandle = cc.loader.md5Pipe ? cc.loader.md5Pipe.transformURL(fontAsset.nativeUrl, true) : fontAsset.nativeUrl;
        var extName = cc.path.extname(fontHandle);
        this._resetBMFont();
        if (".ttf" === extName) {
          this._labelType = _ccsg.Label.Type.TTF;
          this._blendFunc = cc.BlendFunc._alphaPremultiplied();
          this._renderCmd._needDraw = true;
          this._fontHandle = this._loadTTFFont(fontHandle);
        } else if (fontAsset.spriteFrame) {
          this._labelType = _ccsg.Label.Type.BMFont;
          this._blendFunc = cc.BlendFunc._alphaNonPremultiplied();
          this._renderCmd._needDraw = false;
          this._initBMFontWithString(this._string, fontAsset);
        }
        this._notifyLabelSkinDirty();
      },
      _loadTTFFont: function(fontHandle) {
        var self = this;
        var callback = function() {
          self._notifyLabelSkinDirty();
          self.emit("load");
        };
        var fontFamilyName = "";
        true;
        fontFamilyName = wx.loadFont(fontHandle);
        if (!fontFamilyName) {
          fontFamilyName = cc.CustomFontLoader._getFontFamily(fontHandle);
          cc.warn("TTF font is not supported on debugger, but it will be displayed correctly on mobile device.");
        }
        callback();
        return fontFamilyName;
      },
      setContentSize: function(size, height) {
        if (this._overFlow === _ccsg.Label.Overflow.NONE) return;
        this._setDimensions(size, height);
      },
      setBlendFunc: function(src, dst) {
        var locBlendFunc = this._blendFunc;
        if (void 0 === dst) {
          locBlendFunc.src = src.src;
          locBlendFunc.dst = src.dst;
        } else {
          locBlendFunc.src = src;
          locBlendFunc.dst = dst;
        }
      },
      getBlendFunc: function() {
        return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst);
      },
      _setupBMFontOverflowMetrics: function(newWidth, newHeight) {
        this._overFlow === _ccsg.Label.Overflow.RESIZE_HEIGHT && (newHeight = 0);
        if (this._overFlow === _ccsg.Label.Overflow.NONE) {
          newWidth = 0;
          newHeight = 0;
        }
        this._labelWidth = newWidth;
        this._labelHeight = newHeight;
        this._labelDimensions.width = newWidth;
        this._labelDimensions.height = newHeight;
        this._maxLineWidth = newWidth;
      },
      _updateLabel: function() {
        if (this._labelType === _ccsg.Label.Type.BMFont) {
          var contentSize = this._contentSize;
          var newWidth = contentSize.width;
          var newHeight = contentSize.height;
          this._setupBMFontOverflowMetrics(newWidth, newHeight);
          this._updateContent();
          this.setColor(this.color);
        } else this._labelType !== _ccsg.Label.Type.TTF && this._labelType !== _ccsg.Label.Type.SystemFont || this._renderCmd._bakeLabel();
      },
      _notifyLabelSkinDirty: function() {
        false;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.textDirty | _ccsg.Node._dirtyFlags.contentDirty);
      },
      _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new _ccsg.Label.WebGLRenderCmd(this) : new _ccsg.Label.CanvasRenderCmd(this);
      },
      getContentSize: function() {
        var locFlag = this._renderCmd._dirtyFlag;
        if (locFlag & _ccsg.Node._dirtyFlags.textDirty) {
          this._updateLabel();
          this._renderCmd._dirtyFlag &= ~_ccsg.Node._dirtyFlags.textDirty;
        }
        return _ccsg.Node.prototype.getContentSize.call(this);
      },
      _getWidth: function() {
        var locFlag = this._renderCmd._dirtyFlag;
        if (locFlag & _ccsg.Node._dirtyFlags.textDirty) {
          this._updateLabel();
          this._renderCmd._dirtyFlag &= ~_ccsg.Node._dirtyFlags.textDirty;
        }
        return _ccsg.Node.prototype._getWidth.call(this);
      },
      _getHeight: function() {
        var locFlag = this._renderCmd._dirtyFlag;
        if (locFlag & _ccsg.Node._dirtyFlags.textDirty) {
          this._updateLabel();
          this._renderCmd._dirtyFlag &= ~_ccsg.Node._dirtyFlags.textDirty;
        }
        return _ccsg.Node.prototype._getHeight.call(this);
      },
      _alignText: function() {
        var ret = true;
        do {
          if (!this._spriteBatchNode) return true;
          this._textDesiredHeight = 0;
          this._linesWidth = [];
          this._lineBreakWithoutSpaces ? this._multilineTextWrapByChar() : this._multilineTextWrapByWord();
          this._computeAlignmentOffset();
          if (this._overFlow === _ccsg.Label.Overflow.SHRINK) {
            var fontSize = this.getFontSize();
            fontSize > 0 && this._isVerticalClamp() && this._shrinkLabelToContentSize(this._isVerticalClamp.bind(this));
          }
          if (!this._updateQuads()) {
            ret = false;
            this._overFlow === _ccsg.Label.Overflow.SHRINK && this._shrinkLabelToContentSize(this._isHorizontalClamp.bind(this));
            break;
          }
        } while (0);
        return ret;
      },
      _isHorizontalClamped: function(px, lineIndex) {
        var wordWidth = this._linesWidth[lineIndex];
        var letterOverClamp = px > this._contentSize.width || px < 0;
        return this._isWrapText ? wordWidth > this._contentSize.width && letterOverClamp : letterOverClamp;
      },
      _updateQuads: function() {
        var ret = true;
        this._spriteBatchNode.removeAllChildren();
        for (var ctr = 0; ctr < this._string.length; ++ctr) if (this._lettersInfo[ctr]._valid) {
          var letterDef = this._fontAtlas._letterDefinitions[this._lettersInfo[ctr]._char];
          this._reusedRect.height = letterDef._height;
          this._reusedRect.width = letterDef._width;
          this._reusedRect.x = letterDef._u;
          this._reusedRect.y = letterDef._v;
          var py = this._lettersInfo[ctr]._positionY + this._letterOffsetY;
          if (this._labelHeight > 0) {
            if (py > this._tailoredTopY) {
              var clipTop = py - this._tailoredTopY;
              this._reusedRect.y += clipTop;
              this._reusedRect.height -= clipTop;
              py -= clipTop;
            }
            py - letterDef._height * this._bmfontScale < this._tailoredBottomY && (this._reusedRect.height = py < this._tailoredBottomY ? 0 : py - this._tailoredBottomY);
          }
          var lineIndex = this._lettersInfo[ctr]._lineIndex;
          var px = this._lettersInfo[ctr]._positionX + letterDef._width / 2 * this._bmfontScale + this._linesOffsetX[lineIndex];
          if (this._labelWidth > 0 && this._isHorizontalClamped(px, lineIndex)) if (this._overFlow === _ccsg.Label.Overflow.CLAMP) this._reusedRect.width = 0; else if (this._overFlow === _ccsg.Label.Overflow.SHRINK) {
            if (this._contentSize.width > letterDef._width) {
              ret = false;
              break;
            }
            this._reusedRect.width = 0;
          }
          if (this._reusedRect.height > 0 && this._reusedRect.width > 0) {
            var fontChar = this.getChildByTag(ctr);
            var locTexture = this._spriteBatchNode._texture;
            var spriteFrame = this._spriteFrame;
            var isRotated = this._spriteFrame.isRotated();
            var originalSize = spriteFrame._originalSize;
            var rect = spriteFrame._rect;
            var offset = spriteFrame._offset;
            var trimmedLeft = offset.x + (originalSize.width - rect.width) / 2;
            var trimmedTop = offset.y - (originalSize.height - rect.height) / 2;
            if (isRotated) {
              var originalX = this._reusedRect.x;
              this._reusedRect.x = rect.x + rect.height - this._reusedRect.y - this._reusedRect.height - trimmedTop;
              this._reusedRect.y = originalX + rect.y - trimmedLeft;
              this._reusedRect.y < 0 && (this._reusedRect.height = this._reusedRect.height + trimmedTop);
            } else {
              this._reusedRect.x += rect.x - trimmedLeft;
              this._reusedRect.y += rect.y + trimmedTop;
            }
            if (fontChar) fontChar.setTextureRect(this._reusedRect, isRotated); else {
              fontChar = new _ccsg.Sprite();
              fontChar.initWithTexture(locTexture, this._reusedRect, isRotated);
              fontChar.setAnchorPoint(cc.p(0, 1));
            }
            var letterPositionX = this._lettersInfo[ctr]._positionX + this._linesOffsetX[this._lettersInfo[ctr]._lineIndex];
            fontChar.setPosition(letterPositionX, py);
            this._updateLetterSpriteScale(fontChar);
            this._spriteBatchNode.addChild(fontChar);
          }
        }
        return ret;
      },
      _updateLetterSpriteScale: function(sprite) {
        this._labelType === _ccsg.Label.Type.BMFont && this._fontSize > 0 && sprite.setScale(this._bmfontScale);
      },
      _recordPlaceholderInfo: function(letterIndex, char) {
        if (letterIndex >= this._lettersInfo.length) {
          var tmpInfo = new LetterInfo();
          this._lettersInfo.push(tmpInfo);
        }
        this._lettersInfo[letterIndex]._char = char;
        this._lettersInfo[letterIndex]._valid = false;
      },
      _recordLetterInfo: function(letterPosition, character, letterIndex, lineIndex) {
        if (letterIndex >= this._lettersInfo.length) {
          var tmpInfo = new LetterInfo();
          this._lettersInfo.push(tmpInfo);
        }
        character = character.charCodeAt(0);
        this._lettersInfo[letterIndex]._lineIndex = lineIndex;
        this._lettersInfo[letterIndex]._char = character;
        this._lettersInfo[letterIndex]._valid = this._fontAtlas._letterDefinitions[character]._validDefinition;
        this._lettersInfo[letterIndex]._positionX = letterPosition.x;
        this._lettersInfo[letterIndex]._positionY = letterPosition.y;
      },
      _setDimensions: function(size, height) {
        var newWidth = "number" === typeof size.width ? size.width : size;
        var newHeight = "number" === typeof size.height ? size.height : height;
        var oldSize = this.getContentSize();
        _ccsg.Node.prototype.setContentSize.call(this, size, height);
        if (newHeight !== oldSize.height || newWidth !== oldSize.width) {
          this._setupBMFontOverflowMetrics(newWidth, newHeight);
          this._drawFontsize > 0 && this._restoreFontSize();
          this._notifyLabelSkinDirty();
        }
      },
      _restoreFontSize: function() {
        this._fontSize = this._drawFontsize;
      },
      _multilineTextWrap: function(nextTokenFunc) {
        var textLen = this.getStringLength();
        var lineIndex = 0;
        var nextTokenX = 0;
        var nextTokenY = 0;
        var longestLine = 0;
        var letterRight = 0;
        var lineSpacing = this._lineSpacing;
        var highestY = 0;
        var lowestY = 0;
        var letterDef = null;
        var letterPosition = cc.p(0, 0);
        this._updateBMFontScale();
        for (var index = 0; index < textLen; ) {
          var character = this._string.charAt(index);
          if ("\n" === character) {
            this._linesWidth.push(letterRight);
            letterRight = 0;
            lineIndex++;
            nextTokenX = 0;
            nextTokenY -= this._lineHeight * this._bmfontScale + lineSpacing;
            this._recordPlaceholderInfo(index, character);
            index++;
            continue;
          }
          var tokenLen = nextTokenFunc(this._string, index, textLen);
          var tokenHighestY = highestY;
          var tokenLowestY = lowestY;
          var tokenRight = letterRight;
          var nextLetterX = nextTokenX;
          var newLine = false;
          for (var tmp = 0; tmp < tokenLen; ++tmp) {
            var letterIndex = index + tmp;
            character = this._string.charAt(letterIndex);
            if ("\r" === character) {
              this._recordPlaceholderInfo(letterIndex, character);
              continue;
            }
            letterDef = this._fontAtlas.getLetterDefinitionForChar(character);
            if (!letterDef) {
              this._recordPlaceholderInfo(letterIndex, character);
              console.log("Can't find letter definition in texture atlas " + this._config.atlasName + " for letter:" + character);
              continue;
            }
            var letterX = nextLetterX + letterDef._offsetX * this._bmfontScale;
            if (this._isWrapText && this._maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef._width * this._bmfontScale > this._maxLineWidth && !cc.TextUtils.isUnicodeSpace(character)) {
              this._linesWidth.push(letterRight);
              letterRight = 0;
              lineIndex++;
              nextTokenX = 0;
              nextTokenY -= this._lineHeight * this._bmfontScale + lineSpacing;
              newLine = true;
              break;
            }
            letterPosition.x = letterX;
            letterPosition.y = nextTokenY - letterDef._offsetY * this._bmfontScale;
            this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex);
            letterIndex + 1 < this._horizontalKernings.length && letterIndex < textLen - 1 && (nextLetterX += this._horizontalKernings[letterIndex + 1]);
            nextLetterX += letterDef._xAdvance * this._bmfontScale + this._spacingX;
            tokenRight = letterPosition.x + letterDef._width * this._bmfontScale;
            tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y);
            tokenLowestY > letterPosition.y - letterDef._height * this._bmfontScale && (tokenLowestY = letterPosition.y - letterDef._height * this._bmfontScale);
          }
          if (newLine) continue;
          nextTokenX = nextLetterX;
          letterRight = tokenRight;
          highestY < tokenHighestY && (highestY = tokenHighestY);
          lowestY > tokenLowestY && (lowestY = tokenLowestY);
          longestLine < letterRight && (longestLine = letterRight);
          index += tokenLen;
        }
        this._linesWidth.push(letterRight);
        this._numberOfLines = lineIndex + 1;
        this._textDesiredHeight = this._numberOfLines * this._lineHeight * this._bmfontScale;
        this._numberOfLines > 1 && (this._textDesiredHeight += (this._numberOfLines - 1) * this._lineSpacing);
        var contentSize = cc.size(this._labelWidth, this._labelHeight);
        this._labelWidth <= 0 && (contentSize.width = parseFloat(longestLine.toFixed(2)));
        this._labelHeight <= 0 && (contentSize.height = parseFloat(this._textDesiredHeight.toFixed(2)));
        _ccsg.Node.prototype.setContentSize.call(this, contentSize);
        this._tailoredTopY = contentSize.height;
        this._tailoredBottomY = 0;
        highestY > 0 && (this._tailoredTopY = contentSize.height + highestY);
        lowestY < -this._textDesiredHeight && (this._tailoredBottomY = this._textDesiredHeight + lowestY);
        return true;
      },
      _multilineTextWrapByWord: function() {
        return this._multilineTextWrap(this._getFirstWordLen.bind(this));
      },
      _multilineTextWrapByChar: function() {
        return this._multilineTextWrap(this._getFirstCharLen.bind(this));
      },
      _isVerticalClamp: function() {
        return this._textDesiredHeight > this._contentSize.height;
      },
      _isHorizontalClamp: function() {
        var letterClamp = false;
        for (var ctr = 0; ctr < this.getStringLength(); ++ctr) if (this._lettersInfo[ctr]._valid) {
          var letterDef = this._fontAtlas._letterDefinitions[this._lettersInfo[ctr]._char];
          var px = this._lettersInfo[ctr]._positionX + letterDef._width / 2 * this._bmfontScale;
          var lineIndex = this._lettersInfo[ctr]._lineIndex;
          if (this._labelWidth > 0) if (this._isWrapText) {
            var wordWidth = this._linesWidth[lineIndex];
            if (wordWidth > this._contentSize.width && (px > this._contentSize.width || px < 0)) {
              letterClamp = true;
              break;
            }
          } else if (px > this._contentSize.width) {
            letterClamp = true;
            break;
          }
        }
        return letterClamp;
      },
      _shrinkLabelToContentSize: function(lambda) {
        var fontSize = this.getFontSize();
        var i = 0;
        var tempLetterDefinition = this._fontAtlas.cloneLetterDefinition();
        var originalLineHeight = this._lineHeight;
        var flag = true;
        while (lambda()) {
          ++i;
          var newFontSize = fontSize - i;
          flag = false;
          if (newFontSize <= 0) break;
          var scale = newFontSize / fontSize;
          this._fontAtlas.assignLetterDefinitions(tempLetterDefinition);
          this._fontAtlas.scaleFontLetterDefinition(scale);
          this._lineHeight = originalLineHeight * scale;
          this._lineBreakWithoutSpaces ? this._multilineTextWrapByChar() : this._multilineTextWrapByWord();
          this._computeAlignmentOffset();
        }
        this._lineHeight = originalLineHeight;
        this._fontAtlas.assignLetterDefinitions(tempLetterDefinition);
        flag || fontSize - i >= 0 && this._scaleFontSizeDown(fontSize - i);
      },
      _scaleFontSizeDown: function(fontSize) {
        var shouldUpdateContent = true;
        if (this._labelType === _ccsg.Label.Type.BMFont) {
          if (!fontSize) {
            fontSize = .1;
            shouldUpdateContent = false;
          }
          this._fontSize = fontSize;
          shouldUpdateContent && this._updateContent();
        }
      },
      _updateContent: function() {
        if (this._fontAtlas) {
          this._computeHorizontalKerningForText(this._string);
          this._alignText();
        }
      },
      _computeAlignmentOffset: function() {
        this._linesOffsetX = [];
        switch (this._hAlign) {
         case cc.TextAlignment.LEFT:
          for (var i = 0; i < this._numberOfLines; ++i) this._linesOffsetX.push(0);
          break;

         case cc.TextAlignment.CENTER:
          this._linesWidth.forEach(function(lineWidth) {
            this._linesOffsetX.push((this._contentSize.width - lineWidth) / 2);
          }.bind(this));
          break;

         case cc.TextAlignment.RIGHT:
          this._linesWidth.forEach(function(lineWidth) {
            this._linesOffsetX.push(this._contentSize.width - lineWidth);
          }.bind(this));
        }
        switch (this._vAlign) {
         case cc.VerticalTextAlignment.TOP:
          this._letterOffsetY = this._contentSize.height;
          break;

         case cc.VerticalTextAlignment.CENTER:
          this._letterOffsetY = (this._contentSize.height + this._textDesiredHeight) / 2;
          break;

         case cc.VerticalTextAlignment.BOTTOM:
          this._letterOffsetY = this._textDesiredHeight;
        }
      },
      _getFirstCharLen: function() {
        return 1;
      },
      _getFirstWordLen: function(text, startIndex, textLen) {
        var character = text.charAt(startIndex);
        if (cc.TextUtils.isUnicodeCJK(character) || "\n" === character || cc.TextUtils.isUnicodeSpace(character)) return 1;
        var len = 1;
        letterDef = this._fontAtlas.getLetterDefinitionForChar(character);
        if (!letterDef) return len;
        var nextLetterX = letterDef._xAdvance * this._bmfontScale + this._spacingX;
        var letterDef;
        var letterX;
        for (var index = startIndex + 1; index < textLen; ++index) {
          character = text.charAt(index);
          letterDef = this._fontAtlas.getLetterDefinitionForChar(character);
          if (!letterDef) break;
          letterX = nextLetterX + letterDef._offsetX * this._bmfontScale;
          if (letterX + letterDef._width * this._bmfontScale > this._maxLineWidth && !cc.TextUtils.isUnicodeSpace(character) && this._maxLineWidth > 0) return len;
          nextLetterX += letterDef._xAdvance * this._bmfontScale + this._spacingX;
          if ("\n" === character || cc.TextUtils.isUnicodeSpace(character) || cc.TextUtils.isUnicodeCJK(character)) break;
          len++;
        }
        return len;
      },
      _updateBMFontScale: function() {
        if (this._labelType === _ccsg.Label.Type.BMFont) {
          var originalFontSize = this._fontAtlas._fontSize;
          this._bmfontScale = this._fontSize / originalFontSize;
        } else this._bmfontScale = 1;
      },
      _initBMFontWithString: function(str, fontAsset) {
        var self = this;
        if (self._config) {
          cc.logID(4002);
          return false;
        }
        this._string = str;
        this._setBMFontFile(fontAsset);
      },
      _createSpriteBatchNode: function(texture) {
        this._spriteBatchNode = new cc.SpriteBatchNode(texture, this._string.length);
        this._spriteBatchNode.setCascadeColorEnabled(true);
        this._spriteBatchNode.setCascadeOpacityEnabled(true);
        this.addChild(this._spriteBatchNode);
        this._updateContent();
        this.setColor(this.color);
      },
      _createFontChars: function() {
        if (!this._config) return;
        this._fontAtlas = new cc.FontAtlas(this._config);
        this._lineHeight || (this._lineHeight = this._fontAtlas._lineHeight);
        var locCfg = this._config;
        var locFontDict = locCfg.fontDefDictionary;
        for (var fontDef in locFontDict) {
          var letterDefinition = new FontLetterDefinition();
          var tempRect = locFontDict[fontDef].rect;
          letterDefinition._offsetX = parseInt(locFontDict[fontDef].xOffset);
          letterDefinition._offsetY = parseInt(locFontDict[fontDef].yOffset);
          letterDefinition._width = parseInt(tempRect.width);
          letterDefinition._height = parseInt(tempRect.height);
          letterDefinition._u = parseInt(tempRect.x) + this._imageOffset.x;
          letterDefinition._v = parseInt(tempRect.y) + this._imageOffset.y;
          letterDefinition._textureID = 0;
          letterDefinition._validDefinition = true;
          letterDefinition._xAdvance = parseInt(locFontDict[fontDef].xAdvance);
          this._fontAtlas.addLetterDefinitions(fontDef, letterDefinition);
        }
      },
      _rescaleWithOriginalFontSize: function() {
        var renderingFontSize = this.getFontSize();
        this._drawFontsize - renderingFontSize >= 1 && this._overFlow === _ccsg.Label.Overflow.SHRINK && (this._labelType === _ccsg.Label.Type.BMFont ? this._scaleFontSizeDown(this._drawFontsize) : this._fontSize = this._drawFontsize);
      },
      _computeHorizontalKerningForText: function() {
        var stringLen = this.getStringLength();
        var locKerningDict = this._config.kerningDict;
        var prev = -1;
        for (var i = 0; i < stringLen; ++i) {
          var key = this._string.charCodeAt(i);
          var kerningAmount = locKerningDict[prev << 16 | 65535 & key] || 0;
          this._horizontalKernings[i] = i < stringLen - 1 ? kerningAmount : 0;
          prev = key;
        }
      },
      _setBMFontFile: function(fontAsset) {
        if (fontAsset && this._labelType === _ccsg.Label.Type.BMFont) {
          var self = this;
          this._resetBMFont();
          var fntConfig = this._fontAsset._fntConfig;
          fntConfig ? self._config = fntConfig : cc.warn("Invalid BMFont Assets!");
          var spriteFrame = fontAsset.spriteFrame;
          self._createFontChars();
          self._spriteFrame = spriteFrame;
          var createLabelSprites = function() {
            var texture = spriteFrame.getTexture();
            self._textureLoaded = texture.loaded;
            self._createSpriteBatchNode(texture);
            self.emit("load");
          };
          if (spriteFrame.textureLoaded()) createLabelSprites(); else {
            spriteFrame.once("load", createLabelSprites);
            spriteFrame.ensureLoadTexture();
          }
        }
      }
    });
    _ccsg.Label.pool = new JS.Pool(function(label) {
      if (false, !(label instanceof _ccsg.Label)) return false;
      label._string = "";
      label._fontAsset = null;
      label._fontHandle = "";
      label._labelType = 0;
      label._resetBMFont();
      false;
      return true;
    }, 10);
    _ccsg.Label.pool.get = function(string, fontAsset) {
      var label = this._get();
      if (label) {
        var isAsset = fontAsset instanceof cc.Font;
        var fontHandle = isAsset ? fontAsset.nativeUrl : "";
        label._fontHandle = fontHandle;
        "string" !== typeof string && (string = "" + string);
        label._string = string;
        label._position.x = 0;
        label._position.y = 0;
        label.setAnchorPoint(.5, .5);
        _ccsg.Node.prototype.setContentSize.call(label, 10, 10);
        isAsset ? label.setFontAsset(fontAsset) : label.setFontFamily("Arial");
        label.setString(string);
        label.setHorizontalAlign(cc.TextAlignment.LEFT);
        label.setVerticalAlign(cc.VerticalTextAlignment.TOP);
        label.setFontSize(40);
        label.setOverflow(0);
        label.enableWrapText(true);
        label.setVisible(true);
        label.setLineHeight(40);
        label.setOutlined(false);
        label.enableBold(false);
        label.enableItalics(false);
        label.enableUnderline(false);
        return label;
      }
      return new _ccsg.Label(string || "", fontAsset);
    };
    var _p = _ccsg.Label.prototype;
    cc.js.addon(_p, EventTarget.prototype);
    _ccsg.Label.Type = cc.Enum({
      TTF: 0,
      BMFont: 1,
      SystemFont: 2
    });
    _ccsg.Label.Overflow = cc.Enum({
      NONE: 0,
      CLAMP: 1,
      SHRINK: 2,
      RESIZE_HEIGHT: 3
    });
    var labelPro = _ccsg.Label.prototype;
    Object.defineProperty(labelPro, "width", {
      get: labelPro._getWidth,
      set: _ccsg.Node.prototype._setWidth
    });
    Object.defineProperty(labelPro, "height", {
      get: labelPro._getHeight,
      set: _ccsg.Node.prototype._setHeight
    });
  }), {
    "../event/event-target": 60,
    "../platform/js": 109,
    "./CCTextUtils": 68
  } ],
  66: [ (function(require, module, exports) {
    (function() {
      _ccsg.Label.TTFLabelBaker = function() {};
      var proto = _ccsg.Label.TTFLabelBaker.prototype = Object.create(Object.prototype);
      proto.updateStatus = function() {
        var flags = _ccsg.Node._dirtyFlags, locFlag = this._dirtyFlag;
        var colorDirty = locFlag & flags.colorDirty, opacityDirty = locFlag & flags.opacityDirty;
        colorDirty && this._updateDisplayColor();
        if (opacityDirty) {
          this._updateDisplayOpacity();
          this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
        }
        if (locFlag & flags.contentDirty) {
          this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
          this._dirtyFlag &= ~flags.contentDirty;
        }
        if (colorDirty || locFlag & flags.textDirty) {
          this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
          this._rebuildLabelSkin();
        }
        if (this._dirtyFlag & flags.transformDirty) {
          this.transform(this.getParentRenderCmd(), true);
          this._dirtyFlag &= ~flags.transformDirty;
        }
      };
      proto._syncStatus = function(parentCmd) {
        var flags = _ccsg.Node._dirtyFlags, locFlag = this._dirtyFlag;
        var parentNode = parentCmd ? parentCmd._node : null;
        parentNode && parentNode._cascadeColorEnabled && parentCmd._dirtyFlag & flags.colorDirty && (locFlag |= flags.colorDirty);
        parentNode && parentNode._cascadeOpacityEnabled && parentCmd._dirtyFlag & flags.opacityDirty && (locFlag |= flags.opacityDirty);
        parentCmd && parentCmd._dirtyFlag & flags.transformDirty && (locFlag |= flags.transformDirty);
        var colorDirty = locFlag & flags.colorDirty, opacityDirty = locFlag & flags.opacityDirty;
        this._dirtyFlag = locFlag;
        colorDirty && this._syncDisplayColor();
        opacityDirty && this._syncDisplayOpacity();
        (colorDirty || opacityDirty || this._dirtyFlag & flags.textDirty) && this._rebuildLabelSkin();
        this._dirtyFlag & flags.transformDirty && this.transform(parentCmd);
      };
      proto._getLineHeight = function() {
        var nodeSpacingY = this._node.getLineHeight();
        var node = this._node;
        nodeSpacingY = 0 === nodeSpacingY ? node._fontSize : nodeSpacingY * node._fontSize / this._drawFontsize;
        var lineHeight = 0 | nodeSpacingY;
        return lineHeight;
      };
      proto._constructFontDesc = function() {
        var node = this._node;
        var fontDesc = node._fontSize.toString() + "px ";
        var fontFamily = 0 === node._fontHandle.length ? "serif" : node._fontHandle;
        fontDesc += fontFamily;
        node._isBold && (fontDesc = "bold " + fontDesc);
        return fontDesc;
      };
      proto._safeMeasureText = function(ctx, string) {
        var metric = ctx.measureText(string);
        return metric && metric.width || 0;
      };
      proto._measureText = function(ctx) {
        return function(string) {
          return ctx.measureText(string).width;
        };
      };
      proto._calculateLabelFont = function() {
        var node = this._node;
        var paragraphedStrings = node._string.split("\n");
        node._fontSize = node._drawFontsize;
        var fontDesc = this._constructFontDesc();
        this._labelContext.font = fontDesc;
        var paragraphLength = this._calculateParagraphLength(paragraphedStrings, this._labelContext);
        if (_ccsg.Label.Overflow.SHRINK === node._overFlow) {
          this._splitedStrings = paragraphedStrings;
          var i = 0;
          var totalHeight = 0;
          var maxLength = 0;
          if (node._isWrapText) {
            var canvasWidthNoMargin = this._canvasSize.width - 2 * this._getMargin();
            var canvasHeightNoMargin = this._canvasSize.height - 2 * this._getMargin();
            if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) {
              fontDesc = this._constructFontDesc();
              this._labelContext.font = fontDesc;
              return fontDesc;
            }
            totalHeight = canvasHeightNoMargin + 1;
            maxLength = canvasWidthNoMargin + 1;
            var actualFontSize = this._drawFontsize + 1;
            var textFragment = "";
            var tryDivideByTwo = true;
            var startShrinkFontSize = 0 | actualFontSize;
            while (totalHeight > canvasHeightNoMargin || maxLength > canvasWidthNoMargin) {
              if (tryDivideByTwo) actualFontSize = startShrinkFontSize / 2 | 0; else {
                actualFontSize = startShrinkFontSize - 1;
                startShrinkFontSize = actualFontSize;
              }
              if (actualFontSize <= 0) {
                cc.logID(4003);
                break;
              }
              node._fontSize = actualFontSize;
              fontDesc = this._constructFontDesc();
              this._labelContext.font = fontDesc;
              this._splitedStrings = [];
              totalHeight = 0;
              for (i = 0; i < paragraphedStrings.length; ++i) {
                var j = 0;
                var allWidth = this._safeMeasureText(this._labelContext, paragraphedStrings[i]);
                textFragment = cc.TextUtils.fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(this._labelContext));
                while (j < textFragment.length) {
                  var measureWidth = this._safeMeasureText(this._labelContext, textFragment[j]);
                  maxLength = measureWidth;
                  totalHeight += this._getLineHeight();
                  ++j;
                }
                this._splitedStrings = this._splitedStrings.concat(textFragment);
              }
              if (tryDivideByTwo) if (totalHeight > canvasHeightNoMargin) startShrinkFontSize = 0 | actualFontSize; else {
                tryDivideByTwo = false;
                totalHeight = canvasHeightNoMargin + 1;
              }
            }
          } else {
            totalHeight = paragraphedStrings.length * this._getLineHeight();
            for (i = 0; i < paragraphedStrings.length; ++i) maxLength < paragraphLength[i] && (maxLength = paragraphLength[i]);
            var scaleX = (this._canvasSize.width - 2 * this._getMargin()) / maxLength;
            var scaleY = this._canvasSize.height / totalHeight;
            node._fontSize = this._drawFontsize * Math.min(1, scaleX, scaleY) | 0;
            fontDesc = this._constructFontDesc();
            this._labelContext.font = fontDesc;
          }
        }
        return fontDesc;
      };
      proto._getMargin = function() {
        return this._node && this._node._margin || 0;
      };
      proto._calculateParagraphLength = function(paragraphedStrings, ctx) {
        var paragraphLength = [];
        for (var i = 0; i < paragraphedStrings.length; ++i) paragraphLength.push(this._safeMeasureText(ctx, paragraphedStrings[i]));
        return paragraphLength;
      };
      proto._calculateCanvasSize = function() {
        var node = this._node;
        var canvasWidth = node._contentSize.width;
        var canvasHeight = node._contentSize.height;
        canvasWidth <= 0 && (canvasWidth = 1);
        canvasHeight <= 0 && (canvasHeight = 1);
        return cc.size(canvasWidth, canvasHeight);
      };
      proto._calculateSplitedStrings = function() {
        var node = this._node;
        var paragraphedStrings = node._string.split("\n");
        var i;
        if (node._isWrapText) {
          this._splitedStrings = [];
          var canvasWidthNoMargin = this._canvasSize.width - 2 * this._getMargin();
          for (i = 0; i < paragraphedStrings.length; ++i) {
            var allWidth = this._safeMeasureText(this._labelContext, paragraphedStrings[i]);
            var textFragment = cc.TextUtils.fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(this._labelContext));
            this._splitedStrings = this._splitedStrings.concat(textFragment);
          }
        } else this._splitedStrings = paragraphedStrings;
      };
      proto._updateLabelDimensions = function() {
        var node = this._node;
        var paragraphedStrings = node._string.split("\n");
        var i;
        var ctx = this._labelContext;
        if (_ccsg.Label.Overflow.RESIZE_HEIGHT === node._overFlow) {
          this._canvasSize.height = this._splitedStrings.length * this._getLineHeight();
          _ccsg.Node.prototype.setContentSize.call(node, this._canvasSize);
        } else if (_ccsg.Label.Overflow.NONE === node._overFlow) {
          this._splitedStrings = paragraphedStrings;
          var canvasSizeX = 0;
          var canvasSizeY = 0;
          for (i = 0; i < paragraphedStrings.length; ++i) {
            var paraLength = this._safeMeasureText(ctx, paragraphedStrings[i]);
            canvasSizeX = canvasSizeX > paraLength ? canvasSizeX : paraLength;
          }
          canvasSizeY = this._splitedStrings.length * this._getLineHeight();
          this._canvasSize.width = Math.round(canvasSizeX.toFixed(2)) + 2 * this._getMargin();
          this._canvasSize.height = Math.round(canvasSizeY.toFixed(2));
          node._isItalic && (this._canvasSize.width += node._drawFontsize * Math.tan(.20943951));
          _ccsg.Node.prototype.setContentSize.call(node, this._canvasSize);
        }
        this._labelCanvas.width = this._canvasSize.width;
        this._labelCanvas.height = this._canvasSize.height;
      };
      proto._calculateFillTextStartPosition = function() {
        var node = this._node;
        var lineHeight = this._getLineHeight();
        var lineCount = this._splitedStrings.length;
        var labelX;
        var firstLinelabelY;
        labelX = cc.TextAlignment.RIGHT === node._hAlign ? this._canvasSize.width - this._getMargin() : cc.TextAlignment.CENTER === node._hAlign ? this._canvasSize.width / 2 : 0 + this._getMargin();
        firstLinelabelY = cc.VerticalTextAlignment.TOP === node._vAlign ? 0 : cc.VerticalTextAlignment.CENTER === node._vAlign ? this._canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 : this._canvasSize.height - lineHeight * (lineCount - 1);
        return cc.p(labelX, firstLinelabelY);
      };
      proto._calculateTextBaseline = function() {
        var node = this._node;
        var hAlign;
        var vAlign;
        hAlign = cc.TextAlignment.RIGHT === node._hAlign ? "right" : cc.TextAlignment.CENTER === node._hAlign ? "center" : "left";
        this._labelContext.textAlign = hAlign;
        vAlign = cc.VerticalTextAlignment.TOP === node._vAlign ? "top" : cc.VerticalTextAlignment.CENTER === node._vAlign ? "middle" : "bottom";
        this._labelContext.textBaseline = vAlign;
      };
      proto._bakeLabel = function() {
        var node = this._node;
        this._drawFontsize = node._drawFontsize;
        this._canvasSize = this._calculateCanvasSize();
        this._fontDesc = this._calculateLabelFont();
        this._calculateSplitedStrings();
        this._updateLabelDimensions();
        this._calculateTextBaseline();
        this._updateTexture();
      };
      proto._calculateUnderlineStartPosition = function() {
        var node = this._node;
        var lineHeight = this._getLineHeight();
        var lineCount = this._splitedStrings.length;
        var labelX;
        var firstLinelabelY;
        labelX = 0 + this._getMargin();
        firstLinelabelY = cc.VerticalTextAlignment.TOP === node._vAlign ? node._fontSize : cc.VerticalTextAlignment.CENTER === node._vAlign ? this._canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 + node._fontSize / 2 : this._canvasSize.height - lineHeight * (lineCount - 1);
        return cc.p(labelX, firstLinelabelY);
      };
      proto._updateTexture = function() {
        this._labelContext.clearRect(0, 0, this._canvasSize.width, this._canvasSize.height);
        this._labelContext.font = this._fontDesc;
        var startPosition = this._calculateFillTextStartPosition();
        var lineHeight = this._getLineHeight();
        this._labelContext.lineJoin = "round";
        var color = this._displayedColor;
        this._labelContext.fillStyle = "rgb(" + color.r + "," + color.g + "," + color.b + ")";
        var underlineStartPosition;
        for (var i = 0; i < this._splitedStrings.length; ++i) {
          if (this._node.isOutlined()) {
            var strokeColor = this._node.getOutlineColor() || cc.color(255, 255, 255, 255);
            this._labelContext.globalCompositeOperation = "source-over";
            this._labelContext.strokeStyle = "rgb(" + strokeColor.r + "," + strokeColor.g + "," + strokeColor.b + ")";
            this._labelContext.lineWidth = 2 * this._node.getOutlineWidth();
            this._labelContext.strokeText(this._splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight);
          }
          if (this._node.getFillColorGradientEnabled()) {
            var gradientStartColor = this._node.getGradientStartColor() || cc.color(255, 255, 255, 255);
            var gradientEndColor = this._node.getGradientEndColor() || cc.color(255, 255, 255, 255);
            var gradientArgument = this._getGradientArgs();
            var gradient = this._labelContext.createLinearGradient(gradientArgument.left, gradientArgument.top, gradientArgument.right, gradientArgument.bottom);
            gradient.addColorStop(0, cc.colorToHex(gradientStartColor));
            gradient.addColorStop(1, cc.colorToHex(gradientEndColor));
            this._labelContext.fillStyle = gradient;
          }
          this._labelContext.fillText(this._splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight);
          if (this._node._isUnderline) {
            underlineStartPosition = this._calculateUnderlineStartPosition();
            this._labelContext.save();
            this._labelContext.beginPath();
            this._labelContext.lineWidth = this._node._fontSize / 8;
            this._labelContext.strokeStyle = "rgb(" + color.r + "," + color.g + "," + color.b + ")";
            this._labelContext.moveTo(underlineStartPosition.x, underlineStartPosition.y + i * lineHeight - 1);
            this._labelContext.lineTo(underlineStartPosition.x + this._labelCanvas.width, underlineStartPosition.y + i * lineHeight - 1);
            this._labelContext.stroke();
            this._labelContext.restore();
          }
        }
        this._texture.loaded = false;
        this._texture._nativeAsset = this._labelCanvas;
      };
      proto._getGradientArgs = function() {
        this._gradientArgument = {};
        this._gradientArgument.left = 0;
        this._gradientArgument.top = 0;
        var contentSize = this._node._contentSize;
        switch (this._node.getFillColorGradientDirection()) {
         case 0:
          this._gradientArgument.right = contentSize.width;
          this._gradientArgument.bottom = 0;
          break;

         case 1:
          this._gradientArgument.right = 0;
          this._gradientArgument.bottom = contentSize.height;
          break;

         case 2:
          this._gradientArgument.right = contentSize.width;
          this._gradientArgument.bottom = contentSize.height;
        }
        return this._gradientArgument;
      };
      proto._rebuildLabelSkin = function() {
        this._dirtyFlag &= ~_ccsg.Node._dirtyFlags.textDirty;
        var node = this._node;
        node._updateLabel();
      };
    })();
    (function() {
      _ccsg.Label.CanvasRenderCmd = function(renderableObject) {
        this._rootCtor(renderableObject);
        this._needDraw = true;
        this._texture = new cc.Texture2D();
        this._labelCanvas = document.createElement("canvas");
        this._labelCanvas.width = 1;
        this._labelCanvas.height = 1;
        this._labelContext = this._labelCanvas.getContext("2d");
        this._texture.initWithElement(this._labelCanvas);
        this._splitedStrings = null;
      };
      var proto = _ccsg.Label.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
      cc.js.mixin(proto, _ccsg.Label.TTFLabelBaker.prototype);
      proto.constructor = _ccsg.Label.CanvasRenderCmd;
      proto._doCulling = function() {
        var rect = cc.visibleRect, bb = this._currentRegion, l = bb._minX, r = bb._maxX, b = bb._minY, t = bb._maxY, vl = rect.left.x, vr = rect.right.x, vt = rect.top.y, vb = rect.bottom.y;
        this._needDraw = !(r < vl || l > vr || t < vb || b > vt);
      };
      proto.rendering = function(ctx, scaleX, scaleY) {
        var node = this._node;
        if (node._labelType === _ccsg.Label.Type.TTF || node._labelType === _ccsg.Label.Type.SystemFont) {
          var locDisplayOpacity = this._displayedOpacity;
          var alpha = locDisplayOpacity / 255;
          if (0 === locDisplayOpacity) return;
          var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
          wrapper.setTransform(this._worldTransform, scaleX, scaleY);
          wrapper.setCompositeOperation(_ccsg.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(node._blendFunc));
          wrapper.setGlobalAlpha(alpha);
          if (this._texture) {
            var sx, sy, sw, sh;
            var x, y, w, h;
            x = 0;
            y = -this._node._contentSize.height;
            w = this._node._contentSize.width;
            h = this._node._contentSize.height;
            var textureWidth = this._texture.getPixelWidth();
            var textureHeight = this._texture.getPixelHeight();
            sx = 0;
            sy = 0;
            sw = textureWidth;
            sh = textureHeight;
            var image = this._texture._image;
            if ("" !== this._texture._pattern) {
              wrapper.setFillStyle(context.createPattern(image, this._texture._pattern));
              context.fillRect(x, y, w, h);
            } else 0 !== sw && 0 !== sh && 0 !== w && 0 !== h && context.drawImage(image, sx, sy, sw, sh, x, y, w, h);
          }
          cc.g_NumberOfDraws = cc.g_NumberOfDraws + 1;
        }
      };
    })();
  }), {} ],
  67: [ (function(require, module, exports) {
    var opts = {
      premultiplyAlpha: true
    };
    var _sharedLabelCanvas;
    _ccsg.Label.WebGLRenderCmd = function(renderableObject) {
      this._rootCtor(renderableObject);
      this._needDraw = true;
      this._texture = new cc.Texture2D();
      this._texture.update(opts);
      _sharedLabelCanvas = _sharedLabelCanvas || document.createElement("canvas");
      this._labelCanvas = _sharedLabelCanvas;
      this._texture.initWithElement(this._labelCanvas);
      this._labelContext = this._labelCanvas.getContext("2d");
      this._labelCanvas.width = 1;
      this._labelCanvas.height = 1;
      this._splitedStrings = null;
      this._drawFontsize = 0;
      this._vertices = [ {
        x: 0,
        y: 0,
        u: 0,
        v: 0
      }, {
        x: 0,
        y: 0,
        u: 0,
        v: 1
      }, {
        x: 0,
        y: 0,
        u: 1,
        v: 0
      }, {
        x: 0,
        y: 0,
        u: 1,
        v: 1
      } ];
      this._color = new Uint32Array(1);
      this._dirty = false;
      this._shaderProgram = cc.shaderCache.programForKey(cc.macro.SHADER_SPRITE_POSITION_TEXTURECOLOR);
    };
    var proto = _ccsg.Label.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
    cc.js.mixin(proto, _ccsg.Label.TTFLabelBaker.prototype);
    proto.constructor = _ccsg.Label.WebGLRenderCmd;
    proto.updateTransform = function(parentCmd) {
      this.originUpdateTransform(parentCmd);
      var node = this._node, lx = 0, rx = this._node.width, by = 0, ty = this._node.height, wt = this._worldTransform;
      var vert = this._vertices;
      vert[0].x = lx * wt.a + ty * wt.c + wt.tx;
      vert[0].y = lx * wt.b + ty * wt.d + wt.ty;
      vert[1].x = lx * wt.a + by * wt.c + wt.tx;
      vert[1].y = lx * wt.b + by * wt.d + wt.ty;
      vert[2].x = rx * wt.a + ty * wt.c + wt.tx;
      vert[2].y = rx * wt.b + ty * wt.d + wt.ty;
      vert[3].x = rx * wt.a + by * wt.c + wt.tx;
      vert[3].y = rx * wt.b + by * wt.d + wt.ty;
    };
    proto._doCulling = function() {
      var node = this._node;
      if (!node._string || node._labelType !== _ccsg.Label.Type.TTF && node._labelType !== _ccsg.Label.Type.SystemFont) return;
      var rect = cc.visibleRect;
      this._cameraFlag > 0 && (rect = cc.Camera.main.visibleRect);
      var vl = rect.left.x;
      var vr = rect.right.x;
      var vt = rect.top.y;
      var vb = rect.bottom.y;
      var vert = this._vertices;
      (vert[0].x - vl & vert[1].x - vl & vert[2].x - vl & vert[3].x - vl) >> 31 || (vr - vert[0].x & vr - vert[1].x & vr - vert[2].x & vr - vert[3].x) >> 31 || (vert[0].y - vb & vert[1].y - vb & vert[2].y - vb & vert[3].y - vb) >> 31 || (vt - vert[0].y & vt - vert[1].y & vt - vert[2].y & vt - vert[3].y) >> 31 ? this._needDraw = false : this._needDraw = true;
    };
    proto.uploadData = function(f32buffer, ui32buffer, vertexDataOffset) {
      var node = this._node;
      if (!node._string || node._labelType !== _ccsg.Label.Type.TTF && node._labelType !== _ccsg.Label.Type.SystemFont) return 0;
      var opacity = this._displayedOpacity;
      this._color[0] = ~~opacity << 24 >>> 0 | ~~opacity << 16 | ~~opacity << 8 | ~~opacity;
      var z = node._vertexZ;
      var vertices = this._vertices;
      var i, len = vertices.length, vertex, offset = vertexDataOffset;
      for (i = 0; i < len; ++i) {
        vertex = vertices[i];
        f32buffer[offset] = vertex.x;
        f32buffer[offset + 1] = vertex.y;
        f32buffer[offset + 2] = z;
        ui32buffer[offset + 3] = this._color[0];
        f32buffer[offset + 4] = vertex.u;
        f32buffer[offset + 5] = vertex.v;
        offset += 6;
      }
      return len;
    };
  }), {} ],
  68: [ (function(require, module, exports) {
    var CustomFontDescriptor = function() {
      this._status = "unloaded";
      this._observers = [];
      this._isLoadWithCSS = false;
    };
    CustomFontDescriptor.prototype.onLoaded = function() {
      this._status = "loaded";
      this._observers.forEach((function(item) {
        item();
      }));
    };
    CustomFontDescriptor.prototype.isLoaded = function() {
      return "loaded" === this._status;
    };
    CustomFontDescriptor.prototype.addHandler = function(callback) {
      -1 === this._observers.indexOf(callback) && this._observers.push(callback);
    };
    var CustomFontLoader = {
      _fontCache: {},
      _fontWidthCache: {},
      _canvasContext: null,
      _testString: "BESbswy",
      _allFontsLoaded: false,
      _intervalId: 0,
      loadTTF: function(url, callback) {
        var fontFamilyName = this._getFontFamily(url);
        var md5Pipe = cc.loader.md5Pipe;
        md5Pipe && (url = md5Pipe.transformURL(url, true));
        var useFontFace = cc.sys.browserType !== cc.sys.BROWSER_TYPE_BAIDU && cc.sys.browserType !== cc.sys.BROWSER_TYPE_BAIDU_APP && cc.sys.browserType !== cc.sys.BROWSER_TYPE_MOBILE_QQ;
        window.FontFace && useFontFace ? this._loadWithFontFace(fontFamilyName, url, callback) : this._loadWithCSS(fontFamilyName, url, callback);
        0 === this._intervalId && (this._intervalId = setInterval(this._checkFontLoaded.bind(this), 100));
      },
      _checkFontLoaded: function() {
        this._allFontsLoaded = true;
        for (var k in this._fontCache) {
          var fontDescriptor = this._fontCache[k];
          if (fontDescriptor.isLoaded() || !fontDescriptor._isLoadWithCSS) continue;
          var oldWidth = this._fontWidthCache[k];
          this._canvasContext.font = "40px " + k;
          var newWidth = this._canvasContext.measureText(this._testString).width;
          oldWidth !== newWidth ? fontDescriptor.onLoaded() : this._allFontsLoaded = false;
        }
        if (this._allFontsLoaded) {
          clearInterval(this._intervalId);
          this._intervalId = 0;
        }
      },
      _loadWithFontFace: function(fontFamilyName, url, callback) {
        var fontDescriptor = this._fontCache[fontFamilyName];
        if (fontDescriptor) fontDescriptor.isLoaded() || fontDescriptor.addHandler(callback); else {
          var fontFace = new FontFace(fontFamilyName, "url('" + url + "')");
          document.fonts.add(fontFace);
          fontDescriptor = new CustomFontDescriptor();
          fontDescriptor.addHandler(callback);
          this._fontCache[fontFamilyName] = fontDescriptor;
          fontFace.loaded.then((function() {
            fontDescriptor.onLoaded();
          }));
        }
      },
      _loadWithCSS: function(fontFamilyName, url, callback) {
        var fontDescriptor = this._fontCache[fontFamilyName];
        if (fontDescriptor) fontDescriptor.isLoaded() || fontDescriptor.addHandler(callback); else {
          var doc = document;
          var fontStyle = document.createElement("style");
          fontStyle.type = "text/css";
          doc.body.appendChild(fontStyle);
          var fontStr = "";
          isNaN(fontFamilyName - 0) ? fontStr += "@font-face { font-family:" + fontFamilyName + "; src:" : fontStr += "@font-face { font-family:'" + fontFamilyName + "'; src:";
          fontStr += "url('" + url + "');";
          fontStyle.textContent = fontStr + "}";
          var preloadDiv = document.createElement("div");
          var _divStyle = preloadDiv.style;
          _divStyle.fontFamily = fontFamilyName;
          preloadDiv.innerHTML = ".";
          _divStyle.position = "absolute";
          _divStyle.left = "-100px";
          _divStyle.top = "-100px";
          doc.body.appendChild(preloadDiv);
          fontDescriptor = new CustomFontDescriptor();
          fontDescriptor.addHandler(callback);
          this._fontCache[fontFamilyName] = fontDescriptor;
          fontDescriptor._isLoadWithCSS = true;
          if (!this._canvasContext) {
            var labelCanvas = document.createElement("canvas");
            labelCanvas.width = 100;
            labelCanvas.height = 100;
            this._canvasContext = labelCanvas.getContext("2d");
          }
          var fontDesc = "40px " + fontFamilyName;
          this._canvasContext.font = fontDesc;
          var width = this._canvasContext.measureText(this._testString).width;
          this._fontWidthCache[fontFamilyName] = width;
          var self = this;
          fontStyle.onload = function() {
            setTimeout((function() {
              if (!self._allFontsLoaded) {
                cc.logID(4004);
                fontDescriptor.onLoaded();
                cc.director.getScheduler().unschedule(this._checkFontLoaded, this);
              }
            }), 2e4);
          };
        }
      },
      _getFontFamily: function(fontHandle) {
        var ttfIndex = fontHandle.lastIndexOf(".ttf");
        if (-1 === ttfIndex) return fontHandle;
        var slashPos = fontHandle.lastIndexOf("/");
        var fontFamilyName;
        fontFamilyName = -1 === slashPos ? fontHandle.substring(0, ttfIndex) + "_LABEL" : fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
        return fontFamilyName;
      }
    };
    var TextUtils = {
      label_wordRex: /([a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430-\u044f\u0410-\u042f\u0401\u0451]+|\S)/,
      label_symbolRex: /^[!,.:;'}\]%\?>\u3001\u2018\u201c\u300b\uff1f\u3002\uff0c\uff01]/,
      label_lastWordRex: /([a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430\xed\xec\xcd\xcc\xef\xc1\xc0\xe1\xe0\xc9\xc8\xd2\xd3\xf2\xf3\u0150\u0151\xd9\xda\u0170\xfa\u0171\xf1\xd1\xe6\xc6\u0153\u0152\xc3\xc2\xe3\xd4\xf5\u011b\u0161\u010d\u0159\u017e\xfd\xe1\xed\xe9\xf3\xfa\u016f\u0165\u010f\u0148\u011a\u0160\u010c\u0158\u017d\xc1\xcd\xc9\xd3\xda\u0164\u017c\u017a\u015b\xf3\u0144\u0142\u0119\u0107\u0105\u017b\u0179\u015a\xd3\u0143\u0141\u0118\u0106\u0104-\u044f\u0410-\u042f\u0401\u0451]+|\S)$/,
      label_lastEnglish: /[a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430\xed\xec\xcd\xcc\xef\xc1\xc0\xe1\xe0\xc9\xc8\xd2\xd3\xf2\xf3\u0150\u0151\xd9\xda\u0170\xfa\u0171\xf1\xd1\xe6\xc6\u0153\u0152\xc3\xc2\xe3\xd4\xf5\u011b\u0161\u010d\u0159\u017e\xfd\xe1\xed\xe9\xf3\xfa\u016f\u0165\u010f\u0148\u011a\u0160\u010c\u0158\u017d\xc1\xcd\xc9\xd3\xda\u0164\u017c\u017a\u015b\xf3\u0144\u0142\u0119\u0107\u0105\u017b\u0179\u015a\xd3\u0143\u0141\u0118\u0106\u0104-\u044f\u0410-\u042f\u0401\u0451]+$/,
      label_firstEnglish: /^[a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430\xed\xec\xcd\xcc\xef\xc1\xc0\xe1\xe0\xc9\xc8\xd2\xd3\xf2\xf3\u0150\u0151\xd9\xda\u0170\xfa\u0171\xf1\xd1\xe6\xc6\u0153\u0152\xc3\xc2\xe3\xd4\xf5\u011b\u0161\u010d\u0159\u017e\xfd\xe1\xed\xe9\xf3\xfa\u016f\u0165\u010f\u0148\u011a\u0160\u010c\u0158\u017d\xc1\xcd\xc9\xd3\xda\u0164\u017c\u017a\u015b\xf3\u0144\u0142\u0119\u0107\u0105\u017b\u0179\u015a\xd3\u0143\u0141\u0118\u0106\u0104-\u044f\u0410-\u042f\u0401\u0451]/,
      label_wrapinspection: true,
      isUnicodeCJK: function(ch) {
        var __CHINESE_REG = /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/;
        var __JAPANESE_REG = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
        var __KOREAN_REG = /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/;
        return __CHINESE_REG.test(ch) || __JAPANESE_REG.test(ch) || __KOREAN_REG.test(ch);
      },
      isUnicodeSpace: function(ch) {
        ch = ch.charCodeAt(0);
        return ch >= 9 && ch <= 13 || 32 === ch || 133 === ch || 160 === ch || 5760 === ch || ch >= 8192 && ch <= 8202 || 8232 === ch || 8233 === ch || 8239 === ch || 8287 === ch || 12288 === ch;
      },
      fragmentText: function(stringToken, allWidth, maxWidth, measureText) {
        var wrappedWords = [];
        if (0 === stringToken.length || maxWidth < 0) {
          wrappedWords.push("");
          return wrappedWords;
        }
        var text = stringToken;
        while (allWidth > maxWidth && text.length > 1) {
          var fuzzyLen = text.length * (maxWidth / allWidth) | 0;
          var tmpText = text.substr(fuzzyLen);
          var width = allWidth - measureText(tmpText);
          var sLine = tmpText;
          var pushNum = 0;
          var checkWhile = 0;
          var checkCount = 10;
          while (width > maxWidth && checkWhile++ < checkCount) {
            fuzzyLen *= maxWidth / width;
            fuzzyLen |= 0;
            tmpText = text.substr(fuzzyLen);
            width = allWidth - measureText(tmpText);
          }
          checkWhile = 0;
          while (width <= maxWidth && checkWhile++ < checkCount) {
            if (tmpText) {
              var exec = this.label_wordRex.exec(tmpText);
              pushNum = exec ? exec[0].length : 1;
              sLine = tmpText;
            }
            fuzzyLen += pushNum;
            tmpText = text.substr(fuzzyLen);
            width = allWidth - measureText(tmpText);
          }
          fuzzyLen -= pushNum;
          if (0 === fuzzyLen) {
            fuzzyLen = 1;
            sLine = sLine.substr(1);
          }
          var sText = text.substr(0, fuzzyLen), result;
          if (this.label_wrapinspection && this.label_symbolRex.test(sLine || tmpText)) {
            result = this.label_lastWordRex.exec(sText);
            fuzzyLen -= result ? result[0].length : 0;
            0 === fuzzyLen && (fuzzyLen = 1);
            sLine = text.substr(fuzzyLen);
            sText = text.substr(0, fuzzyLen);
          }
          if (this.label_firstEnglish.test(sLine)) {
            result = this.label_lastEnglish.exec(sText);
            if (result && sText !== result[0]) {
              fuzzyLen -= result[0].length;
              sLine = text.substr(fuzzyLen);
              sText = text.substr(0, fuzzyLen);
            }
          }
          if (0 === wrappedWords.length) wrappedWords.push(sText); else {
            sText = sText.trim();
            sText.length > 0 && wrappedWords.push(sText);
          }
          text = sLine || tmpText;
          allWidth = measureText(text);
        }
        if (0 === wrappedWords.length) wrappedWords.push(text); else {
          text = text.trim();
          text.length > 0 && wrappedWords.push(text);
        }
        return wrappedWords;
      }
    };
    cc.TextUtils = module.exports = TextUtils;
    cc.CustomFontLoader = module.exports = CustomFontLoader;
  }), {} ],
  69: [ (function(require, module, exports) {
    var JS = require("../platform/js");
    var Pipeline = require("./pipeline");
    var LoadingItems = require("./loading-items");
    var AssetLoader = require("./asset-loader");
    var Downloader = require("./downloader");
    var Loader = require("./loader");
    var AssetTable = require("./asset-table");
    var callInNextTick = require("../platform/utils").callInNextTick;
    var AutoReleaseUtils = require("./auto-release-utils");
    var ReleasedAssetChecker = (true, require("./released-asset-checker"));
    var resources = new AssetTable();
    function getXMLHttpRequest() {
      return window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject("MSXML2.XMLHTTP");
    }
    var _info = {
      url: null,
      raw: false
    };
    function getResWithUrl(res) {
      var id, result, isUuid;
      if ("object" === typeof res) {
        result = res;
        if (res.url) return result;
        id = res.uuid;
      } else {
        result = {};
        id = res;
      }
      isUuid = result.type ? "uuid" === result.type : cc.AssetLibrary._uuidInSettings(id);
      cc.AssetLibrary._getAssetInfoInRuntime(id, _info);
      result.url = isUuid ? _info.url : id;
      if (_info.url && "uuid" === result.type && _info.raw) {
        result.type = null;
        result.isRawAsset = true;
      } else isUuid || (result.isRawAsset = true);
      return result;
    }
    var _sharedResources = [];
    var _sharedList = [];
    function CCLoader() {
      var assetLoader = new AssetLoader();
      var downloader = new Downloader();
      var loader = new Loader();
      Pipeline.call(this, [ assetLoader, downloader, loader ]);
      this.assetLoader = assetLoader;
      this.downloader = downloader;
      this.loader = loader;
      this.onProgress = null;
      this._autoReleaseSetting = {};
      true;
      this._releasedAssetChecker_DEBUG = new ReleasedAssetChecker();
    }
    JS.extend(CCLoader, Pipeline);
    var proto = CCLoader.prototype;
    proto.init = function(director) {
      true;
      var self = this;
      director.on(cc.Director.EVENT_BEFORE_VISIT, (function() {
        self._releasedAssetChecker_DEBUG.checkCouldRelease(self._cache);
      }));
    };
    proto.getXMLHttpRequest = getXMLHttpRequest;
    proto.addDownloadHandlers = function(extMap) {
      this.downloader.addHandlers(extMap);
    };
    proto.addLoadHandlers = function(extMap) {
      this.loader.addHandlers(extMap);
    };
    proto.load = function(resources, progressCallback, completeCallback) {
      false;
      if (void 0 === completeCallback) {
        completeCallback = progressCallback;
        progressCallback = this.onProgress || null;
      }
      var self = this;
      var singleRes = false;
      if (!(resources instanceof Array)) {
        singleRes = true;
        resources = resources ? [ resources ] : [];
      }
      _sharedResources.length = 0;
      for (var i = 0; i < resources.length; ++i) {
        var resource = resources[i];
        if (resource && resource.id) {
          cc.warnID(4920, resource.id);
          resource.uuid || resource.url || (resource.url = resource.id);
        }
        var res = getResWithUrl(resource);
        if (!res.url && !res.uuid) continue;
        var item = this._cache[res.url];
        _sharedResources.push(item || res);
      }
      var queue = LoadingItems.create(this, progressCallback, (function(errors, items) {
        callInNextTick((function() {
          if (completeCallback) {
            if (singleRes) {
              var id = res.url;
              completeCallback.call(self, items.getError(id), items.getContent(id));
            } else completeCallback.call(self, errors, items);
            completeCallback = null;
          }
          var _id;
          false;
          items.destroy();
        }));
      }));
      LoadingItems.initQueueDeps(queue);
      queue.append(_sharedResources);
      _sharedResources.length = 0;
    };
    proto.flowInDeps = function(owner, urlList, callback) {
      _sharedList.length = 0;
      for (var i = 0; i < urlList.length; ++i) {
        var res = getResWithUrl(urlList[i]);
        if (!res.url && !res.uuid) continue;
        var item = this._cache[res.url];
        item ? _sharedList.push(item) : _sharedList.push(res);
      }
      var queue = LoadingItems.create(this, owner ? function(completedCount, totalCount, item) {
        this._ownerQueue && this._ownerQueue.onProgress && this._ownerQueue._childOnProgress(item);
      } : null, (function(errors, items) {
        callback(errors, items);
        owner && owner.deps && (owner.deps.length = 0);
        items.destroy();
      }));
      if (owner) {
        var ownerQueue = LoadingItems.getQueue(owner);
        queue._ownerQueue = ownerQueue._ownerQueue || ownerQueue;
      }
      var accepted = queue.append(_sharedList, owner);
      _sharedList.length = 0;
      return accepted;
    };
    proto._resources = resources;
    proto._getResUuid = function(url, type, quiet) {
      if (!url) return null;
      var index = url.indexOf("?");
      -1 !== index && (url = url.substr(0, index));
      var uuid = resources.getUuid(url, type);
      if (!uuid) {
        var extname = cc.path.extname(url);
        if (extname) {
          url = url.slice(0, -extname.length);
          uuid = resources.getUuid(url, type);
          uuid && !quiet && cc.warnID(4901, url, extname);
        }
      }
      return uuid;
    };
    proto._getReferenceKey = function(assetOrUrlOrUuid) {
      var key;
      "object" === typeof assetOrUrlOrUuid ? key = assetOrUrlOrUuid._uuid || null : "string" === typeof assetOrUrlOrUuid && (key = this._getResUuid(assetOrUrlOrUuid, null, true) || assetOrUrlOrUuid);
      if (!key) {
        cc.warnID(4800, assetOrUrlOrUuid);
        return key;
      }
      cc.AssetLibrary._getAssetInfoInRuntime(key, _info);
      return this._cache[_info.url] ? _info.url : key;
    };
    proto._urlNotFound = function(url, type, completeCallback) {
      callInNextTick((function() {
        url = cc.url.normalize(url);
        var info = (type ? JS.getClassName(type) : "Asset") + ' in "resources/' + url + '" does not exist.';
        completeCallback && completeCallback(new Error(info), []);
      }));
    };
    proto._parseLoadResArgs = function(type, onProgress, onComplete) {
      if (void 0 === onComplete) {
        var isValidType = cc.isChildClassOf(type, cc.RawAsset);
        if (onProgress) {
          onComplete = onProgress;
          isValidType && (onProgress = this.onProgress || null);
        } else if (void 0 === onProgress && !isValidType) {
          onComplete = type;
          onProgress = this.onProgress || null;
          type = null;
        }
        if (void 0 !== onProgress && !isValidType) {
          onProgress = type;
          type = null;
        }
      }
      return {
        type: type,
        onProgress: onProgress,
        onComplete: onComplete
      };
    };
    proto.loadRes = function(url, type, progressCallback, completeCallback) {
      var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
      type = args.type;
      progressCallback = args.onProgress;
      completeCallback = args.onComplete;
      var self = this;
      var uuid = self._getResUuid(url, type);
      uuid ? this.load({
        type: "uuid",
        uuid: uuid
      }, progressCallback, (function(err, asset) {
        asset && self.setAutoReleaseRecursively(uuid, false);
        completeCallback && completeCallback(err, asset);
      })) : self._urlNotFound(url, type, completeCallback);
    };
    proto._loadResUuids = function(uuids, progressCallback, completeCallback, urls) {
      if (uuids.length > 0) {
        var self = this;
        var res = uuids.map((function(uuid) {
          return {
            type: "uuid",
            uuid: uuid
          };
        }));
        this.load(res, progressCallback, (function(errors, items) {
          if (completeCallback) {
            var assetRes = [];
            var urlRes = urls && [];
            for (var i = 0; i < res.length; ++i) {
              var uuid = res[i].uuid;
              var id = this._getReferenceKey(uuid);
              var item = items.getContent(id);
              if (item) {
                self.setAutoReleaseRecursively(uuid, false);
                assetRes.push(item);
                urlRes && urlRes.push(urls[i]);
              }
            }
            urls ? completeCallback(errors, assetRes, urlRes) : completeCallback(errors, assetRes);
          }
        }));
      } else completeCallback && callInNextTick((function() {
        urls ? completeCallback(null, [], []) : completeCallback(null, []);
      }));
    };
    proto.loadResArray = function(urls, type, progressCallback, completeCallback) {
      var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
      type = args.type;
      progressCallback = args.onProgress;
      completeCallback = args.onComplete;
      var uuids = [];
      for (var i = 0; i < urls.length; i++) {
        var url = urls[i];
        var uuid = this._getResUuid(url, type);
        if (!uuid) {
          this._urlNotFound(url, type, completeCallback);
          return;
        }
        uuids.push(uuid);
      }
      this._loadResUuids(uuids, progressCallback, completeCallback);
    };
    proto.loadResDir = function(url, type, progressCallback, completeCallback) {
      var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
      type = args.type;
      progressCallback = args.onProgress;
      completeCallback = args.onComplete;
      var urls = [];
      var uuids = resources.getUuidArray(url, type, urls);
      this._loadResUuids(uuids, progressCallback, (function(errors, assetRes, urlRes) {
        var assetResLength = assetRes.length;
        for (var i = 0; i < assetResLength; ++i) if (assetRes[i] instanceof cc.SpriteAtlas) {
          var spriteFrames = assetRes[i].getSpriteFrames();
          for (var k in spriteFrames) {
            var sf = spriteFrames[k];
            assetRes.push(sf);
            urlRes && urlRes.push(urlRes[i] + "/" + sf.name);
          }
        }
        completeCallback && completeCallback(errors, assetRes, urlRes);
      }), urls);
    };
    proto.getRes = function(url, type) {
      var item = this._cache[url];
      if (!item) {
        var uuid = this._getResUuid(url, type, true);
        if (!uuid) return null;
        var ref = this._getReferenceKey(uuid);
        item = this._cache[ref];
      }
      item && item.alias && (item = item.alias);
      return item && item.complete ? item.content : null;
    };
    proto.getResCount = function() {
      return Object.keys(this._cache).length;
    };
    proto.getDependsRecursively = function(owner) {
      if (owner) {
        var key = this._getReferenceKey(owner);
        var assets = AutoReleaseUtils.getDependsRecursively(key);
        assets.push(key);
        return assets;
      }
      return [];
    };
    proto.release = function(asset) {
      if (Array.isArray(asset)) for (var i = 0; i < asset.length; i++) {
        var key = asset[i];
        this.release(key);
      } else if (asset) {
        var id = this._getReferenceKey(asset);
        var item = this.getItem(id);
        if (item) {
          var removed = this.removeItem(id);
          asset = item.content;
          if (cc.Class.isInstanceOf(asset, cc.Asset)) {
            asset.nativeUrl && this.release(asset.nativeUrl);
            asset.destroy();
          }
          (true, removed) && this._releasedAssetChecker_DEBUG.setReleased(item, id);
        }
      }
    };
    proto.releaseAsset = function(asset) {
      var uuid = asset._uuid;
      uuid && this.release(uuid);
    };
    proto.releaseRes = function(url, type) {
      var uuid = this._getResUuid(url, type);
      uuid ? this.release(uuid) : cc.errorID(4914, url);
    };
    proto.releaseResDir = function(url, type) {
      var uuids = resources.getUuidArray(url, type);
      for (var i = 0; i < uuids.length; i++) {
        var uuid = uuids[i];
        this.release(uuid);
      }
    };
    proto.releaseAll = function() {
      for (var id in this._cache) this.release(id);
    };
    proto.removeItem = function(key) {
      var removed = Pipeline.prototype.removeItem.call(this, key);
      delete this._autoReleaseSetting[key];
      return removed;
    };
    proto.setAutoRelease = function(assetOrUrlOrUuid, autoRelease) {
      var key = this._getReferenceKey(assetOrUrlOrUuid);
      !!key && (this._autoReleaseSetting[key] = !!autoRelease);
    };
    proto.setAutoReleaseRecursively = function(assetOrUrlOrUuid, autoRelease) {
      autoRelease = !!autoRelease;
      var key = this._getReferenceKey(assetOrUrlOrUuid);
      if (key) {
        this._autoReleaseSetting[key] = autoRelease;
        var depends = AutoReleaseUtils.getDependsRecursively(key);
        for (var i = 0; i < depends.length; i++) {
          var depend = depends[i];
          this._autoReleaseSetting[depend] = autoRelease;
        }
      } else false;
    };
    proto.isAutoRelease = function(assetOrUrl) {
      var key = this._getReferenceKey(assetOrUrl);
      if (key) return !!this._autoReleaseSetting[key];
      return false;
    };
    cc.loader = new CCLoader();
    false;
    module.exports = cc.loader;
  }), {
    "../platform/js": 109,
    "../platform/utils": 113,
    "./asset-loader": 70,
    "./asset-table": 71,
    "./auto-release-utils": 73,
    "./downloader": 74,
    "./loader": 76,
    "./loading-items": 77,
    "./pipeline": 80,
    "./released-asset-checker": 81
  } ],
  70: [ (function(require, module, exports) {
    var Path = require("../utils/CCPath");
    var Pipeline = require("./pipeline");
    var LoadingItems = require("./loading-items");
    var ID = "AssetLoader";
    var AssetLoader = function(extMap) {
      this.id = ID;
      this.async = true;
      this.pipeline = null;
    };
    AssetLoader.ID = ID;
    var reusedArray = [];
    AssetLoader.prototype.handle = function(item, callback) {
      var uuid = item.uuid;
      if (!uuid) return !item.content ? null : item.content;
      var self = this;
      cc.AssetLibrary.queryAssetInfo(uuid, (function(error, url, isRawAsset) {
        if (error) callback(error); else {
          item.url = item.rawUrl = url;
          item.isRawAsset = isRawAsset;
          if (isRawAsset) {
            var ext = Path.extname(url).toLowerCase();
            if (!ext) {
              callback(new Error(cc._getError(4931, uuid, url)));
              return;
            }
            ext = ext.substr(1);
            var queue = LoadingItems.getQueue(item);
            reusedArray[0] = {
              queueId: item.queueId,
              id: url,
              url: url,
              type: ext,
              error: null,
              alias: item,
              complete: true
            };
            false;
            queue.append(reusedArray);
            item.type = ext;
            callback(null, item.content);
          } else {
            item.type = "uuid";
            callback(null, item.content);
          }
        }
      }));
    };
    Pipeline.AssetLoader = module.exports = AssetLoader;
  }), {
    "../utils/CCPath": 131,
    "./loading-items": 77,
    "./pipeline": 80
  } ],
  71: [ (function(require, module, exports) {
    var pushToMap = require("../utils/misc").pushToMap;
    function Entry(uuid, type) {
      this.uuid = uuid;
      this.type = type;
    }
    function AssetTable() {
      this._pathToUuid = {};
    }
    function isMatchByWord(path, test) {
      if (path.length > test.length) {
        var nextAscii = path.charCodeAt(test.length);
        return 46 === nextAscii || 47 === nextAscii;
      }
      return true;
    }
    var proto = AssetTable.prototype;
    proto.getUuid = function(path, type) {
      path = cc.url.normalize(path);
      var item = this._pathToUuid[path];
      if (item) if (Array.isArray(item)) {
        if (!type) return item[0].uuid;
        for (var i = 0; i < item.length; i++) {
          var entry = item[i];
          if (cc.isChildClassOf(entry.type, type)) return entry.uuid;
        }
        if (true, cc.isChildClassOf(type, cc.SpriteFrame)) for (var _i = 0; _i < item.length; _i++) {
          var _entry = item[_i];
          if (cc.isChildClassOf(_entry.type, cc.SpriteAtlas)) {
            cc.errorID(4932, path);
            break;
          }
        }
      } else {
        if (!type || cc.isChildClassOf(item.type, type)) return item.uuid;
        (true, cc.isChildClassOf(type, cc.SpriteFrame)) && cc.isChildClassOf(item.type, cc.SpriteAtlas) && cc.errorID(4932, path);
      }
      return "";
    };
    proto.getUuidArray = function(path, type, out_urls) {
      path = cc.url.normalize(path);
      "/" === path[path.length - 1] && (path = path.slice(0, -1));
      var path2uuid = this._pathToUuid;
      var uuids = [];
      var isChildClassOf = cc.isChildClassOf;
      var _foundAtlasUrl;
      for (var p in path2uuid) if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
        var item = path2uuid[p];
        if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
          var entry = item[i];
          if (!type || isChildClassOf(entry.type, type)) {
            uuids.push(entry.uuid);
            out_urls && out_urls.push(p);
          } else (true, entry.type === cc.SpriteAtlas) && (_foundAtlasUrl = p);
        } else if (!type || isChildClassOf(item.type, type)) {
          uuids.push(item.uuid);
          out_urls && out_urls.push(p);
        } else (true, item.type === cc.SpriteAtlas) && (_foundAtlasUrl = p);
      }
      (true, 0 === uuids.length) && _foundAtlasUrl && cc.isChildClassOf(type, cc.SpriteFrame) && cc.errorID(4932, _foundAtlasUrl);
      return uuids;
    };
    proto.add = function(path, uuid, type, isMainAsset) {
      path = path.substring(0, path.length - cc.path.extname(path).length);
      var newEntry = new Entry(uuid, type);
      pushToMap(this._pathToUuid, path, newEntry, isMainAsset);
    };
    proto._getInfo_DEBUG = (true, function(uuid, out_info) {
      var path2uuid = this._pathToUuid;
      var paths = Object.keys(path2uuid);
      for (var p = 0; p < paths.length; ++p) {
        var path = paths[p];
        var item = path2uuid[path];
        if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
          var entry = item[i];
          if (entry.uuid === uuid) {
            out_info.path = path;
            out_info.type = entry.type;
            return true;
          }
        } else if (item.uuid === uuid) {
          out_info.path = path;
          out_info.type = item.type;
          return true;
        }
      }
      return false;
    });
    proto.reset = function() {
      this._pathToUuid = {};
    };
    module.exports = AssetTable;
  }), {
    "../utils/misc": 137
  } ],
  72: [ (function(require, module, exports) {
    var sys = require("../platform/CCSys");
    var __audioSupport = sys.__audioSupport;
    var formatSupport = __audioSupport.format;
    var context = __audioSupport.context;
    function loadDomAudio(item, callback) {
      var dom = document.createElement("audio");
      dom.src = item.url;
      true;
      callback(null, dom);
      return;
      var clearEvent;
      var timer;
      var success;
      var failure;
    }
    function loadWebAudio(item, callback) {
      context || callback(new Error(cc._getError(4926)));
      var request = cc.loader.getXMLHttpRequest();
      request.open("GET", item.url, true);
      request.responseType = "arraybuffer";
      request.onload = function() {
        context["decodeAudioData"](request.response, (function(buffer) {
          callback(null, buffer);
        }), (function() {
          callback("decode error - " + item.id, null);
        }));
      };
      request.onerror = function() {
        callback("request error - " + item.id, null);
      };
      request.send();
    }
    function downloadAudio(item, callback) {
      if (0 === formatSupport.length) return new Error(cc._getError(4927));
      var loader;
      if (__audioSupport.WEB_AUDIO) {
        var loadByDeserializedAudio = item._owner instanceof cc.AudioClip;
        loader = loadByDeserializedAudio ? item._owner.loadMode === cc.AudioClip.LoadMode.WEB_AUDIO ? loadWebAudio : loadDomAudio : item.urlParam && item.urlParam["useDom"] ? loadDomAudio : loadWebAudio;
      } else loader = loadDomAudio;
      loader(item, callback);
    }
    module.exports = downloadAudio;
  }), {
    "../platform/CCSys": 97
  } ],
  73: [ (function(require, module, exports) {
    var JS = require("../platform/js");
    function parseDepends(key, parsed) {
      var item = cc.loader.getItem(key);
      if (item) {
        var depends = item.dependKeys;
        if (depends) for (var i = 0; i < depends.length; i++) {
          var depend = depends[i];
          if (!parsed[depend]) {
            parsed[depend] = true;
            parseDepends(depend, parsed);
          }
        }
      }
    }
    function visitAsset(asset, excludeMap) {
      var key = cc.loader._getReferenceKey(asset);
      if (!excludeMap[key]) {
        excludeMap[key] = true;
        parseDepends(key, excludeMap);
      }
    }
    function visitComponent(comp, excludeMap) {
      var props = Object.getOwnPropertyNames(comp);
      for (var i = 0; i < props.length; i++) {
        var value = comp[props[i]];
        if ("object" === typeof value && value) if (Array.isArray(value)) for (var j = 0; j < value.length; j++) {
          var val = value[j];
          cc.Class.isInstanceOf(val, cc.RawAsset) && visitAsset(val, excludeMap);
        } else if (value.constructor && value.constructor !== Object) cc.Class.isInstanceOf(value, cc.RawAsset) && visitAsset(value, excludeMap); else {
          var keys = Object.getOwnPropertyNames(value);
          for (var _j = 0; _j < keys.length; _j++) {
            var _val = value[keys[_j]];
            cc.Class.isInstanceOf(_val, cc.RawAsset) && visitAsset(_val, excludeMap);
          }
        }
      }
    }
    function visitNode(node, excludeMap) {
      for (var i = 0; i < node._components.length; i++) visitComponent(node._components[i], excludeMap);
      for (var _i = 0; _i < node._children.length; _i++) visitNode(node._children[_i], excludeMap);
    }
    module.exports = {
      autoRelease: function(oldSceneAssets, nextSceneAssets, persistNodes) {
        var releaseSettings = cc.loader._autoReleaseSetting;
        var excludeMap = JS.createMap();
        if (nextSceneAssets) for (var i = 0; i < nextSceneAssets.length; i++) excludeMap[nextSceneAssets[i]] = true;
        for (var _i2 = 0; _i2 < persistNodes.length; _i2++) visitNode(persistNodes[_i2], excludeMap);
        if (oldSceneAssets) for (var _i3 = 0; _i3 < oldSceneAssets.length; _i3++) {
          var key = oldSceneAssets[_i3];
          false === releaseSettings[key] || excludeMap[key] || cc.loader.release(key);
        }
        var keys = Object.keys(releaseSettings);
        for (var _i4 = 0; _i4 < keys.length; _i4++) {
          var _key = keys[_i4];
          true !== releaseSettings[_key] || excludeMap[_key] || cc.loader.release(_key);
        }
      },
      getDependsRecursively: function(key) {
        var depends = {};
        parseDepends(key, depends);
        return Object.keys(depends);
      }
    };
  }), {
    "../platform/js": 109
  } ],
  74: [ (function(require, module, exports) {
    var JS = require("../platform/js");
    var sys = require("../platform/CCSys");
    var Path = require("../utils/CCPath");
    var misc = require("../utils/misc");
    var Pipeline = require("./pipeline");
    var PackDownloader = require("./pack-downloader");
    var downloadText = require("./text-downloader");
    var urlAppendTimestamp = require("./utils").urlAppendTimestamp;
    var downloadAudio;
    true;
    downloadAudio = require("./audio-downloader");
    function downloadScript(item, callback, isAsync) {
      if (sys.platform === sys.WECHAT_GAME) {
        require(item.url);
        callback(null, item.url);
        return;
      }
      var url = item.url, d = document, s = document.createElement("script");
      s.async = isAsync;
      s.src = urlAppendTimestamp(url);
      function loadHandler() {
        s.parentNode.removeChild(s);
        s.removeEventListener("load", loadHandler, false);
        s.removeEventListener("error", errorHandler, false);
        callback(null, url);
      }
      function errorHandler() {
        s.parentNode.removeChild(s);
        s.removeEventListener("load", loadHandler, false);
        s.removeEventListener("error", errorHandler, false);
        callback(new Error(cc._getError(4928, url)));
      }
      s.addEventListener("load", loadHandler, false);
      s.addEventListener("error", errorHandler, false);
      d.body.appendChild(s);
    }
    function downloadWebp(item, callback, isCrossOrigin, img) {
      if (!cc.sys.capabilities.webp) return new Error(cc._getError(4929, item.url));
      return downloadImage(item, callback, isCrossOrigin, img);
    }
    function downloadImage(item, callback, isCrossOrigin, img) {
      void 0 === isCrossOrigin && (isCrossOrigin = true);
      var url = urlAppendTimestamp(item.url);
      img = img || misc.imagePool.get();
      isCrossOrigin && "file:" !== window.location.protocol ? img.crossOrigin = "anonymous" : img.crossOrigin = null;
      if (img.complete && img.naturalWidth > 0 && img.src === url) return img;
      (function() {
        function loadCallback() {
          img.removeEventListener("load", loadCallback);
          img.removeEventListener("error", errorCallback);
          callback(null, img);
        }
        function errorCallback() {
          img.removeEventListener("load", loadCallback);
          img.removeEventListener("error", errorCallback);
          "https:" !== window.location.protocol && img.crossOrigin && "anonymous" === img.crossOrigin.toLowerCase() ? downloadImage(item, callback, false, img) : callback(new Error(cc._getError(4930, url)));
        }
        img.addEventListener("load", loadCallback);
        img.addEventListener("error", errorCallback);
        img.src = url;
      })();
    }
    var FONT_TYPE = {
      ".eot": "embedded-opentype",
      ".ttf": "truetype",
      ".ttc": "truetype",
      ".woff": "woff",
      ".svg": "svg"
    };
    function _loadFont(name, srcs, type) {
      var doc = document, fontStyle = document.createElement("style");
      fontStyle.type = "text/css";
      doc.body.appendChild(fontStyle);
      var fontStr = "";
      isNaN(name - 0) ? fontStr += "@font-face { font-family:" + name + "; src:" : fontStr += "@font-face { font-family:'" + name + "'; src:";
      if (srcs instanceof Array) for (var i = 0, li = srcs.length; i < li; i++) {
        var src = srcs[i];
        type = Path.extname(src).toLowerCase();
        fontStr += "url('" + srcs[i] + "') format('" + FONT_TYPE[type] + "')";
        fontStr += i === li - 1 ? ";" : ",";
      } else {
        type = type.toLowerCase();
        fontStr += "url('" + srcs + "') format('" + FONT_TYPE[type] + "');";
      }
      fontStyle.textContent += fontStr + "}";
      var preloadDiv = document.createElement("div");
      var _divStyle = preloadDiv.style;
      _divStyle.fontFamily = name;
      preloadDiv.innerHTML = ".";
      _divStyle.position = "absolute";
      _divStyle.left = "-100px";
      _divStyle.top = "-100px";
      doc.body.appendChild(preloadDiv);
    }
    function downloadFont(item, callback) {
      var url = item.url, type = item.type, name = item.name, srcs = item.srcs;
      if (name && srcs) {
        -1 === srcs.indexOf(url) && srcs.push(url);
        _loadFont(name, srcs);
      } else {
        type = Path.extname(url);
        name = Path.basename(url, type);
        _loadFont(name, url, type);
      }
      if (!document.fonts) return null;
      document.fonts.load("1em " + name).then((function() {
        callback(null, null);
      }), (function(err) {
        callback(err);
      }));
    }
    function downloadUuid(item, callback) {
      var result = PackDownloader.load(item, callback);
      if (void 0 === result) return this.extMap["json"](item, callback);
      return result || void 0;
    }
    var defaultMap = {
      js: downloadScript,
      png: downloadImage,
      jpg: downloadImage,
      bmp: downloadImage,
      jpeg: downloadImage,
      gif: downloadImage,
      ico: downloadImage,
      tiff: downloadImage,
      webp: downloadWebp,
      image: downloadImage,
      mp3: downloadAudio,
      ogg: downloadAudio,
      wav: downloadAudio,
      m4a: downloadAudio,
      txt: downloadText,
      xml: downloadText,
      vsh: downloadText,
      fsh: downloadText,
      atlas: downloadText,
      tmx: downloadText,
      tsx: downloadText,
      json: downloadText,
      ExportJson: downloadText,
      plist: downloadText,
      fnt: downloadText,
      font: downloadFont,
      eot: downloadFont,
      ttf: downloadFont,
      woff: downloadFont,
      svg: downloadFont,
      ttc: downloadFont,
      uuid: downloadUuid,
      default: downloadText
    };
    var ID = "Downloader";
    var Downloader = function(extMap) {
      this.id = ID;
      this.async = true;
      this.pipeline = null;
      this._curConcurrent = 0;
      this._loadQueue = [];
      this._subpackages = {};
      this.extMap = JS.mixin(extMap, defaultMap);
    };
    Downloader.ID = ID;
    Downloader.PackDownloader = PackDownloader;
    Downloader.prototype.addHandlers = function(extMap) {
      JS.mixin(this.extMap, extMap);
    };
    Downloader.prototype._handleLoadQueue = function() {
      while (this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT) {
        var nextOne = this._loadQueue.shift();
        if (!nextOne) break;
        var syncRet = this.handle(nextOne.item, nextOne.callback);
        void 0 !== syncRet && (syncRet instanceof Error ? nextOne.callback(syncRet) : nextOne.callback(null, syncRet));
      }
    };
    Downloader.prototype.handle = function(item, callback) {
      var self = this;
      var downloadFunc = this.extMap[item.type] || this.extMap["default"];
      var syncRet = void 0;
      if (this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT) {
        this._curConcurrent++;
        syncRet = downloadFunc.call(this, item, (function(err, result) {
          self._curConcurrent = Math.max(0, self._curConcurrent - 1);
          self._handleLoadQueue();
          callback && callback(err, result);
        }));
        if (void 0 !== syncRet) {
          this._curConcurrent = Math.max(0, this._curConcurrent - 1);
          this._handleLoadQueue();
          return syncRet;
        }
      } else if (item.ignoreMaxConcurrency) {
        syncRet = downloadFunc.call(this, item, callback);
        if (void 0 !== syncRet) return syncRet;
      } else this._loadQueue.push({
        item: item,
        callback: callback
      });
    };
    Downloader.prototype.loadSubpackage = function(name, completeCallback) {
      var pac = this._subpackages[name];
      pac ? pac.loaded ? completeCallback && completeCallback() : downloadScript({
        url: pac.path
      }, (function(err) {
        err || (pac.loaded = true);
        completeCallback && completeCallback(err);
      })) : completeCallback && completeCallback(new Error("Can't find subpackage " + name));
    };
    Pipeline.Downloader = module.exports = Downloader;
  }), {
    "../platform/CCSys": 97,
    "../platform/js": 109,
    "../utils/CCPath": 131,
    "../utils/misc": 137,
    "./audio-downloader": 72,
    "./pack-downloader": 79,
    "./pipeline": 80,
    "./text-downloader": 82,
    "./utils": 84
  } ],
  75: [ (function(require, module, exports) {
    require("./downloader");
    require("./loader");
    require("./loading-items");
    require("./pipeline");
    require("./CCLoader");
  }), {
    "./CCLoader": 69,
    "./downloader": 74,
    "./loader": 76,
    "./loading-items": 77,
    "./pipeline": 80
  } ],
  76: [ (function(require, module, exports) {
    var JS = require("../platform/js");
    var Pipeline = require("./pipeline");
    var Texture2D = require("../textures/CCTexture2D");
    var loadUuid = require("./uuid-loader");
    function loadNothing(item, callback) {
      return null;
    }
    function loadJSON(item, callback) {
      if ("string" !== typeof item.content) return new Error("JSON Loader: Input item doesn't contain string content");
      try {
        var result = JSON.parse(item.content);
        return result;
      } catch (e) {
        return new Error("JSON Loader: Parse json [" + item.id + "] failed : " + e);
      }
    }
    function loadImage(item, callback) {
      var loadByDeserializedAsset = cc.Class.isInstanceOf(item._owner, cc.Asset);
      if (loadByDeserializedAsset) return null;
      var image = item.content;
      false;
      var rawUrl = item.rawUrl;
      var tex = cc.textureCache.getTextureForKey(rawUrl) || new Texture2D();
      tex.url = rawUrl;
      tex._setRawAsset(rawUrl, false);
      tex._nativeAsset = image;
      cc.textureCache.cacheImage(rawUrl, tex);
      return tex;
    }
    function loadAudioAsAsset(item, callback) {
      var loadByDeserializedAsset = cc.Class.isInstanceOf(item._owner, cc.Asset);
      if (loadByDeserializedAsset) return null;
      var audioClip = new cc.AudioClip();
      audioClip._setRawAsset(item.rawUrl, false);
      audioClip._nativeAsset = item.content;
      return audioClip;
    }
    function loadPlist(item, callback) {
      if ("string" !== typeof item.content) return new Error("Plist Loader: Input item doesn't contain string content");
      var result = cc.plistParser.parse(item.content);
      return result || new Error("Plist Loader: Parse [" + item.id + "] failed");
    }
    var defaultMap = {
      png: loadImage,
      jpg: loadImage,
      bmp: loadImage,
      jpeg: loadImage,
      gif: loadImage,
      ico: loadImage,
      tiff: loadImage,
      webp: loadImage,
      image: loadImage,
      mp3: loadAudioAsAsset,
      ogg: loadAudioAsAsset,
      wav: loadAudioAsAsset,
      m4a: loadAudioAsAsset,
      json: loadJSON,
      ExportJson: loadJSON,
      plist: loadPlist,
      uuid: loadUuid,
      prefab: loadUuid,
      fire: loadUuid,
      scene: loadUuid,
      default: loadNothing
    };
    var ID = "Loader";
    var Loader = function(extMap) {
      this.id = ID;
      this.async = true;
      this.pipeline = null;
      this.extMap = JS.mixin(extMap, defaultMap);
    };
    Loader.ID = ID;
    Loader.prototype.addHandlers = function(extMap) {
      this.extMap = JS.mixin(this.extMap, extMap);
    };
    Loader.prototype.handle = function(item, callback) {
      var loadFunc = this.extMap[item.type] || this.extMap["default"];
      return loadFunc.call(this, item, callback);
    };
    Pipeline.Loader = module.exports = Loader;
  }), {
    "../platform/js": 109,
    "../textures/CCTexture2D": 128,
    "./pipeline": 80,
    "./uuid-loader": 85
  } ],
  77: [ (function(require, module, exports) {
    var CallbacksInvoker = require("../platform/callbacks-invoker");
    var Path = require("../utils/CCPath");
    var JS = require("../platform/js");
    var _qid = 0 | 998 * Math.random();
    var _queues = {};
    var _pool = [];
    var _POOL_MAX_LENGTH = 10;
    var ItemState = {
      WORKING: 1,
      COMPLETE: 2,
      ERROR: 3
    };
    var _queueDeps = {};
    function isIdValid(id) {
      var realId = id.url || id;
      return "string" === typeof realId;
    }
    function _parseUrlParam(url) {
      if (!url) return;
      var split = url.split("?");
      if (!split || !split[0] || !split[1]) return;
      var urlParam = {};
      var queries = split[1].split("&");
      queries.forEach((function(item) {
        var itemSplit = item.split("=");
        urlParam[itemSplit[0]] = itemSplit[1];
      }));
      return urlParam;
    }
    function createItem(id, queueId) {
      var url = "object" === typeof id ? id.url : id;
      var result = {
        queueId: queueId,
        id: url,
        url: url,
        rawUrl: void 0,
        urlParam: _parseUrlParam(url),
        type: "",
        error: null,
        content: null,
        complete: false,
        states: {},
        deps: null
      };
      if ("object" === typeof id) {
        JS.mixin(result, id);
        if (id.skips) for (var i = 0; i < id.skips.length; i++) {
          var skip = id.skips[i];
          result.states[skip] = ItemState.COMPLETE;
        }
      }
      result.rawUrl = result.url;
      url && !result.type && (result.type = Path.extname(url).toLowerCase().substr(1));
      return result;
    }
    var checkedIds = [];
    function checkCircleReference(owner, item, recursiveCall) {
      if (!owner || !item) return false;
      var result = false;
      checkedIds.push(item.id);
      if (item.deps) {
        var i, deps = item.deps, subDep;
        for (i = 0; i < deps.length; i++) {
          subDep = deps[i];
          if (subDep.id === owner.id) {
            result = true;
            break;
          }
          if (checkedIds.indexOf(subDep.id) >= 0) continue;
          if (subDep.deps && checkCircleReference(owner, subDep, true)) {
            result = true;
            break;
          }
        }
      }
      recursiveCall || (checkedIds.length = 0);
      return result;
    }
    var LoadingItems = function(pipeline, urlList, onProgress, onComplete) {
      CallbacksInvoker.call(this);
      this._id = ++_qid;
      _queues[this._id] = this;
      this._pipeline = pipeline;
      this._errorUrls = [];
      this._appending = false;
      this._ownerQueue = null;
      this.onProgress = onProgress;
      this.onComplete = onComplete;
      this.map = {};
      this.completed = {};
      this.totalCount = 0;
      this.completedCount = 0;
      this._pipeline ? this.active = true : this.active = false;
      urlList && (urlList.length > 0 ? this.append(urlList) : this.allComplete());
    };
    LoadingItems.ItemState = new cc.Enum(ItemState);
    LoadingItems.create = function(pipeline, urlList, onProgress, onComplete) {
      if (void 0 === onProgress) {
        if ("function" === typeof urlList) {
          onComplete = urlList;
          urlList = onProgress = null;
        }
      } else if (void 0 === onComplete) if ("function" === typeof urlList) {
        onComplete = onProgress;
        onProgress = urlList;
        urlList = null;
      } else {
        onComplete = onProgress;
        onProgress = null;
      }
      var queue = _pool.pop();
      if (queue) {
        queue._pipeline = pipeline;
        queue.onProgress = onProgress;
        queue.onComplete = onComplete;
        _queues[queue._id] = queue;
        queue._pipeline && (queue.active = true);
        urlList && queue.append(urlList);
      } else queue = new LoadingItems(pipeline, urlList, onProgress, onComplete);
      return queue;
    };
    LoadingItems.getQueue = function(item) {
      return item.queueId ? _queues[item.queueId] : null;
    };
    LoadingItems.itemComplete = function(item) {
      var queue = _queues[item.queueId];
      queue && queue.itemComplete(item.id);
    };
    LoadingItems.initQueueDeps = function(queue) {
      var dep = _queueDeps[queue._id];
      if (dep) {
        dep.completed.length = 0;
        dep.deps.length = 0;
      } else dep = _queueDeps[queue._id] = {
        completed: [],
        deps: []
      };
    };
    LoadingItems.registerQueueDep = function(owner, depId) {
      var queueId = owner.queueId || owner;
      if (!queueId) return false;
      var queueDepList = _queueDeps[queueId];
      if (queueDepList) -1 === queueDepList.deps.indexOf(depId) && queueDepList.deps.push(depId); else if (owner.id) for (var id in _queueDeps) {
        var queue = _queueDeps[id];
        -1 !== queue.deps.indexOf(owner.id) && -1 === queue.deps.indexOf(depId) && queue.deps.push(depId);
      }
    };
    LoadingItems.finishDep = function(depId) {
      for (var id in _queueDeps) {
        var queue = _queueDeps[id];
        -1 !== queue.deps.indexOf(depId) && -1 === queue.completed.indexOf(depId) && queue.completed.push(depId);
      }
    };
    var proto = LoadingItems.prototype;
    JS.mixin(proto, CallbacksInvoker.prototype);
    proto.append = function(urlList, owner) {
      if (!this.active) return [];
      owner && !owner.deps && (owner.deps = []);
      this._appending = true;
      var accepted = [], i, url, item;
      for (i = 0; i < urlList.length; ++i) {
        url = urlList[i];
        if (url.queueId && !this.map[url.id]) {
          this.map[url.id] = url;
          owner && owner.deps.push(url);
          if (url.complete || checkCircleReference(owner, url)) {
            this.totalCount++;
            this.itemComplete(url.id);
            continue;
          }
          var self = this;
          var queue = _queues[url.queueId];
          if (queue) {
            this.totalCount++;
            LoadingItems.registerQueueDep(owner || this._id, url.id);
            queue.addListener(url.id, (function(item) {
              self.itemComplete(item.id);
            }));
          }
          continue;
        }
        if (isIdValid(url)) {
          item = createItem(url, this._id);
          var key = item.id;
          if (!this.map[key]) {
            this.map[key] = item;
            this.totalCount++;
            owner && owner.deps.push(item);
            LoadingItems.registerQueueDep(owner || this._id, key);
            accepted.push(item);
          }
        }
      }
      this._appending = false;
      this.completedCount === this.totalCount ? this.allComplete() : this._pipeline.flowIn(accepted);
      return accepted;
    };
    proto._childOnProgress = function(item) {
      if (this.onProgress) {
        var dep = _queueDeps[this._id];
        this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
      }
    };
    proto.allComplete = function() {
      var errors = 0 === this._errorUrls.length ? null : this._errorUrls;
      this.onComplete && this.onComplete(errors, this);
    };
    proto.isCompleted = function() {
      return this.completedCount >= this.totalCount;
    };
    proto.isItemCompleted = function(id) {
      return !!this.completed[id];
    };
    proto.exists = function(id) {
      return !!this.map[id];
    };
    proto.getContent = function(id) {
      var item = this.map[id];
      var ret = null;
      item && (item.content ? ret = item.content : item.alias && (ret = item.alias.content));
      return ret;
    };
    proto.getError = function(id) {
      var item = this.map[id];
      var ret = null;
      item && (item.error ? ret = item.error : item.alias && (ret = item.alias.error));
      return ret;
    };
    proto.addListener = CallbacksInvoker.prototype.add;
    proto.hasListener = CallbacksInvoker.prototype.has;
    proto.removeListener = CallbacksInvoker.prototype.remove;
    proto.removeAllListeners = CallbacksInvoker.prototype.removeAll;
    proto.removeItem = function(url) {
      var item = this.map[url];
      if (!item) return;
      if (!this.completed[item.alias || url]) return;
      delete this.completed[url];
      delete this.map[url];
      if (item.alias) {
        delete this.completed[item.alias.id];
        delete this.map[item.alias.id];
      }
      this.completedCount--;
      this.totalCount--;
    };
    proto.itemComplete = function(id) {
      var item = this.map[id];
      if (!item) return;
      var errorListId = this._errorUrls.indexOf(id);
      item.error && -1 === errorListId ? this._errorUrls.push(id) : item.error || -1 === errorListId || this._errorUrls.splice(errorListId, 1);
      this.completed[id] = item;
      this.completedCount++;
      LoadingItems.finishDep(item.id);
      if (this.onProgress) {
        var dep = _queueDeps[this._id];
        this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
      }
      this.invoke(id, item);
      this.removeAll(id);
      !this._appending && this.completedCount >= this.totalCount && this.allComplete();
    };
    proto.destroy = function() {
      this.active = false;
      this._appending = false;
      this._pipeline = null;
      this._ownerQueue = null;
      this._errorUrls.length = 0;
      this.onProgress = null;
      this.onComplete = null;
      this.map = {};
      this.completed = {};
      this.totalCount = 0;
      this.completedCount = 0;
      CallbacksInvoker.call(this);
      _queues[this._id] = null;
      if (_queueDeps[this._id]) {
        _queueDeps[this._id].completed.length = 0;
        _queueDeps[this._id].deps.length = 0;
      }
      -1 === _pool.indexOf(this) && _pool.length < _POOL_MAX_LENGTH && _pool.push(this);
    };
    cc.LoadingItems = module.exports = LoadingItems;
  }), {
    "../platform/callbacks-invoker": 102,
    "../platform/js": 109,
    "../utils/CCPath": 131
  } ],
  78: [ (function(require, module, exports) {
    var Pipeline = require("./pipeline");
    var ID = "MD5Pipe";
    var ExtnameRegex = /(\.[^.\n\\/]*)$/;
    var MD5Pipe = function(md5AssetsMap, libraryBase, rawAssetsBase) {
      this.id = ID;
      this.async = false;
      this.pipeline = null;
      this.md5AssetsMap = md5AssetsMap;
      this.libraryBase = libraryBase;
      this.rawAssetsBase = rawAssetsBase;
    };
    MD5Pipe.ID = ID;
    MD5Pipe.prototype.handle = function(item) {
      item.url = this.transformURL(item.url);
      return item;
    };
    MD5Pipe.prototype.transformURL = function(url, hashPatchInFolder) {
      var index = url.indexOf("?");
      var key = url;
      -1 !== index && (key = url.substr(0, index));
      if (key.startsWith(this.libraryBase)) key = key.slice(this.libraryBase.length); else {
        if (!key.startsWith(this.rawAssetsBase)) return url;
        key = key.slice(this.rawAssetsBase.length);
      }
      var hashValue = this.md5AssetsMap[key];
      if (hashValue) if (hashPatchInFolder) {
        var dirname = cc.path.dirname(url);
        var basename = cc.path.basename(url);
        url = dirname + "." + hashValue + "/" + basename;
      } else {
        var matched = false;
        url = url.replace(ExtnameRegex, (function(match, p1) {
          matched = true;
          return "." + hashValue + p1;
        }));
        matched || (url = url + "." + hashValue);
      }
      return url;
    };
    Pipeline.MD5Pipe = module.exports = MD5Pipe;
  }), {
    "./pipeline": 80
  } ],
  79: [ (function(require, module, exports) {
    var Unpackers = require("./unpackers");
    var pushToMap = require("../utils/misc").pushToMap;
    var PackState = {
      Invalid: 0,
      Removed: 1,
      Downloading: 2,
      Loaded: 3
    };
    function UnpackerData() {
      this.unpacker = null;
      this.state = PackState.Invalid;
    }
    var uuidToPack = {};
    var packIndices = {};
    var globalUnpackers = {};
    function error(uuid, packUuid) {
      return new Error("Can not retrieve " + uuid + " from packer " + packUuid);
    }
    module.exports = {
      initPacks: function(packs) {
        packIndices = packs;
        for (var packUuid in packs) {
          var uuids = packs[packUuid];
          for (var i = 0; i < uuids.length; i++) {
            var uuid = uuids[i];
            var pushFront = 1 === uuids.length;
            pushToMap(uuidToPack, uuid, packUuid, pushFront);
          }
        }
      },
      _loadNewPack: function(uuid, packUuid, callback) {
        var self = this;
        var packUrl = cc.AssetLibrary.getLibUrlNoExt(packUuid) + ".json";
        cc.loader.load({
          url: packUrl,
          ignoreMaxConcurrency: true
        }, (function(err, packJson) {
          if (err) {
            cc.errorID(4916, uuid);
            return callback(err);
          }
          var res = self._doLoadNewPack(uuid, packUuid, packJson);
          res ? callback(null, res) : callback(error(uuid, packUuid));
        }));
      },
      _doPreload: function(packUuid, packJson) {
        var unpackerData = globalUnpackers[packUuid];
        if (!unpackerData) {
          unpackerData = globalUnpackers[packUuid] = new UnpackerData();
          unpackerData.state = PackState.Downloading;
        }
        if (unpackerData.state !== PackState.Loaded) {
          unpackerData.unpacker = new Unpackers.JsonUnpacker();
          unpackerData.unpacker.load(packIndices[packUuid], packJson);
          unpackerData.state = PackState.Loaded;
        }
      },
      _doLoadNewPack: function(uuid, packUuid, packedJson) {
        var unpackerData = globalUnpackers[packUuid];
        if (unpackerData.state !== PackState.Loaded) {
          "string" === typeof packedJson && (packedJson = JSON.parse(packedJson));
          Array.isArray(packedJson) ? unpackerData.unpacker = new Unpackers.JsonUnpacker() : packedJson.type === Unpackers.TextureUnpacker.ID && (unpackerData.unpacker = new Unpackers.TextureUnpacker());
          unpackerData.unpacker.load(packIndices[packUuid], packedJson);
          unpackerData.state = PackState.Loaded;
        }
        return unpackerData.unpacker.retrieve(uuid);
      },
      _selectLoadedPack: function(packUuids) {
        var existsPackState = PackState.Invalid;
        var existsPackUuid = "";
        for (var i = 0; i < packUuids.length; i++) {
          var packUuid = packUuids[i];
          var unpackerData = globalUnpackers[packUuid];
          if (unpackerData) {
            var state = unpackerData.state;
            if (state === PackState.Loaded) return packUuid;
            if (state > existsPackState) {
              existsPackState = state;
              existsPackUuid = packUuid;
            }
          }
        }
        return existsPackState !== PackState.Invalid ? existsPackUuid : packUuids[0];
      },
      load: function(item, callback) {
        var uuid = item.uuid;
        var packUuid = uuidToPack[uuid];
        if (!packUuid) return;
        Array.isArray(packUuid) && (packUuid = this._selectLoadedPack(packUuid));
        var unpackerData = globalUnpackers[packUuid];
        if (unpackerData && unpackerData.state === PackState.Loaded) {
          var json = unpackerData.unpacker.retrieve(uuid);
          return json || error(uuid, packUuid);
        }
        if (!unpackerData) {
          true;
          console.log("Create unpacker %s for %s", packUuid, uuid);
          unpackerData = globalUnpackers[packUuid] = new UnpackerData();
          unpackerData.state = PackState.Downloading;
        }
        this._loadNewPack(uuid, packUuid, callback);
        return null;
      }
    };
    false;
  }), {
    "../utils/misc": 137,
    "./unpackers": 83
  } ],
  80: [ (function(require, module, exports) {
    var JS = require("../platform/js");
    var LoadingItems = require("./loading-items");
    var ItemState = LoadingItems.ItemState;
    function flow(pipe, item) {
      var pipeId = pipe.id;
      var itemState = item.states[pipeId];
      var next = pipe.next;
      var pipeline = pipe.pipeline;
      if (item.error || itemState === ItemState.WORKING || itemState === ItemState.ERROR) return;
      if (itemState === ItemState.COMPLETE) next ? flow(next, item) : pipeline.flowOut(item); else {
        item.states[pipeId] = ItemState.WORKING;
        var result = pipe.handle(item, (function(err, result) {
          if (err) {
            item.error = err;
            item.states[pipeId] = ItemState.ERROR;
            pipeline.flowOut(item);
          } else {
            result && (item.content = result);
            item.states[pipeId] = ItemState.COMPLETE;
            next ? flow(next, item) : pipeline.flowOut(item);
          }
        }));
        if (result instanceof Error) {
          item.error = result;
          item.states[pipeId] = ItemState.ERROR;
          pipeline.flowOut(item);
        } else if (void 0 !== result) {
          null !== result && (item.content = result);
          item.states[pipeId] = ItemState.COMPLETE;
          next ? flow(next, item) : pipeline.flowOut(item);
        }
      }
    }
    var Pipeline = function(pipes) {
      this._pipes = pipes;
      this._cache = {};
      for (var i = 0; i < pipes.length; ++i) {
        var pipe = pipes[i];
        if (!pipe.handle || !pipe.id) continue;
        pipe.pipeline = this;
        pipe.next = i < pipes.length - 1 ? pipes[i + 1] : null;
      }
    };
    Pipeline.ItemState = ItemState;
    var proto = Pipeline.prototype;
    proto.insertPipe = function(pipe, index) {
      if (!pipe.handle || !pipe.id || index > this._pipes.length) {
        cc.warnID(4921);
        return;
      }
      if (this._pipes.indexOf(pipe) > 0) {
        cc.warnID(4922);
        return;
      }
      pipe.pipeline = this;
      var nextPipe = null;
      index < this._pipes.length && (nextPipe = this._pipes[index]);
      var previousPipe = null;
      index > 0 && (previousPipe = this._pipes[index - 1]);
      previousPipe && (previousPipe.next = pipe);
      pipe.next = nextPipe;
      this._pipes.splice(index, 0, pipe);
    };
    proto.insertPipeAfter = function(refPipe, newPipe) {
      var index = this._pipes.indexOf(refPipe);
      if (index < 0) return;
      this.insertPipe(newPipe, index + 1);
    };
    proto.appendPipe = function(pipe) {
      if (!pipe.handle || !pipe.id) return;
      pipe.pipeline = this;
      pipe.next = null;
      this._pipes.length > 0 && (this._pipes[this._pipes.length - 1].next = pipe);
      this._pipes.push(pipe);
    };
    proto.flowIn = function(items) {
      var i, pipe = this._pipes[0], item;
      if (pipe) {
        for (i = 0; i < items.length; i++) {
          item = items[i];
          this._cache[item.id] = item;
        }
        for (i = 0; i < items.length; i++) {
          item = items[i];
          flow(pipe, item);
        }
      } else for (i = 0; i < items.length; i++) this.flowOut(items[i]);
    };
    proto.flowInDeps = function(owner, urlList, callback) {
      var deps = LoadingItems.create(this, (function(errors, items) {
        callback(errors, items);
        items.destroy();
      }));
      return deps.append(urlList, owner);
    };
    proto.flowOut = function(item) {
      item.error ? delete this._cache[item.id] : this._cache[item.id] || (this._cache[item.id] = item);
      item.complete = true;
      LoadingItems.itemComplete(item);
    };
    proto.copyItemStates = function(srcItem, dstItems) {
      if (!(dstItems instanceof Array)) {
        dstItems.states = srcItem.states;
        return;
      }
      for (var i = 0; i < dstItems.length; ++i) dstItems[i].states = srcItem.states;
    };
    proto.isFlowing = function() {
      return true;
    };
    proto.getItems = function() {
      return null;
    };
    proto.getItem = function(id) {
      var item = this._cache[id];
      if (!item) return item;
      item.alias && (item = item.alias);
      return item;
    };
    proto.removeItem = function(id) {
      var removed = this._cache[id];
      removed && removed.complete && delete this._cache[id];
      return removed;
    };
    proto.clear = function() {
      for (var id in this._cache) {
        var item = this._cache[id];
        delete this._cache[id];
        if (!item.complete) {
          item.error = new Error("Canceled manually");
          this.flowOut(item);
        }
      }
    };
    cc.Pipeline = module.exports = Pipeline;
  }), {
    "../platform/js": 109,
    "./loading-items": 77
  } ],
  81: [ (function(require, module, exports) {
    true;
    var JS;
    var tmpInfo;
    (function() {
      JS = require("../platform/js");
      function ReleasedAssetChecker() {
        this._releasedKeys = JS.createMap(true);
        this._dirty = false;
      }
      ReleasedAssetChecker.prototype.setReleased = function(item, releasedKey) {
        this._releasedKeys[releasedKey] = true;
        this._dirty = true;
      };
      tmpInfo = null;
      function getItemDesc(item) {
        if (item.uuid) {
          tmpInfo || (tmpInfo = {
            path: "",
            type: null
          });
          if (cc.loader._resources._getInfo_DEBUG(item.uuid, tmpInfo)) {
            tmpInfo.path = "resources/" + tmpInfo.path;
            return '"' + tmpInfo.path + '" (type: ' + JS.getClassName(tmpInfo.type) + ", uuid: " + item.uuid + ")";
          }
          return '"' + item.rawUrl + '" (' + item.uuid + ")";
        }
        return '"' + item.rawUrl + '"';
      }
      function doCheckCouldRelease(releasedKey, refOwnerItem, caches) {
        var loadedAgain = caches[releasedKey];
        loadedAgain || cc.log('"' + releasedKey + '" was released but maybe still referenced by ' + getItemDesc(refOwnerItem));
      }
      ReleasedAssetChecker.prototype.checkCouldRelease = function(caches) {
        if (!this._dirty) return;
        this._dirty = false;
        var released = this._releasedKeys;
        for (var id in caches) {
          var item = caches[id];
          item.alias && (item = item.alias);
          var depends = item.dependKeys;
          if (depends) for (var i = 0; i < depends.length; ++i) {
            var depend = depends[i];
            if (released[depend]) {
              doCheckCouldRelease(depend, item, caches);
              delete released[depend];
            }
          }
        }
        JS.clear(released);
      };
      module.exports = ReleasedAssetChecker;
    })();
  }), {
    "../platform/js": 109
  } ],
  82: [ (function(require, module, exports) {
    var sys = require("../platform/CCSys");
    false;
    var urlAppendTimestamp = require("./utils").urlAppendTimestamp;
    module.exports = function(item, callback) {
      var url = item.url;
      url = urlAppendTimestamp(url);
      var xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load " + url + " failed!", navigator = window.navigator;
      xhr.open("GET", url, true);
      if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
        xhr.setRequestHeader("Accept-Charset", "utf-8");
        xhr.onreadystatechange = function() {
          4 === xhr.readyState && (200 === xhr.status || 0 === xhr.status ? callback(null, xhr.responseText) : callback({
            status: xhr.status,
            errorMessage: errInfo
          }));
        };
      } else {
        xhr.overrideMimeType && xhr.overrideMimeType("text/plain; charset=utf-8");
        xhr.onload = function() {
          4 === xhr.readyState && (200 === xhr.status || 0 === xhr.status ? callback(null, xhr.responseText) : callback({
            status: xhr.status,
            errorMessage: errInfo
          }));
        };
        xhr.onerror = function() {
          callback({
            status: xhr.status,
            errorMessage: errInfo
          });
        };
      }
      xhr.send(null);
    };
  }), {
    "../platform/CCSys": 97,
    "./utils": 84
  } ],
  83: [ (function(require, module, exports) {
    var Texture2D = require("../textures/CCTexture2D");
    var JS = require("../platform/js");
    function JsonUnpacker() {
      this.jsons = {};
    }
    JsonUnpacker.prototype.load = function(indices, packedJson) {
      packedJson.length !== indices.length && cc.errorID(4915);
      for (var i = 0; i < indices.length; i++) {
        var key = indices[i];
        var json = packedJson[i];
        this.jsons[key] = json;
      }
    };
    JsonUnpacker.prototype.retrieve = function(key) {
      return this.jsons[key] || null;
    };
    function TextureUnpacker() {
      this.contents = {};
    }
    TextureUnpacker.ID = JS._getClassId(Texture2D);
    TextureUnpacker.prototype.load = function(indices, packedJson) {
      var datas = packedJson.data.split("|");
      datas.length !== indices.length && cc.errorID(4915);
      for (var i = 0; i < indices.length; i++) this.contents[indices[i]] = datas[i];
    };
    TextureUnpacker.prototype.retrieve = function(key) {
      var content = this.contents[key];
      return content ? {
        __type__: TextureUnpacker.ID,
        content: content
      } : null;
    };
    false;
    module.exports = {
      JsonUnpacker: JsonUnpacker,
      TextureUnpacker: TextureUnpacker
    };
  }), {
    "../platform/js": 109,
    "../textures/CCTexture2D": 128
  } ],
  84: [ (function(require, module, exports) {
    var _noCacheRex = /\?/;
    module.exports = {
      urlAppendTimestamp: function(url) {
        cc.game.config["noCache"] && "string" === typeof url && (_noCacheRex.test(url) ? url += "&_t=" + (new Date() - 0) : url += "?_t=" + (new Date() - 0));
        return url;
      }
    };
  }), {} ],
  85: [ (function(require, module, exports) {
    var JS = require("../platform/js");
    require("../platform/deserialize");
    var LoadingItems = require("./loading-items");
    function isSceneObj(json) {
      var SCENE_ID = "cc.Scene";
      var PREFAB_ID = "cc.Prefab";
      return json && (json[0] && json[0].__type__ === SCENE_ID || json[1] && json[1].__type__ === SCENE_ID || json[0] && json[0].__type__ === PREFAB_ID);
    }
    function parseDepends(item, asset, tdInfo, deferredLoadRawAssetsInRuntime) {
      var uuidList = tdInfo.uuidList;
      var objList = tdInfo.uuidObjList;
      var propList = tdInfo.uuidPropList;
      var stillUseUrl = tdInfo._stillUseUrl;
      var depends;
      var i, dependUuid;
      var dependKeys = item.dependKeys = [];
      if (deferredLoadRawAssetsInRuntime) {
        depends = [];
        for (i = 0; i < uuidList.length; i++) {
          dependUuid = uuidList[i];
          var obj = objList[i];
          var prop = propList[i];
          var info = cc.AssetLibrary._getAssetInfoInRuntime(dependUuid);
          if (info.raw) {
            var url = info.url;
            obj[prop] = url;
            dependKeys.push(url);
          } else depends.push({
            type: "uuid",
            uuid: dependUuid,
            deferredLoadRaw: true,
            _owner: obj,
            _ownerProp: prop,
            _stillUseUrl: stillUseUrl[i]
          });
        }
      } else {
        depends = new Array(uuidList.length);
        for (i = 0; i < uuidList.length; i++) {
          dependUuid = uuidList[i];
          depends[i] = {
            type: "uuid",
            uuid: dependUuid,
            _owner: objList[i],
            _ownerProp: propList[i],
            _stillUseUrl: stillUseUrl[i]
          };
        }
        asset._native && !asset.constructor.preventPreloadNativeObject && depends.push({
          url: asset.nativeUrl,
          _owner: asset,
          _ownerProp: "_nativeAsset"
        });
      }
      return depends;
    }
    function loadDepends(pipeline, item, asset, depends, callback) {
      item.content = asset;
      var dependKeys = item.dependKeys;
      pipeline.flowInDeps(item, depends, (function(errors, items) {
        var item, missingAssetReporter;
        var itemsMap = items.map;
        for (var src in itemsMap) {
          item = itemsMap[src];
          item.uuid && item.content && (item.content._uuid = item.uuid);
        }
        for (var i = 0; i < depends.length; i++) {
          var dep = depends[i];
          var dependSrc = dep.uuid;
          var dependUrl = dep.url;
          var dependObj = dep._owner;
          var dependProp = dep._ownerProp;
          item = itemsMap[dependUrl];
          if (!item) continue;
          var loadCallbackCtx = dep;
          function loadCallback(item) {
            var value = item.content;
            this._stillUseUrl && (value = value && cc.RawAsset.wasRawAssetType(value.constructor) ? value.nativeUrl : item.rawUrl);
            this._owner[this._ownerProp] = value;
            item.uuid !== asset._uuid && dependKeys.indexOf(item.id) < 0 && dependKeys.push(item.id);
          }
          if (item.complete || item.content) if (item.error) {
            var MissingObjectReporter;
            false;
            cc._throw(item.error);
          } else loadCallback.call(loadCallbackCtx, item); else {
            var queue = LoadingItems.getQueue(item);
            var list = queue._callbackTable[dependSrc];
            list ? list.unshift(loadCallback, loadCallbackCtx) : queue.addListener(dependSrc, loadCallback, loadCallbackCtx);
          }
        }
        false;
        callback(errors, asset);
      }));
    }
    function canDeferredLoad(asset, item, isScene) {
      false, false;
      var res = item.deferredLoadRaw;
      res ? cc.Class.isInstanceOf(asset, cc.Asset) && asset.constructor.preventDeferredLoadDependents && (res = false) : isScene && (asset instanceof cc.SceneAsset || asset instanceof cc.Prefab) && (res = asset.asyncLoadAssets);
      return res;
    }
    var MissingClass;
    function loadUuid(item, callback) {
      false;
      var json;
      if ("string" === typeof item.content) try {
        json = JSON.parse(item.content);
      } catch (e) {
        return new Error(cc._getError(4923, item.id, e.stack));
      } else {
        if ("object" !== typeof item.content) return new Error(cc._getError(4924));
        json = item.content;
      }
      var classFinder;
      var isScene = isSceneObj(json);
      if (isScene) {
        false;
        classFinder = cc._MissingScript.safeFindClass;
      } else classFinder = function(id) {
        var cls = JS._getClassById(id);
        if (cls) return cls;
        cc.warnID(4903, id);
        return Object;
      };
      var tdInfo = cc.deserialize.Details.pool.get();
      var asset;
      try {
        asset = cc.deserialize(json, tdInfo, {
          classFinder: classFinder,
          target: item.existingAsset,
          customEnv: item
        });
      } catch (e) {
        cc.deserialize.Details.pool.put(tdInfo);
        var err = e.stack;
        return new Error(cc._getError(4925, item.id, err));
      }
      asset._uuid = item.uuid;
      false;
      var deferredLoad = canDeferredLoad(asset, item, isScene);
      var depends = parseDepends(item, asset, tdInfo, deferredLoad);
      cc.deserialize.Details.pool.put(tdInfo);
      if (0 === depends.length) return callback(null, asset);
      loadDepends(this.pipeline, item, asset, depends, callback);
    }
    module.exports = loadUuid;
    loadUuid.isSceneObj = isSceneObj;
  }), {
    "../platform/deserialize": 104,
    "../platform/js": 109,
    "./loading-items": 77
  } ],
  86: [ (function(require, module, exports) {
    var CompScheduler = require("./component-scheduler");
    var Flags = require("./platform/CCObject").Flags;
    var JS = require("./platform/js");
    var callerFunctor = false;
    var MAX_POOL_SIZE = 4;
    var IsPreloadStarted = Flags.IsPreloadStarted;
    var IsOnLoadStarted = Flags.IsOnLoadStarted;
    var IsOnLoadCalled = Flags.IsOnLoadCalled;
    var Deactivating = Flags.Deactivating;
    var callPreloadInTryCatch = false;
    var callOnLoadInTryCatch = false;
    var callOnDestroyInTryCatch = false;
    var callResetInTryCatch = false;
    var callOnFocusInTryCatch = false;
    var callOnLostFocusInTryCatch = false;
    var callPreload = function(c) {
      c.__preload();
    };
    var callOnLoad = function(c) {
      c.onLoad();
      c._objFlags |= IsOnLoadCalled;
    };
    var UnsortedInvoker = cc.Class({
      extends: CompScheduler.LifeCycleInvoker,
      add: function(comp) {
        this._zero.array.push(comp);
      },
      remove: function(comp) {
        this._zero.fastRemove(comp);
      },
      cancelInactive: function(flagToClear) {
        CompScheduler.LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
      },
      invoke: function() {
        this._invoke(this._zero);
        this._zero.array.length = 0;
      }
    });
    var invokePreload = CompScheduler.createInvokeImpl(callPreload);
    var invokeOnLoad = CompScheduler.createInvokeImpl(callOnLoad);
    var activateTasksPool = new JS.Pool(MAX_POOL_SIZE);
    activateTasksPool.get = function getActivateTask() {
      var task = this._get() || {
        preload: new UnsortedInvoker(invokePreload),
        onLoad: new CompScheduler.OneOffInvoker(invokeOnLoad),
        onEnable: new CompScheduler.OneOffInvoker(CompScheduler.invokeOnEnable)
      };
      task.preload._zero.i = -1;
      var invoker = task.onLoad;
      invoker._zero.i = -1;
      invoker._neg.i = -1;
      invoker._pos.i = -1;
      invoker = task.onEnable;
      invoker._zero.i = -1;
      invoker._neg.i = -1;
      invoker._pos.i = -1;
      return task;
    };
    function _componentCorrupted(node, comp, index) {
      false;
      comp ? node._removeComponent(comp) : JS.array.removeAt(node._components, index);
    }
    function _onLoadInEditor(comp) {
      if (comp.onLoad && !cc.engine._isPlaying) {
        var focused = Editor.Selection.curActivate("node") === comp.node.uuid;
        focused ? comp.onFocusInEditor && callOnFocusInTryCatch(comp) : comp.onLostFocusInEditor && callOnLostFocusInTryCatch(comp);
      }
      true;
      _Scene.AssetsWatcher.start(comp);
    }
    function ctor() {
      this._activatingStack = [];
    }
    var NodeActivator = cc.Class({
      ctor: ctor,
      reset: ctor,
      _activateNodeRecursively: function(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
        if (node._objFlags & Deactivating) {
          cc.errorID(3816, node.name);
          return;
        }
        node._activeInHierarchy = true;
        var originCount = node._components.length;
        for (var i = 0; i < originCount; ++i) {
          var component = node._components[i];
          if (component instanceof cc.Component) this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker); else {
            _componentCorrupted(node, component, i);
            --i;
            --originCount;
          }
        }
        for (var _i = 0, len = node._children.length; _i < len; ++_i) {
          var child = node._children[_i];
          child._active && this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
        }
        node._onPostActivated(true);
      },
      _deactivateNodeRecursively: function(node) {
        false;
        node._objFlags |= Deactivating;
        node._activeInHierarchy = false;
        var originCount = node._components.length;
        for (var c = 0; c < originCount; ++c) {
          var component = node._components[c];
          if (component._enabled) {
            cc.director._compScheduler.disableComp(component);
            if (node._activeInHierarchy) {
              node._objFlags &= ~Deactivating;
              return;
            }
          }
        }
        for (var i = 0, len = node._children.length; i < len; ++i) {
          var child = node._children[i];
          if (child._activeInHierarchy) {
            this._deactivateNodeRecursively(child);
            if (node._activeInHierarchy) {
              node._objFlags &= ~Deactivating;
              return;
            }
          }
        }
        node._onPostActivated(false);
        node._objFlags &= ~Deactivating;
      },
      activateNode: function(node, active) {
        if (active) {
          var task = activateTasksPool.get();
          this._activatingStack.push(task);
          this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable);
          task.preload.invoke();
          task.onLoad.invoke();
          task.onEnable.invoke();
          this._activatingStack.pop();
          activateTasksPool.put(task);
        } else {
          this._deactivateNodeRecursively(node);
          var stack = this._activatingStack;
          for (var i = 0; i < stack.length; i++) {
            var lastTask = stack[i];
            lastTask.preload.cancelInactive(IsPreloadStarted);
            lastTask.onLoad.cancelInactive(IsOnLoadStarted);
            lastTask.onEnable.cancelInactive();
          }
        }
        node.emit("active-in-hierarchy-changed", node);
      },
      activateComp: function(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
        if (!(comp._objFlags & IsPreloadStarted)) {
          comp._objFlags |= IsPreloadStarted;
          "function" === typeof comp.__preload && (preloadInvoker ? preloadInvoker.add(comp) : comp.__preload());
        }
        if (!(comp._objFlags & IsOnLoadStarted)) {
          comp._objFlags |= IsOnLoadStarted;
          if (comp.onLoad) if (onLoadInvoker) onLoadInvoker.add(comp); else {
            comp.onLoad();
            comp._objFlags |= IsOnLoadCalled;
          } else comp._objFlags |= IsOnLoadCalled;
        }
        if (comp._enabled) {
          var deactivatedOnLoading = !comp.node._activeInHierarchy;
          if (deactivatedOnLoading) return;
          cc.director._compScheduler.enableComp(comp, onEnableInvoker);
        }
      },
      destroyComp: function(comp) {
        cc.director._compScheduler.disableComp(comp);
        comp.onDestroy && comp._objFlags & IsOnLoadCalled && comp.onDestroy();
      },
      resetComp: false
    });
    module.exports = NodeActivator;
  }), {
    "./component-scheduler": 37,
    "./platform/CCObject": 95,
    "./platform/js": 109,
    "./utils/misc": 137
  } ],
  87: [ (function(require, module, exports) {
    var js;
    var macro;
    var sys;
    var eventManager;
    var TOUCH_TIMEOUT;
    var bkInputManager;
    false;
  }), {
    "../event-manager": 58,
    "../platform/js": 109,
    "./CCMacro": 94,
    "./CCSys": 97
  } ],
  88: [ (function(require, module, exports) {
    var Asset = require("../assets/CCAsset");
    var callInNextTick = require("./utils").callInNextTick;
    var Loader = require("../load-pipeline/CCLoader");
    var PackDownloader = require("../load-pipeline/pack-downloader");
    var AutoReleaseUtils = require("../load-pipeline/auto-release-utils");
    var decodeUuid = require("../utils/decode-uuid");
    var MD5Pipe = require("../load-pipeline/md5-pipe");
    var _libraryBase = "";
    var _rawAssetsBase = "";
    var _uuidToRawAsset = {};
    function isScene(asset) {
      return asset && (asset.constructor === cc.SceneAsset || asset instanceof cc.Scene);
    }
    function RawAssetEntry(url, type) {
      this.url = url;
      this.type = type;
    }
    var AssetLibrary = {
      loadAsset: function(uuid, callback, options) {
        if ("string" !== typeof uuid) return callInNextTick(callback, new Error("[AssetLibrary] uuid must be string"), null);
        var item = {
          uuid: uuid,
          type: "uuid"
        };
        options && options.existingAsset && (item.existingAsset = options.existingAsset);
        Loader.load(item, (function(error, asset) {
          if (error || !asset) error = new Error("[AssetLibrary] loading JSON or dependencies failed: " + (error ? error.message : "Unknown error")); else {
            if (asset.constructor === cc.SceneAsset) {
              false;
              var key = cc.loader._getReferenceKey(uuid);
              asset.scene.dependAssets = AutoReleaseUtils.getDependsRecursively(key);
            }
            if (false, isScene(asset)) {
              var id = cc.loader._getReferenceKey(uuid);
              Loader.removeItem(id);
            }
          }
          callback && callback(error, asset);
        }));
      },
      getLibUrlNoExt: function(uuid, inRawAssetsDir) {
        true;
        uuid = decodeUuid(uuid);
        var base = (true, inRawAssetsDir ? _rawAssetsBase + "assets/" : _libraryBase);
        return base + uuid.slice(0, 2) + "/" + uuid;
      },
      _queryAssetInfoInEditor: function(uuid, callback) {
        false;
      },
      _getAssetInfoInRuntime: function(uuid, result) {
        result = result || {
          url: null,
          raw: false
        };
        var info = _uuidToRawAsset[uuid];
        if (info && !cc.isChildClassOf(info.type, cc.Asset)) {
          result.url = _rawAssetsBase + info.url;
          result.raw = true;
        } else {
          result.url = this.getLibUrlNoExt(uuid) + ".json";
          result.raw = false;
        }
        return result;
      },
      _uuidInSettings: function(uuid) {
        return uuid in _uuidToRawAsset;
      },
      queryAssetInfo: function(uuid, callback) {
        false;
        var info = this._getAssetInfoInRuntime(uuid);
        callback(null, info.url, info.raw);
      },
      parseUuidInEditor: function(url) {
        var uuid;
        var isImported;
        var dir;
        var dirBasename;
        var isAssetUrl;
        var index;
        false;
      },
      loadJson: function(json, callback) {
        var randomUuid = "" + (new Date().getTime() + Math.random());
        var item = {
          uuid: randomUuid,
          type: "uuid",
          content: json,
          skips: [ Loader.assetLoader.id, Loader.downloader.id ]
        };
        Loader.load(item, (function(error, asset) {
          if (error) error = new Error("[AssetLibrary] loading JSON or dependencies failed: " + error.message); else {
            if (asset.constructor === cc.SceneAsset) {
              var key = cc.loader._getReferenceKey(randomUuid);
              asset.scene.dependAssets = AutoReleaseUtils.getDependsRecursively(key);
            }
            if (false, isScene(asset)) {
              var id = cc.loader._getReferenceKey(randomUuid);
              Loader.removeItem(id);
            }
          }
          asset._uuid = "";
          callback && callback(error, asset);
        }));
      },
      getAssetByUuid: function(uuid) {
        return AssetLibrary._uuidToAsset[uuid] || null;
      },
      init: function(options) {
        false;
        var libraryPath = options.libraryPath;
        libraryPath = libraryPath.replace(/\\/g, "/");
        _libraryBase = cc.path.stripSep(libraryPath) + "/";
        _rawAssetsBase = options.rawAssetsBase;
        var md5AssetsMap = options.md5AssetsMap;
        if (md5AssetsMap) {
          var md5Pipe = new MD5Pipe(md5AssetsMap, _libraryBase, _rawAssetsBase);
          cc.loader.insertPipeAfter(cc.loader.assetLoader, md5Pipe);
          cc.loader.md5Pipe = md5Pipe;
        }
        var resources = Loader._resources;
        resources.reset();
        var rawAssets = options.rawAssets;
        if (rawAssets) for (var mountPoint in rawAssets) {
          var assets = rawAssets[mountPoint];
          for (var uuid in assets) {
            var info = assets[uuid];
            var url = info[0];
            var typeId = info[1];
            var type = cc.js._getClassById(typeId);
            if (!type) {
              cc.error("Cannot get", typeId);
              continue;
            }
            _uuidToRawAsset[uuid] = new RawAssetEntry(mountPoint + "/" + url, type);
            if ("assets" === mountPoint) {
              var ext = cc.path.extname(url);
              ext && (url = url.slice(0, -ext.length));
              var isSubAsset = 1 === info[2];
              resources.add(url, uuid, type, !isSubAsset);
            }
          }
        }
        options.packedAssets && PackDownloader.initPacks(options.packedAssets);
        cc.url._init(options.mountPaths && options.mountPaths.assets || _rawAssetsBase + "assets");
      }
    };
    AssetLibrary._uuidToAsset = {};
    module.exports = cc.AssetLibrary = AssetLibrary;
  }), {
    "../assets/CCAsset": 18,
    "../load-pipeline/CCLoader": 69,
    "../load-pipeline/auto-release-utils": 73,
    "../load-pipeline/md5-pipe": 78,
    "../load-pipeline/pack-downloader": 79,
    "../utils/decode-uuid": 134,
    "./utils": 113
  } ],
  89: [ (function(require, module, exports) {
    var JS = require("./js");
    var Enum = require("./CCEnum");
    var Utils = require("./utils");
    var _isPlainEmptyObj_DEV = Utils.isPlainEmptyObj_DEV;
    var _cloneable_DEV = Utils.cloneable_DEV;
    var Attr = require("./attribute");
    var DELIMETER = Attr.DELIMETER;
    var getTypeChecker = Attr.getTypeChecker;
    var preprocess = require("./preprocess-class");
    require("./requiring-frame");
    var BUILTIN_ENTRIES = [ "name", "extends", "mixins", "ctor", "__ctor__", "properties", "statics", "editor", "__ES6__" ];
    var INVALID_STATICS_DEV = false;
    function pushUnique(array, item) {
      array.indexOf(item) < 0 && array.push(item);
    }
    var deferredInitializer = {
      datas: null,
      push: function(data) {
        if (this.datas) this.datas.push(data); else {
          this.datas = [ data ];
          var self = this;
          setTimeout((function() {
            self.init();
          }), 0);
        }
      },
      init: function() {
        var datas = this.datas;
        if (datas) {
          for (var i = 0; i < datas.length; ++i) {
            var data = datas[i];
            var cls = data.cls;
            var properties = data.props;
            "function" === typeof properties && (properties = properties());
            var name = JS.getClassName(cls);
            properties ? declareProperties(cls, name, properties, cls.$super, data.mixins) : cc.errorID(3633, name);
          }
          this.datas = null;
        }
      }
    };
    function appendProp(cls, name) {
      false;
      pushUnique(cls.__props__, name);
    }
    var tmpArray = [];
    function defineProp(cls, className, propName, val, es6) {
      var defaultValue = val.default;
      false;
      Attr.setClassAttr(cls, propName, "default", defaultValue);
      appendProp(cls, propName);
      var attrs = parseAttributes(cls, val, className, propName, false);
      if (attrs) {
        var onAfterProp = tmpArray;
        for (var i = 0; i < attrs.length; i++) {
          var attr = attrs[i];
          Attr.attr(cls, propName, attr);
          attr._onAfterProp && onAfterProp.push(attr._onAfterProp);
        }
        for (var c = 0; c < onAfterProp.length; c++) onAfterProp[c](cls, propName);
        tmpArray.length = 0;
        attrs.length = 0;
      }
    }
    function defineGetSet(cls, name, propName, val, es6) {
      var getter = val.get;
      var setter = val.set;
      var proto = cls.prototype;
      var d = Object.getOwnPropertyDescriptor(proto, propName);
      var setterUndefined = !d;
      if (getter) {
        false;
        var attrs = parseAttributes(cls, val, name, propName, true);
        for (var i = 0; i < attrs.length; i++) Attr.attr(cls, propName, attrs[i]);
        attrs.length = 0;
        var ForceSerializable = false;
        ForceSerializable || Attr.setClassAttr(cls, propName, "serializable", false);
        !!ForceSerializable && appendProp(cls, propName);
        es6 || JS.get(proto, propName, getter, setterUndefined, setterUndefined);
        false, false;
      }
      if (setter) {
        if (!es6) {
          false;
          JS.set(proto, propName, setter, setterUndefined, setterUndefined);
        }
        false, false;
      }
    }
    function getDefault(defaultVal) {
      if ("function" === typeof defaultVal) {
        false;
        return defaultVal();
      }
      return defaultVal;
    }
    function mixinWithInherited(dest, src, filter) {
      for (var prop in src) dest.hasOwnProperty(prop) || filter && !filter(prop) || Object.defineProperty(dest, prop, JS.getPropertyDescriptor(src, prop));
    }
    function doDefine(className, baseClass, mixins, options) {
      var shouldAddProtoCtor;
      var __ctor__ = options.__ctor__;
      var ctor = options.ctor;
      var __es6__ = options.__ES6__;
      var ctorToUse;
      false;
      var ctors;
      var fireClass;
      if (__es6__) {
        ctors = [ ctor ];
        fireClass = ctor;
      } else {
        ctors = __ctor__ ? [ __ctor__ ] : _getAllCtors(baseClass, mixins, options);
        fireClass = _createCtor(ctors, baseClass, className, options);
        JS.value(fireClass, "extend", (function(options) {
          options.extends = this;
          return CCClass(options);
        }), true);
      }
      JS.value(fireClass, "__ctors__", ctors.length > 0 ? ctors : null, true);
      var prototype = fireClass.prototype;
      if (baseClass) {
        if (!__es6__) {
          JS.extend(fireClass, baseClass);
          prototype = fireClass.prototype;
        }
        fireClass.$super = baseClass;
        false;
      }
      if (mixins) {
        for (var m = mixins.length - 1; m >= 0; m--) {
          var mixin = mixins[m];
          mixinWithInherited(prototype, mixin.prototype);
          mixinWithInherited(fireClass, mixin, (function(prop) {
            return mixin.hasOwnProperty(prop) && true;
          }));
          CCClass._isCCClass(mixin) && mixinWithInherited(Attr.getClassAttrs(fireClass).constructor.prototype, Attr.getClassAttrs(mixin).constructor.prototype);
        }
        prototype.constructor = fireClass;
      }
      __es6__ || (prototype.__initProps__ = compileProps);
      JS.setClassName(className, fireClass);
      return fireClass;
    }
    function define(className, baseClass, mixins, options) {
      var Component = cc.Component;
      var frame = cc._RF.peek();
      if (frame && cc.isChildClassOf(baseClass, Component)) {
        if (cc.isChildClassOf(frame.cls, Component)) {
          cc.errorID(3615);
          return null;
        }
        false;
        className = className || frame.script;
      }
      var cls = doDefine(className, baseClass, mixins, options);
      if (frame) if (cc.isChildClassOf(baseClass, Component)) {
        var uuid = frame.uuid;
        if (uuid) {
          JS._setClassId(uuid, cls);
          false;
        }
        frame.cls = cls;
      } else cc.isChildClassOf(frame.cls, Component) || (frame.cls = cls);
      return cls;
    }
    function normalizeClassName_DEV(className) {
      var DefaultName = "CCClass";
      if (className) {
        className = className.replace(/^[^$A-Za-z_]/, "_").replace(/[^0-9A-Za-z_$]/g, "_");
        try {
          Function("function " + className + "(){}")();
          return className;
        } catch (e) {}
      }
      return DefaultName;
    }
    function getNewValueTypeCode(value) {
      var clsName = JS.getClassName(value);
      var type = value.constructor;
      var res = "new " + clsName + "(";
      for (var i = 0; i < type.__props__.length; i++) {
        var prop = type.__props__[i];
        var propVal = value[prop];
        if ("object" === typeof propVal) {
          cc.errorID(3641, clsName);
          return "new " + clsName + "()";
        }
        res += propVal;
        i < type.__props__.length - 1 && (res += ",");
      }
      return res + ")";
    }
    function getNewValueType(value) {
      var clsName = JS.getClassName(value);
      var type = value.constructor;
      var res = new type();
      for (var i = 0; i < type.__props__.length; i++) {
        var prop = type.__props__[i];
        var propVal = value[prop];
        if ("object" === typeof propVal) {
          cc.errorID(3641, clsName);
          return res;
        }
        res[prop] = propVal;
      }
      return res;
    }
    function escapeForJS(s) {
      return JSON.stringify(s).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    function getInitPropsJit(attrs, propList) {
      var F = [];
      var func = "";
      for (var i = 0; i < propList.length; i++) {
        var prop = propList[i];
        var attrKey = prop + DELIMETER + "default";
        if (attrKey in attrs) {
          var statement;
          statement = IDENTIFIER_RE.test(prop) ? "this." + prop + "=" : "this[" + escapeForJS(prop) + "]=";
          var expression;
          var def = attrs[attrKey];
          if ("object" === typeof def && def) expression = def instanceof cc.ValueType ? getNewValueTypeCode(def) : Array.isArray(def) ? "[]" : "{}"; else if ("function" === typeof def) {
            var index = F.length;
            F.push(def);
            expression = "F[" + index + "]()";
            false;
          } else expression = "string" === typeof def ? escapeForJS(def) : def;
          statement = statement + expression + ";\n";
          func += statement;
        }
      }
      var initProps;
      initProps = 0 === F.length ? Function(func) : Function("F", "return (function(){\n" + func + "})")(F);
      return initProps;
    }
    function getInitProps(attrs, propList) {
      function func() {
        var F = [];
        for (var i = 0; i < propList.length; i++) {
          var prop = propList[i];
          var attrKey = prop + DELIMETER + "default";
          if (attrKey in attrs) {
            var expression;
            var def = attrs[attrKey];
            if ("object" === typeof def && def) expression = def instanceof cc.ValueType ? getNewValueType(def) : Array.isArray(def) ? [] : {}; else if ("function" === typeof def) {
              var index = F.length;
              F.push(def);
              expression = F[index]();
              false;
            } else expression = def;
            this[prop] = expression;
          }
        }
      }
      return func;
    }
    var IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/;
    function compileProps(actualClass) {
      var attrs = Attr.getClassAttrs(actualClass);
      var propList = actualClass.__props__;
      if (null === propList) {
        deferredInitializer.init();
        propList = actualClass.__props__;
      }
      var initProps = getInitProps(attrs, propList);
      actualClass.prototype.__initProps__ = initProps;
      initProps.call(this);
    }
    var _createCtor = function(ctors, baseClass, className, options) {
      var superCallBounded = baseClass && boundSuperCalls(baseClass, options, className);
      return function CCClass() {
        superCallBounded && (this._super = null);
        this.__initProps__(CCClass);
        var ctorLen = ctors.length;
        var cs = CCClass.__ctors__;
        if (ctorLen > 0) {
          var useTryCatch = !(className && className.startsWith("cc."));
          if (useTryCatch) try {
            if (1 === ctorLen) cs[0].apply(this, arguments); else for (var i = 0; i < ctorLen; i++) cs[i].apply(this, arguments);
          } catch (e) {
            cc._throw(e);
          } else if (1 === ctorLen) cs[0].apply(this, arguments); else for (var _i = 0; _i < ctorLen; _i++) cs[_i].apply(this, arguments);
        }
      };
    };
    function _validateCtor_DEV(ctor, baseClass, className, options) {
      var originCtor;
      false;
      !(ctor.length > 0) || className && className.startsWith("cc.") || cc.warnID(3617, className);
      return ctor;
    }
    function _getAllCtors(baseClass, mixins, options) {
      function getCtors(cls) {
        return CCClass._isCCClass(cls) ? cls.__ctors__ || [] : [ cls ];
      }
      var ctors = [];
      var baseOrMixins = [ baseClass ].concat(mixins);
      for (var b = 0; b < baseOrMixins.length; b++) {
        var baseOrMixin = baseOrMixins[b];
        if (baseOrMixin) {
          var baseCtors = getCtors(baseOrMixin);
          for (var c = 0; c < baseCtors.length; c++) pushUnique(ctors, baseCtors[c]);
        }
      }
      var ctor = options.ctor;
      ctor && ctors.push(ctor);
      return ctors;
    }
    var SuperCallReg = /xyz/.test((function() {
      xyz;
    })) ? /\b\._super\b/ : /.*/;
    var SuperCallRegStrict = /xyz/.test((function() {
      xyz;
    })) ? /this\._super\s*\(/ : /(NONE){99}/;
    function boundSuperCalls(baseClass, options, className) {
      var hasSuperCall = false;
      for (var funcName in options) {
        if (BUILTIN_ENTRIES.indexOf(funcName) >= 0) continue;
        var func = options[funcName];
        if ("function" !== typeof func) continue;
        var pd = JS.getPropertyDescriptor(baseClass.prototype, funcName);
        if (pd) {
          var superFunc = pd.value;
          if ("function" === typeof superFunc) {
            if (SuperCallReg.test(func)) {
              hasSuperCall = true;
              options[funcName] = (function(superFunc, func) {
                return function() {
                  var tmp = this._super;
                  this._super = superFunc;
                  var ret = func.apply(this, arguments);
                  this._super = tmp;
                  return ret;
                };
              })(superFunc, func);
            }
            continue;
          }
        }
        false;
      }
      return hasSuperCall;
    }
    function declareProperties(cls, className, properties, baseClass, mixins, es6) {
      cls.__props__ = [];
      baseClass && baseClass.__props__ && (cls.__props__ = baseClass.__props__.slice());
      if (mixins) for (var m = 0; m < mixins.length; ++m) {
        var mixin = mixins[m];
        mixin.__props__ && (cls.__props__ = cls.__props__.concat(mixin.__props__.filter((function(x) {
          return cls.__props__.indexOf(x) < 0;
        }))));
      }
      if (properties) {
        preprocess.preprocessAttrs(properties, className, cls, es6);
        for (var propName in properties) {
          var val = properties[propName];
          "default" in val ? defineProp(cls, className, propName, val, es6) : defineGetSet(cls, className, propName, val, es6);
        }
      }
    }
    function CCClass(options) {
      options = options || {};
      var name = options.name;
      var base = options.extends;
      var mixins = options.mixins;
      var cls = define(name, base, mixins, options);
      name || (name = cc.js.getClassName(cls));
      cls._sealed = true;
      base && (base._sealed = false);
      var properties = options.properties;
      if ("function" === typeof properties || base && null === base.__props__ || mixins && mixins.some((function(x) {
        return null === x.__props__;
      }))) {
        false;
        deferredInitializer.push({
          cls: cls,
          props: properties,
          mixins: mixins
        });
        cls.__props__ = null;
      } else declareProperties(cls, name, properties, base, options.mixins, options.__ES6__);
      var statics = options.statics;
      if (statics) {
        var staticPropName;
        false;
        for (staticPropName in statics) cls[staticPropName] = statics[staticPropName];
      }
      for (var funcName in options) {
        if (BUILTIN_ENTRIES.indexOf(funcName) >= 0) continue;
        var func = options[funcName];
        if (!preprocess.validateMethodWithProps(func, funcName, name, cls, base)) continue;
        JS.value(cls.prototype, funcName, func, true, true);
      }
      var editor = options.editor;
      editor && !!cc.isChildClassOf(base, cc.Component) && cc.Component._registerEditorProps(cls, editor);
      return cls;
    }
    CCClass._isCCClass = function(constructor) {
      return constructor && constructor.hasOwnProperty("__ctors__");
    };
    CCClass._fastDefine = function(className, constructor, serializableFields) {
      JS.setClassName(className, constructor);
      var props = constructor.__props__ = Object.keys(serializableFields);
      var attrProtos = Attr.getClassAttrsProto(constructor);
      for (var i = 0; i < props.length; i++) {
        var key = props[i];
        attrProtos[key + DELIMETER + "visible"] = false;
        attrProtos[key + DELIMETER + "default"] = serializableFields[key];
      }
    };
    CCClass.Attr = Attr;
    CCClass.attr = Attr.attr;
    cc.isChildClassOf = function(subclass, superclass) {
      if (subclass && superclass) {
        if ("function" !== typeof subclass) return false;
        if ("function" !== typeof superclass) {
          false;
          return false;
        }
        if (subclass === superclass) return true;
        for (;;) {
          subclass = JS.getSuper(subclass);
          if (!subclass) return false;
          if (subclass === superclass) return true;
        }
      }
      return false;
    };
    CCClass.getInheritanceChain = function(klass) {
      var chain = [];
      for (;;) {
        klass = JS.getSuper(klass);
        if (!klass) break;
        klass !== Object && chain.push(klass);
      }
      return chain;
    };
    CCClass.isInstanceOf = function(obj__skip_jsb_warning, klass) {
      return obj__skip_jsb_warning instanceof klass;
    };
    var PrimitiveTypes = {
      Integer: "Number",
      Float: "Number",
      Boolean: "Boolean",
      String: "String"
    };
    var tmpAttrs = [];
    function parseAttributes(cls, attrs, className, propName, usedInGetter) {
      var ERR_Type = "";
      var attrsProto = null;
      var attrsProtoKey = "";
      function getAttrsProto() {
        attrsProtoKey = propName + DELIMETER;
        return attrsProto = Attr.getClassAttrsProto(cls);
      }
      tmpAttrs.length = 0;
      var result = tmpAttrs;
      var type = attrs.type;
      if (type) {
        var primitiveType = PrimitiveTypes[type];
        if (primitiveType) result.push({
          type: type,
          _onAfterProp: getTypeChecker(primitiveType, "cc." + type)
        }); else if ("Object" === type) false; else if (type === Attr.ScriptUuid) {
          var attr = Attr.ObjectType(cc.ScriptAsset);
          attr.type = "Script";
          result.push(attr);
        } else "object" === typeof type ? !!Enum.isEnum(type) && result.push({
          type: "Enum",
          enumList: Enum.getList(type)
        }) : "function" === typeof type && (attrs.url ? result.push({
          type: "Object",
          ctor: type,
          _onAfterProp: getTypeChecker("String", "cc.String")
        }) : result.push(attrs._short ? {
          type: "Object",
          ctor: type
        } : Attr.ObjectType(type)));
      }
      function parseSimpleAttr(attrName, expectType) {
        if (attrName in attrs) {
          var val = attrs[attrName];
          typeof val === expectType && ((attrsProto || getAttrsProto())[attrsProtoKey + attrName] = val);
        }
      }
      if (attrs.editorOnly) {
        false;
        (attrsProto || getAttrsProto())[attrsProtoKey + "editorOnly"] = true;
      }
      false;
      attrs.url && ((attrsProto || getAttrsProto())[attrsProtoKey + "saveUrlAsAsset"] = true);
      if (false === attrs.serializable) {
        false;
        (attrsProto || getAttrsProto())[attrsProtoKey + "serializable"] = false;
      }
      parseSimpleAttr("formerlySerializedAs", "string");
      false;
      var visible;
      var startsWithUS;
      false;
      var range = attrs.range;
      if (range) if (Array.isArray(range)) if (range.length >= 2) {
        (attrsProto || getAttrsProto())[attrsProtoKey + "min"] = range[0];
        attrsProto[attrsProtoKey + "max"] = range[1];
        range.length > 2 && (attrsProto[attrsProtoKey + "step"] = range[2]);
      } else false; else false;
      parseSimpleAttr("min", "number");
      parseSimpleAttr("max", "number");
      parseSimpleAttr("step", "number");
      return result;
    }
    cc.Class = CCClass;
    module.exports = {
      isArray: function(defaultVal) {
        defaultVal = getDefault(defaultVal);
        return Array.isArray(defaultVal);
      },
      fastDefine: CCClass._fastDefine,
      getNewValueTypeCode: getNewValueTypeCode,
      IDENTIFIER_RE: IDENTIFIER_RE,
      escapeForJS: escapeForJS,
      getDefault: getDefault
    };
    false;
  }), {
    "./CCEnum": 91,
    "./attribute": 101,
    "./js": 109,
    "./preprocess-class": 110,
    "./requiring-frame": 111,
    "./utils": 113
  } ],
  90: [ (function(require, module, exports) {
    require("./CCClass");
    var Preprocess = require("./preprocess-class");
    var JS = require("./js");
    var isPlainEmptyObj_DEV = false;
    var CACHE_KEY = "__ccclassCache__";
    function fNOP(ctor) {
      return ctor;
    }
    function getSubDict(obj, key) {
      return obj[key] || (obj[key] = {});
    }
    function checkCtorArgument(decorate) {
      return function(target) {
        if ("function" === typeof target) return decorate(target);
        return function(ctor) {
          return decorate(ctor, target);
        };
      };
    }
    function _checkNormalArgument(validator_DEV, decorate, decoratorName) {
      return function(target) {
        false;
        return function(ctor) {
          return decorate(ctor, target);
        };
      };
    }
    var checkCompArgument = _checkNormalArgument.bind(null, false);
    function _argumentChecker(type) {
      return _checkNormalArgument.bind(null, false);
    }
    var checkStringArgument = _argumentChecker("string");
    var checkNumberArgument = _argumentChecker("number");
    function getClassCache(ctor, decoratorName) {
      false;
      return getSubDict(ctor, CACHE_KEY);
    }
    function getDefaultFromInitializer(initializer) {
      var value;
      try {
        value = initializer();
      } catch (e) {
        return initializer;
      }
      return "object" !== typeof value || null === value ? value : initializer;
    }
    function extractActualDefaultValues(ctor) {
      var dummyObj;
      try {
        dummyObj = new ctor();
      } catch (e) {
        false;
        return {};
      }
      return dummyObj;
    }
    function genProperty(ctor, properties, propName, options, desc, cache) {
      var fullOptions;
      if (options) {
        fullOptions = Preprocess.getFullFormOfProperty(options);
        fullOptions = fullOptions || options;
      }
      var existsProperty = properties[propName];
      var prop = JS.mixin(existsProperty || {}, fullOptions || {});
      var isGetset = desc && (desc.get || desc.set);
      if (isGetset) {
        var errorProps;
        false;
        desc.get && (prop.get = desc.get);
        desc.set && (prop.set = desc.set);
      } else {
        false;
        var defaultValue = void 0;
        var isDefaultValueSpecified = false;
        if (desc) {
          if (desc.initializer) {
            defaultValue = getDefaultFromInitializer(desc.initializer);
            isDefaultValueSpecified = true;
          }
        } else {
          var actualDefaultValues = cache.default || (cache.default = extractActualDefaultValues(ctor));
          if (actualDefaultValues.hasOwnProperty(propName)) {
            defaultValue = actualDefaultValues[propName];
            isDefaultValueSpecified = true;
          }
        }
        false;
        prop.default = defaultValue;
      }
      properties[propName] = prop;
    }
    var ccclass = checkCtorArgument((function(ctor, name) {
      var base = JS.getSuper(ctor);
      base === Object && (base = null);
      var proto = {
        name: name,
        extends: base,
        ctor: ctor,
        __ES6__: true
      };
      var cache = ctor[CACHE_KEY];
      if (cache) {
        var decoratedProto = cache.proto;
        decoratedProto && JS.mixin(proto, decoratedProto);
        ctor[CACHE_KEY] = void 0;
      }
      var res = cc.Class(proto);
      var propNames;
      var i;
      var prop;
      var desc;
      var func;
      false;
      return res;
    }));
    function property(ctorProtoOrOptions, propName, desc) {
      var options = null;
      function normalized(ctorProto, propName, desc) {
        var cache = getClassCache(ctorProto.constructor);
        if (cache) {
          var ccclassProto = getSubDict(cache, "proto");
          var properties = getSubDict(ccclassProto, "properties");
          genProperty(ctorProto.constructor, properties, propName, options, desc, cache);
        }
      }
      if ("undefined" === typeof propName) {
        options = ctorProtoOrOptions;
        return normalized;
      }
      normalized(ctorProtoOrOptions, propName, desc);
    }
    function createEditorDecorator(argCheckFunc, editorPropName, staticValue) {
      return argCheckFunc((function(ctor, decoratedValue) {
        var cache = getClassCache(ctor, editorPropName);
        if (cache) {
          var value = void 0 !== staticValue ? staticValue : decoratedValue;
          var proto = getSubDict(cache, "proto");
          getSubDict(proto, "editor")[editorPropName] = value;
        }
      }), editorPropName);
    }
    function createDummyDecorator(argCheckFunc) {
      return argCheckFunc(fNOP);
    }
    var executeInEditMode = createDummyDecorator(checkCtorArgument, "executeInEditMode", true);
    var requireComponent = createEditorDecorator(checkCompArgument, "requireComponent");
    var menu = createDummyDecorator(checkStringArgument, "menu");
    var executionOrder = createEditorDecorator(checkNumberArgument, "executionOrder");
    var disallowMultiple = createDummyDecorator(checkCtorArgument, "disallowMultiple");
    var playOnFocus = createDummyDecorator(checkCtorArgument, "playOnFocus");
    var inspector = createDummyDecorator(checkStringArgument, "inspector");
    var icon = createDummyDecorator(checkStringArgument, "icon");
    var help = createDummyDecorator(checkStringArgument, "help");
    function mixins() {
      var mixins = [];
      for (var i = 0; i < arguments.length; i++) mixins[i] = arguments[i];
      return function(ctor) {
        var cache = getClassCache(ctor, "mixins");
        cache && (getSubDict(cache, "proto").mixins = mixins);
      };
    }
    cc._decorator = module.exports = {
      ccclass: ccclass,
      property: property,
      executeInEditMode: executeInEditMode,
      requireComponent: requireComponent,
      menu: menu,
      executionOrder: executionOrder,
      disallowMultiple: disallowMultiple,
      playOnFocus: playOnFocus,
      inspector: inspector,
      icon: icon,
      help: help,
      mixins: mixins
    };
  }), {
    "./CCClass": 89,
    "./js": 109,
    "./preprocess-class": 110,
    "./utils": 113
  } ],
  91: [ (function(require, module, exports) {
    var JS = require("./js");
    function Enum(obj) {
      if ("__enums__" in obj) return obj;
      JS.value(obj, "__enums__", null, true);
      var lastIndex = -1;
      var keys = Object.keys(obj);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var val = obj[key];
        if (-1 === val) {
          val = ++lastIndex;
          obj[key] = val;
        } else if ("number" === typeof val) lastIndex = val; else if ("string" === typeof val && Number.isInteger(parseFloat(key))) continue;
        var reverseKey = "" + val;
        if (key !== reverseKey) {
          if ((false, false) && reverseKey in obj && obj[reverseKey] !== key) {
            cc.errorID(7100, reverseKey);
            continue;
          }
          JS.value(obj, reverseKey, key);
        }
      }
      return obj;
    }
    Enum.isEnum = function(enumType) {
      return enumType && enumType.hasOwnProperty("__enums__");
    };
    Enum.getList = function(enumDef) {
      if (enumDef.__enums__) return enumDef.__enums__;
      var enums = enumDef.__enums__ = [];
      for (var name in enumDef) {
        var value = enumDef[name];
        Number.isInteger(value) && enums.push({
          name: name,
          value: value
        });
      }
      enums.sort((function(a, b) {
        return a.value - b.value;
      }));
      return enums;
    };
    var _TestEnum;
    false;
    module.exports = cc.Enum = Enum;
  }), {
    "./js": 109
  } ],
  92: [ (function(require, module, exports) {
    cc.ClassManager || require("./_CCClass");
    var eventManager = require("../event-manager");
    var inputManager = require("./CCInputManager");
    inputManager.__instanceId = cc.ClassManager.getNewInstanceId();
    var _didAccelerateFun;
    inputManager.setAccelerometerEnabled = function(isEnable) {
      var _t = this;
      if (_t._accelEnabled === isEnable) return;
      _t._accelEnabled = isEnable;
      var scheduler = cc.director.getScheduler();
      if (_t._accelEnabled) {
        _t._registerAccelerometerEvent();
        _t._accelCurTime = 0;
        scheduler.scheduleUpdate(_t);
      } else {
        _t._unregisterAccelerometerEvent();
        _t._accelCurTime = 0;
        scheduler.unscheduleUpdate(_t);
      }
    };
    inputManager.setAccelerometerInterval = function(interval) {
      this._accelInterval !== interval && (this._accelInterval = interval);
    };
    inputManager._registerKeyboardEvent = function() {
      cc.game.canvas.addEventListener("keydown", (function(e) {
        eventManager.dispatchEvent(new cc.Event.EventKeyboard(e.keyCode, true));
        e.stopPropagation();
        e.preventDefault();
      }), false);
      cc.game.canvas.addEventListener("keyup", (function(e) {
        eventManager.dispatchEvent(new cc.Event.EventKeyboard(e.keyCode, false));
        e.stopPropagation();
        e.preventDefault();
      }), false);
    };
    inputManager._registerAccelerometerEvent = function() {
      var w = window, _t = this;
      _t._acceleration = new cc.Acceleration();
      _t._accelDeviceEvent = w.DeviceMotionEvent || w.DeviceOrientationEvent;
      cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (_t._accelDeviceEvent = window.DeviceOrientationEvent);
      var _deviceEventType = _t._accelDeviceEvent === w.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
      var ua = navigator.userAgent;
      (/Android/.test(ua) || /Adr/.test(ua) && cc.sys.browserType === cc.BROWSER_TYPE_UC) && (_t._minus = -1);
      _didAccelerateFun = _t.didAccelerate.bind(_t);
      w.addEventListener(_deviceEventType, _didAccelerateFun, false);
    };
    inputManager._unregisterAccelerometerEvent = function() {
      var w = window, _t = this;
      var _deviceEventType = _t._accelDeviceEvent === w.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
      _didAccelerateFun && w.removeEventListener(_deviceEventType, _didAccelerateFun, false);
    };
    inputManager.didAccelerate = function(eventData) {
      var _t = this, w = window;
      if (!_t._accelEnabled) return;
      var mAcceleration = _t._acceleration;
      var x, y, z;
      if (_t._accelDeviceEvent === window.DeviceMotionEvent) {
        var eventAcceleration = eventData["accelerationIncludingGravity"];
        x = _t._accelMinus * eventAcceleration.x * .1;
        y = _t._accelMinus * eventAcceleration.y * .1;
        z = .1 * eventAcceleration.z;
      } else {
        x = eventData["gamma"] / 90 * .981;
        y = -eventData["beta"] / 90 * .981;
        z = eventData["alpha"] / 90 * .981;
      }
      mAcceleration.x = x;
      mAcceleration.y = y;
      mAcceleration.z = z;
      mAcceleration.timestamp = eventData.timeStamp || Date.now();
      var tmpX = mAcceleration.x;
      if (w.orientation === cc.macro.WEB_ORIENTATION_LANDSCAPE_RIGHT) {
        mAcceleration.x = -mAcceleration.y;
        mAcceleration.y = tmpX;
      } else if (w.orientation === cc.macro.WEB_ORIENTATION_LANDSCAPE_LEFT) {
        mAcceleration.x = mAcceleration.y;
        mAcceleration.y = -tmpX;
      } else if (w.orientation === cc.macro.WEB_ORIENTATION_PORTRAIT_UPSIDE_DOWN) {
        mAcceleration.x = -mAcceleration.x;
        mAcceleration.y = -mAcceleration.y;
      }
      if ((true, cc.sys.os === cc.sys.OS_ANDROID) && cc.sys.browserType !== cc.sys.BROWSER_TYPE_MOBILE_QQ) {
        mAcceleration.x = -mAcceleration.x;
        mAcceleration.y = -mAcceleration.y;
      }
    };
  }), {
    "../event-manager": 58,
    "./CCInputManager": 93,
    "./_CCClass": 100
  } ],
  93: [ (function(require, module, exports) {
    var js = require("../platform/js");
    var macro = require("./CCMacro");
    var sys = require("./CCSys");
    var eventManager = require("../event-manager");
    var TOUCH_TIMEOUT = macro.TOUCH_TIMEOUT;
    var inputManager = {
      _mousePressed: false,
      _isRegisterEvent: false,
      _preTouchPoint: cc.p(0, 0),
      _prevMousePoint: cc.p(0, 0),
      _preTouchPool: [],
      _preTouchPoolPointer: 0,
      _touches: [],
      _touchesIntegerDict: {},
      _indexBitsUsed: 0,
      _maxTouches: 5,
      _accelEnabled: false,
      _accelInterval: .2,
      _accelMinus: 1,
      _accelCurTime: 0,
      _acceleration: null,
      _accelDeviceEvent: null,
      _getUnUsedIndex: function() {
        var temp = this._indexBitsUsed;
        var now = cc.sys.now();
        for (var i = 0; i < this._maxTouches; i++) {
          if (!(1 & temp)) {
            this._indexBitsUsed |= 1 << i;
            return i;
          }
          var touch = this._touches[i];
          if (now - touch._lastModified > TOUCH_TIMEOUT) {
            this._removeUsedIndexBit(i);
            delete this._touchesIntegerDict[touch.getID()];
            return i;
          }
          temp >>= 1;
        }
        return -1;
      },
      _removeUsedIndexBit: function(index) {
        if (index < 0 || index >= this._maxTouches) return;
        var temp = 1 << index;
        temp = ~temp;
        this._indexBitsUsed &= temp;
      },
      _glView: null,
      handleTouchesBegin: function(touches) {
        var selTouch, index, curTouch, touchID, handleTouches = [], locTouchIntDict = this._touchesIntegerDict, now = sys.now();
        for (var i = 0, len = touches.length; i < len; i++) {
          selTouch = touches[i];
          touchID = selTouch.getID();
          index = locTouchIntDict[touchID];
          if (null == index) {
            var unusedIndex = this._getUnUsedIndex();
            if (-1 === unusedIndex) {
              cc.logID(2300, unusedIndex);
              continue;
            }
            curTouch = this._touches[unusedIndex] = new cc.Touch(selTouch._point.x, selTouch._point.y, selTouch.getID());
            curTouch._lastModified = now;
            curTouch._setPrevPoint(selTouch._prevPoint);
            locTouchIntDict[touchID] = unusedIndex;
            handleTouches.push(curTouch);
          }
        }
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.BEGAN;
          eventManager.dispatchEvent(touchEvent);
        }
      },
      handleTouchesMove: function(touches) {
        var selTouch, index, touchID, handleTouches = [], locTouches = this._touches, now = sys.now();
        for (var i = 0, len = touches.length; i < len; i++) {
          selTouch = touches[i];
          touchID = selTouch.getID();
          index = this._touchesIntegerDict[touchID];
          if (null == index) continue;
          if (locTouches[index]) {
            locTouches[index]._setPoint(selTouch._point);
            locTouches[index]._setPrevPoint(selTouch._prevPoint);
            locTouches[index]._lastModified = now;
            handleTouches.push(locTouches[index]);
          }
        }
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.MOVED;
          eventManager.dispatchEvent(touchEvent);
        }
      },
      handleTouchesEnd: function(touches) {
        var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.ENDED;
          eventManager.dispatchEvent(touchEvent);
        }
      },
      handleTouchesCancel: function(touches) {
        var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.CANCELLED;
          eventManager.dispatchEvent(touchEvent);
        }
      },
      getSetOfTouchesEndOrCancel: function(touches) {
        var selTouch, index, touchID, handleTouches = [], locTouches = this._touches, locTouchesIntDict = this._touchesIntegerDict;
        for (var i = 0, len = touches.length; i < len; i++) {
          selTouch = touches[i];
          touchID = selTouch.getID();
          index = locTouchesIntDict[touchID];
          if (null == index) continue;
          if (locTouches[index]) {
            locTouches[index]._setPoint(selTouch._point);
            locTouches[index]._setPrevPoint(selTouch._prevPoint);
            handleTouches.push(locTouches[index]);
            this._removeUsedIndexBit(index);
            delete locTouchesIntDict[touchID];
          }
        }
        return handleTouches;
      },
      getHTMLElementPosition: function(element) {
        if (sys.platform === sys.WECHAT_GAME) return {
          left: 0,
          top: 0,
          width: window.innerWidth,
          height: window.innerHeight
        };
        var docElem = document.documentElement;
        var leftOffset = window.pageXOffset - docElem.clientLeft;
        var topOffset = window.pageYOffset - docElem.clientTop;
        if ("function" === typeof element.getBoundingClientRect) {
          var box = element.getBoundingClientRect();
          return {
            left: box.left + leftOffset,
            top: box.top + topOffset,
            width: box.width,
            height: box.height
          };
        }
        return element instanceof HTMLCanvasElement ? {
          left: leftOffset,
          top: topOffset,
          width: element.width,
          height: element.height
        } : {
          left: leftOffset,
          top: topOffset,
          width: parseInt(element.style.width),
          height: parseInt(element.style.height)
        };
      },
      getPreTouch: function(touch) {
        var preTouch = null;
        var locPreTouchPool = this._preTouchPool;
        var id = touch.getID();
        for (var i = locPreTouchPool.length - 1; i >= 0; i--) if (locPreTouchPool[i].getID() === id) {
          preTouch = locPreTouchPool[i];
          break;
        }
        preTouch || (preTouch = touch);
        return preTouch;
      },
      setPreTouch: function(touch) {
        var find = false;
        var locPreTouchPool = this._preTouchPool;
        var id = touch.getID();
        for (var i = locPreTouchPool.length - 1; i >= 0; i--) if (locPreTouchPool[i].getID() === id) {
          locPreTouchPool[i] = touch;
          find = true;
          break;
        }
        if (!find) if (locPreTouchPool.length <= 50) locPreTouchPool.push(touch); else {
          locPreTouchPool[this._preTouchPoolPointer] = touch;
          this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50;
        }
      },
      getTouchByXY: function(tx, ty, pos) {
        var locPreTouch = this._preTouchPoint;
        var location = this._glView.convertToLocationInView(tx, ty, pos);
        var touch = new cc.Touch(location.x, location.y);
        touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
        locPreTouch.x = location.x;
        locPreTouch.y = location.y;
        return touch;
      },
      getMouseEvent: function(location, pos, eventType) {
        var locPreMouse = this._prevMousePoint;
        var mouseEvent = new cc.Event.EventMouse(eventType);
        mouseEvent._setPrevCursor(locPreMouse.x, locPreMouse.y);
        locPreMouse.x = location.x;
        locPreMouse.y = location.y;
        this._glView._convertMouseToLocationInView(locPreMouse, pos);
        mouseEvent.setLocation(locPreMouse.x, locPreMouse.y);
        return mouseEvent;
      },
      getPointByEvent: function(event, pos) {
        if (null != event.pageX) return {
          x: event.pageX,
          y: event.pageY
        };
        if (sys.platform === sys.WECHAT_GAME) {
          pos.left = 0;
          pos.top = 0;
        } else {
          pos.left -= document.body.scrollLeft;
          pos.top -= document.body.scrollTop;
        }
        return {
          x: event.clientX,
          y: event.clientY
        };
      },
      getTouchesByEvent: function(event, pos) {
        var touchArr = [], locView = this._glView;
        var touch_event, touch, preLocation;
        var locPreTouch = this._preTouchPoint;
        var length = event.changedTouches.length;
        for (var i = 0; i < length; i++) {
          touch_event = event.changedTouches[i];
          if (touch_event) {
            var location;
            location = sys.BROWSER_TYPE_FIREFOX === sys.browserType ? locView.convertToLocationInView(touch_event.pageX, touch_event.pageY, pos) : locView.convertToLocationInView(touch_event.clientX, touch_event.clientY, pos);
            if (null != touch_event.identifier) {
              touch = new cc.Touch(location.x, location.y, touch_event.identifier);
              preLocation = this.getPreTouch(touch).getLocation();
              touch._setPrevPoint(preLocation.x, preLocation.y);
              this.setPreTouch(touch);
            } else {
              touch = new cc.Touch(location.x, location.y);
              touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
            }
            locPreTouch.x = location.x;
            locPreTouch.y = location.y;
            touchArr.push(touch);
          }
        }
        return touchArr;
      },
      registerSystemEvent: function(element) {
        if (this._isRegisterEvent) return;
        this._glView = cc.view;
        var selfPointer = this;
        var prohibition = sys.isMobile;
        var supportMouse = "mouse" in sys.capabilities;
        var supportTouches = "touches" in sys.capabilities;
        if (sys.platform === sys.WECHAT_GAME) {
          prohibition = false;
          supportTouches = true;
          supportMouse = false;
        }
        if (supportMouse) {
          if (!prohibition) {
            window.addEventListener("mousedown", (function() {
              selfPointer._mousePressed = true;
            }), false);
            window.addEventListener("mouseup", (function(event) {
              if (!selfPointer._mousePressed) return;
              selfPointer._mousePressed = false;
              var pos = selfPointer.getHTMLElementPosition(element);
              var location = selfPointer.getPointByEvent(event, pos);
              if (!cc.rectContainsPoint(new cc.Rect(pos.left, pos.top, pos.width, pos.height), location)) {
                selfPointer.handleTouchesEnd([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
                var mouseEvent = selfPointer.getMouseEvent(location, pos, cc.Event.EventMouse.UP);
                mouseEvent.setButton(event.button);
                eventManager.dispatchEvent(mouseEvent);
              }
            }), false);
          }
          var EventMouse = cc.Event.EventMouse;
          var _mouseEventsOnElement = [ !prohibition && [ "mousedown", EventMouse.DOWN, function(event, mouseEvent, location, pos) {
            selfPointer._mousePressed = true;
            selfPointer.handleTouchesBegin([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
            element.focus();
          } ], !prohibition && [ "mouseup", EventMouse.UP, function(event, mouseEvent, location, pos) {
            selfPointer._mousePressed = false;
            selfPointer.handleTouchesEnd([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
          } ], !prohibition && [ "mousemove", EventMouse.MOVE, function(event, mouseEvent, location, pos) {
            selfPointer.handleTouchesMove([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
            selfPointer._mousePressed || mouseEvent.setButton(null);
          } ], [ "mousewheel", EventMouse.SCROLL, function(event, mouseEvent) {
            mouseEvent.setScrollData(0, event.wheelDelta);
          } ], [ "DOMMouseScroll", EventMouse.SCROLL, function(event, mouseEvent) {
            mouseEvent.setScrollData(0, -120 * event.detail);
          } ] ];
          for (var i = 0; i < _mouseEventsOnElement.length; ++i) {
            var entry = _mouseEventsOnElement[i];
            entry && (function() {
              var name = entry[0];
              var type = entry[1];
              var handler = entry[2];
              element.addEventListener(name, (function(event) {
                var pos = selfPointer.getHTMLElementPosition(element);
                var location = selfPointer.getPointByEvent(event, pos);
                var mouseEvent = selfPointer.getMouseEvent(location, pos, type);
                mouseEvent.setButton(event.button);
                handler(event, mouseEvent, location, pos);
                eventManager.dispatchEvent(mouseEvent);
                event.stopPropagation();
                event.preventDefault();
              }), false);
            })();
          }
        }
        if (window.navigator.msPointerEnabled) {
          var _pointerEventsMap = {
            MSPointerDown: selfPointer.handleTouchesBegin,
            MSPointerMove: selfPointer.handleTouchesMove,
            MSPointerUp: selfPointer.handleTouchesEnd,
            MSPointerCancel: selfPointer.handleTouchesCancel
          };
          var _loop = function(_eventName) {
            var touchEvent = _pointerEventsMap[_eventName];
            element.addEventListener(_eventName, (function(event) {
              var pos = selfPointer.getHTMLElementPosition(element);
              pos.left -= document.documentElement.scrollLeft;
              pos.top -= document.documentElement.scrollTop;
              touchEvent.call(selfPointer, [ selfPointer.getTouchByXY(event.clientX, event.clientY, pos) ]);
              event.stopPropagation();
            }), false);
          };
          for (var _eventName in _pointerEventsMap) _loop(_eventName);
        }
        if (supportTouches) {
          var _touchEventsMap = {
            touchstart: function(touchesToHandle) {
              selfPointer.handleTouchesBegin(touchesToHandle);
              sys.platform !== sys.WECHAT_GAME && element.focus();
            },
            touchmove: function(touchesToHandle) {
              selfPointer.handleTouchesMove(touchesToHandle);
            },
            touchend: function(touchesToHandle) {
              selfPointer.handleTouchesEnd(touchesToHandle);
            },
            touchcancel: function(touchesToHandle) {
              selfPointer.handleTouchesCancel(touchesToHandle);
            }
          };
          var registerTouchEvent;
          if (cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB) {
            _touchEventsMap = {
              onTouchStart: _touchEventsMap.touchstart,
              onTouchMove: _touchEventsMap.touchmove,
              onTouchEnd: _touchEventsMap.touchend,
              onTouchCancel: _touchEventsMap.touchcancel
            };
            registerTouchEvent = function(eventName) {
              var handler = _touchEventsMap[eventName];
              wx[eventName]((function(event) {
                if (!event.changedTouches) return;
                var pos = selfPointer.getHTMLElementPosition(element);
                var body = document.body;
                pos.left -= body.scrollLeft || 0;
                pos.top -= body.scrollTop || 0;
                handler(selfPointer.getTouchesByEvent(event, pos));
              }));
            };
          } else registerTouchEvent = function(eventName) {
            var handler = _touchEventsMap[eventName];
            element.addEventListener(eventName, (function(event) {
              if (!event.changedTouches) return;
              var pos = selfPointer.getHTMLElementPosition(element);
              var body = document.body;
              pos.left -= body.scrollLeft || 0;
              pos.top -= body.scrollTop || 0;
              handler(selfPointer.getTouchesByEvent(event, pos));
              event.stopPropagation();
              event.preventDefault();
            }), false);
          };
          for (var eventName in _touchEventsMap) registerTouchEvent(eventName);
        }
        cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB && this._registerKeyboardEvent();
        this._isRegisterEvent = true;
      },
      _registerKeyboardEvent: function() {},
      _registerAccelerometerEvent: function() {},
      update: function(dt) {
        if (this._accelCurTime > this._accelInterval) {
          this._accelCurTime -= this._accelInterval;
          eventManager.dispatchEvent(new cc.Event.EventAcceleration(this._acceleration));
        }
        this._accelCurTime += dt;
      }
    };
    js.get(cc, "inputManager", (function() {
      cc.warnID(1405, "cc.inputManager", "cc.systemEvent");
      return inputManager;
    }));
    module.exports = _cc.inputManager = inputManager;
  }), {
    "../event-manager": 58,
    "../platform/js": 109,
    "./CCMacro": 94,
    "./CCSys": 97
  } ],
  94: [ (function(require, module, exports) {
    require("./_CCClass");
    cc.KEY = {
      none: 0,
      back: 6,
      menu: 18,
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      ctrl: 17,
      alt: 18,
      pause: 19,
      capslock: 20,
      escape: 27,
      space: 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      select: 41,
      insert: 45,
      Delete: 46,
      0: 48,
      1: 49,
      2: 50,
      3: 51,
      4: 52,
      5: 53,
      6: 54,
      7: 55,
      8: 56,
      9: 57,
      a: 65,
      b: 66,
      c: 67,
      d: 68,
      e: 69,
      f: 70,
      g: 71,
      h: 72,
      i: 73,
      j: 74,
      k: 75,
      l: 76,
      m: 77,
      n: 78,
      o: 79,
      p: 80,
      q: 81,
      r: 82,
      s: 83,
      t: 84,
      u: 85,
      v: 86,
      w: 87,
      x: 88,
      y: 89,
      z: 90,
      num0: 96,
      num1: 97,
      num2: 98,
      num3: 99,
      num4: 100,
      num5: 101,
      num6: 102,
      num7: 103,
      num8: 104,
      num9: 105,
      "*": 106,
      "+": 107,
      "-": 109,
      numdel: 110,
      "/": 111,
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123,
      numlock: 144,
      scrolllock: 145,
      ";": 186,
      semicolon: 186,
      equal: 187,
      "=": 187,
      ",": 188,
      comma: 188,
      dash: 189,
      ".": 190,
      period: 190,
      forwardslash: 191,
      grave: 192,
      "[": 219,
      openbracket: 219,
      backslash: 220,
      "]": 221,
      closebracket: 221,
      quote: 222,
      dpadLeft: 1e3,
      dpadRight: 1001,
      dpadUp: 1003,
      dpadDown: 1004,
      dpadCenter: 1005
    };
    cc.ImageFormat = cc.Enum({
      JPG: 0,
      PNG: 1,
      TIFF: 2,
      WEBP: 3,
      PVR: 4,
      ETC: 5,
      S3TC: 6,
      ATITC: 7,
      TGA: 8,
      RAWDATA: 9,
      UNKNOWN: 10
    });
    cc.getImageFormatByData = function(imgData) {
      if (imgData.length > 8 && 137 === imgData[0] && 80 === imgData[1] && 78 === imgData[2] && 71 === imgData[3] && 13 === imgData[4] && 10 === imgData[5] && 26 === imgData[6] && 10 === imgData[7]) return cc.ImageFormat.PNG;
      if (imgData.length > 2 && (73 === imgData[0] && 73 === imgData[1] || 77 === imgData[0] && 77 === imgData[1] || 255 === imgData[0] && 216 === imgData[1])) return cc.ImageFormat.TIFF;
      return cc.ImageFormat.UNKNOWN;
    };
    cc.macro = {
      INVALID_INDEX: -1,
      NODE_TAG_INVALID: -1,
      PI: Math.PI,
      PI2: 2 * Math.PI,
      FLT_MAX: parseFloat("3.402823466e+38F"),
      FLT_MIN: parseFloat("1.175494351e-38F"),
      RAD: Math.PI / 180,
      DEG: 180 / Math.PI,
      UINT_MAX: 4294967295,
      REPEAT_FOREVER: Number.MAX_VALUE - 1,
      FLT_EPSILON: 1.192092896e-7,
      ONE: 1,
      ZERO: 0,
      SRC_ALPHA: 770,
      SRC_ALPHA_SATURATE: 776,
      SRC_COLOR: 768,
      DST_ALPHA: 772,
      DST_COLOR: 774,
      ONE_MINUS_SRC_ALPHA: 771,
      ONE_MINUS_SRC_COLOR: 769,
      ONE_MINUS_DST_ALPHA: 773,
      ONE_MINUS_DST_COLOR: 775,
      ONE_MINUS_CONSTANT_ALPHA: 32772,
      ONE_MINUS_CONSTANT_COLOR: 32770,
      LINEAR: 9729,
      BLEND_DST: 771,
      WEB_ORIENTATION_PORTRAIT: 0,
      WEB_ORIENTATION_LANDSCAPE_LEFT: -90,
      WEB_ORIENTATION_PORTRAIT_UPSIDE_DOWN: 180,
      WEB_ORIENTATION_LANDSCAPE_RIGHT: 90,
      ORIENTATION_PORTRAIT: 1,
      ORIENTATION_LANDSCAPE: 2,
      ORIENTATION_AUTO: 3,
      DENSITYDPI_DEVICE: "device-dpi",
      DENSITYDPI_HIGH: "high-dpi",
      DENSITYDPI_MEDIUM: "medium-dpi",
      DENSITYDPI_LOW: "low-dpi",
      VERTEX_ATTRIB_FLAG_NONE: 0,
      VERTEX_ATTRIB_FLAG_POSITION: 1,
      VERTEX_ATTRIB_FLAG_COLOR: 2,
      VERTEX_ATTRIB_FLAG_TEX_COORDS: 4,
      VERTEX_ATTRIB_FLAG_POS_COLOR_TEX: 7,
      GL_ALL: 0,
      VERTEX_ATTRIB_POSITION: 0,
      VERTEX_ATTRIB_COLOR: 1,
      VERTEX_ATTRIB_TEX_COORDS: 2,
      VERTEX_ATTRIB_MAX: 3,
      UNIFORM_PMATRIX: 0,
      UNIFORM_MVMATRIX: 1,
      UNIFORM_MVPMATRIX: 2,
      UNIFORM_TIME: 3,
      UNIFORM_SINTIME: 4,
      UNIFORM_COSTIME: 5,
      UNIFORM_RANDOM01: 6,
      UNIFORM_SAMPLER: 7,
      UNIFORM_MAX: 8,
      SHADER_POSITION_TEXTURECOLOR: "ShaderPositionTextureColor",
      SHADER_SPRITE_POSITION_TEXTURECOLOR: "ShaderSpritePositionTextureColor",
      SHADER_POSITION_TEXTURECOLORALPHATEST: "ShaderPositionTextureColorAlphaTest",
      SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST: "ShaderSpritePositionTextureColorAlphaTest",
      SHADER_POSITION_COLOR: "ShaderPositionColor",
      SHADER_SPRITE_POSITION_COLOR: "ShaderSpritePositionColor",
      SHADER_POSITION_TEXTURE: "ShaderPositionTexture",
      SHADER_POSITION_TEXTURE_UCOLOR: "ShaderPositionTexture_uColor",
      SHADER_POSITION_TEXTUREA8COLOR: "ShaderPositionTextureA8Color",
      SHADER_POSITION_UCOLOR: "ShaderPosition_uColor",
      SHADER_POSITION_LENGTHTEXTURECOLOR: "ShaderPositionLengthTextureColor",
      UNIFORM_PMATRIX_S: "CC_PMatrix",
      UNIFORM_MVMATRIX_S: "CC_MVMatrix",
      UNIFORM_MVPMATRIX_S: "CC_MVPMatrix",
      UNIFORM_TIME_S: "CC_Time",
      UNIFORM_SINTIME_S: "CC_SinTime",
      UNIFORM_COSTIME_S: "CC_CosTime",
      UNIFORM_RANDOM01_S: "CC_Random01",
      UNIFORM_SAMPLER_S: "CC_Texture0",
      UNIFORM_ALPHA_TEST_VALUE_S: "CC_alpha_value",
      ATTRIBUTE_NAME_COLOR: "a_color",
      ATTRIBUTE_NAME_POSITION: "a_position",
      ATTRIBUTE_NAME_TEX_COORD: "a_texCoord",
      ITEM_SIZE: 32,
      CURRENT_ITEM: 3233828865,
      ZOOM_ACTION_TAG: 3233828866,
      NORMAL_TAG: 8801,
      SELECTED_TAG: 8802,
      DISABLE_TAG: 8803,
      FIX_ARTIFACTS_BY_STRECHING_TEXEL: 0,
      FIX_ARTIFACTS_BY_STRECHING_TEXEL_TMX: 1,
      DIRECTOR_STATS_POSITION: cc.p(0, 0),
      DIRECTOR_FPS_INTERVAL: .5,
      COCOSNODE_RENDER_SUBPIXEL: 1,
      SPRITEBATCHNODE_RENDER_SUBPIXEL: 1,
      AUTO_PREMULTIPLIED_ALPHA_FOR_PNG: 0,
      OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA: 0,
      TEXTURE_NPOT_SUPPORT: 0,
      USE_LA88_LABELS: 1,
      SPRITE_DEBUG_DRAW: 0,
      LABELBMFONT_DEBUG_DRAW: 0,
      LABELATLAS_DEBUG_DRAW: 0,
      ENABLE_STACKABLE_ACTIONS: 1,
      ENABLE_GL_STATE_CACHE: 1,
      TOUCH_TIMEOUT: 5e3,
      BATCH_VERTEX_COUNT: 2e4,
      ENABLE_GC_FOR_NATIVE_OBJECTS: true,
      ENABLE_TILEDMAP_CULLING: true,
      DOWNLOAD_MAX_CONCURRENT: 64,
      ENABLE_TRANSPARENT_CANVAS: false,
      ENABLE_WEBGL_ANTIALIAS: false
    };
    var ENABLE_CULLING = true;
    cc.defineGetterSetter(cc.macro, "ENABLE_CULLING", (function() {
      return ENABLE_CULLING;
    }), (function(val) {
      ENABLE_CULLING = val;
      var scene = cc.director.getScene();
      if (!scene) return;
      false;
      scene._sgNode._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.cullingDirty);
      cc.renderer.childrenOrderDirty = true;
    }));
    cc.defineGetterSetter(cc.macro, "BLEND_SRC", (function() {
      return cc._renderType === cc.game.RENDER_TYPE_WEBGL && cc.macro.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? cc.macro.ONE : cc.macro.SRC_ALPHA;
    }));
    cc.lerp = function(a, b, r) {
      return a + (b - a) * r;
    };
    cc.rand = function() {
      return 16777215 * Math.random();
    };
    cc.randomMinus1To1 = function() {
      return 2 * (Math.random() - .5);
    };
    cc.random0To1 = Math.random;
    cc.degreesToRadians = function(angle) {
      return angle * cc.macro.RAD;
    };
    cc.radiansToDegrees = function(angle) {
      return angle * cc.macro.DEG;
    };
    cc.nodeDrawSetup = function(node) {
      if (node._shaderProgram) {
        node._shaderProgram.use();
        node._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4();
      }
    };
    cc.incrementGLDraws = function(addNumber) {
      cc.g_NumberOfDraws += addNumber;
    };
    cc.checkGLErrorDebug = function() {
      if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
        var _error = cc._renderContext.getError();
        _error && cc.logID(2400, _error);
      }
    };
    module.exports = cc.macro;
  }), {
    "./_CCClass": 100
  } ],
  95: [ (function(require, module, exports) {
    var JS = require("./js");
    var CCClass = require("./CCClass");
    var Destroyed = 1;
    var RealDestroyed = 2;
    var ToDestroy = 4;
    var DontSave = 8;
    var EditorOnly = 16;
    var Dirty = 32;
    var DontDestroy = 64;
    var Destroying = 128;
    var Deactivating = 256;
    var LockedInEditor = 512;
    var IsOnEnableCalled = 2048;
    var IsEditorOnEnableCalled = 4096;
    var IsPreloadStarted = 8192;
    var IsOnLoadCalled = 16384;
    var IsOnLoadStarted = 32768;
    var IsStartCalled = 65536;
    var IsRotationLocked = 1 << 17;
    var IsScaleLocked = 1 << 18;
    var IsAnchorLocked = 1 << 19;
    var IsSizeLocked = 1 << 20;
    var IsPositionLocked = 1 << 21;
    var PersistentMask = ~(ToDestroy | Dirty | Destroying | DontDestroy | Deactivating | IsPreloadStarted | IsOnLoadStarted | IsOnLoadCalled | IsStartCalled | IsOnEnableCalled | IsEditorOnEnableCalled | IsRotationLocked | IsScaleLocked | IsAnchorLocked | IsSizeLocked | IsPositionLocked);
    function CCObject() {
      this._name = "";
      this._objFlags = 0;
    }
    CCClass.fastDefine("cc.Object", CCObject, {
      _name: "",
      _objFlags: 0
    });
    JS.value(CCObject, "Flags", {
      Destroyed: Destroyed,
      DontSave: DontSave,
      EditorOnly: EditorOnly,
      Dirty: Dirty,
      DontDestroy: DontDestroy,
      PersistentMask: PersistentMask,
      Destroying: Destroying,
      Deactivating: Deactivating,
      LockedInEditor: LockedInEditor,
      IsPreloadStarted: IsPreloadStarted,
      IsOnLoadStarted: IsOnLoadStarted,
      IsOnLoadCalled: IsOnLoadCalled,
      IsOnEnableCalled: IsOnEnableCalled,
      IsStartCalled: IsStartCalled,
      IsEditorOnEnableCalled: IsEditorOnEnableCalled,
      IsPositionLocked: IsPositionLocked,
      IsRotationLocked: IsRotationLocked,
      IsScaleLocked: IsScaleLocked,
      IsAnchorLocked: IsAnchorLocked,
      IsSizeLocked: IsSizeLocked
    });
    var objectsToDestroy = [];
    function deferredDestroy() {
      var deleteCount = objectsToDestroy.length;
      for (var i = 0; i < deleteCount; ++i) {
        var obj = objectsToDestroy[i];
        obj._objFlags & Destroyed || obj._destroyImmediate();
      }
      deleteCount === objectsToDestroy.length ? objectsToDestroy.length = 0 : objectsToDestroy.splice(0, deleteCount);
      false;
    }
    JS.value(CCObject, "_deferredDestroy", deferredDestroy);
    false;
    var prototype = CCObject.prototype;
    JS.getset(prototype, "name", (function() {
      return this._name;
    }), (function(value) {
      this._name = value;
    }), true);
    JS.get(prototype, "isValid", (function() {
      return !(this._objFlags & Destroyed);
    }), true);
    false, false;
    var deferredDestroyTimer = null;
    prototype.destroy = function() {
      if (this._objFlags & Destroyed) {
        cc.warnID(5e3);
        return false;
      }
      if (this._objFlags & ToDestroy) return false;
      this._objFlags |= ToDestroy;
      objectsToDestroy.push(this);
      false;
      return true;
    };
    false, false;
    function compileDestruct(obj, ctor) {
      var key, propsToReset = {};
      for (key in obj) if (obj.hasOwnProperty(key)) switch (typeof obj[key]) {
       case "string":
        propsToReset[key] = "";
        break;

       case "object":
       case "function":
        propsToReset[key] = null;
      }
      if (cc.Class._isCCClass(ctor)) {
        var attrs = cc.Class.Attr.getClassAttrs(ctor);
        var propList = ctor.__props__;
        for (var i = 0; i < propList.length; i++) {
          key = propList[i];
          var attrKey = key + cc.Class.Attr.DELIMETER + "default";
          if (attrKey in attrs) switch (typeof attrs[attrKey]) {
           case "string":
            propsToReset[key] = "";
            break;

           case "object":
           case "function":
            propsToReset[key] = null;
            break;

           case "undefined":
            propsToReset[key] = void 0;
          }
        }
      }
      var skipId = obj instanceof cc._BaseNode || obj instanceof cc.Component;
      var func;
      var statement;
      var val;
      false;
      return function(o) {
        for (key in propsToReset) {
          if (skipId && "_id" === key) continue;
          o[key] = propsToReset[key];
        }
      };
    }
    prototype._destruct = function() {
      var ctor = this.constructor;
      var destruct = ctor.__destruct__;
      if (!destruct) {
        destruct = compileDestruct(this, ctor);
        JS.value(ctor, "__destruct__", destruct, true);
      }
      destruct(this);
    };
    prototype._onPreDestroy = null;
    prototype._destroyImmediate = function() {
      if (this._objFlags & Destroyed) {
        cc.errorID(5e3);
        return;
      }
      this._onPreDestroy && this._onPreDestroy();
      true;
      this._destruct();
      this._objFlags |= Destroyed;
    };
    false;
    prototype._deserialize = null;
    cc.isValid = function(value, strictMode) {
      return "object" === typeof value ? !!value && !(value._objFlags & (strictMode ? Destroyed | ToDestroy : Destroyed)) : "undefined" !== typeof value;
    };
    false, false;
    cc.Object = module.exports = CCObject;
  }), {
    "./CCClass": 89,
    "./js": 109
  } ],
  96: [ (function(require, module, exports) {
    cc.screen = {
      _supportsFullScreen: false,
      _preOnFullScreenChange: null,
      _touchEvent: "",
      _fn: null,
      _fnMap: [ [ "requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement" ], [ "requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement" ], [ "webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement" ], [ "mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement" ], [ "msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement" ] ],
      init: function() {
        this._fn = {};
        var i, l, val, map = this._fnMap, valL;
        for (i = 0, l = map.length; i < l; i++) {
          val = map[i];
          if (val && "undefined" !== typeof document[val[1]]) {
            for (i = 0, valL = val.length; i < valL; i++) this._fn[map[0][i]] = val[i];
            break;
          }
        }
        this._supportsFullScreen = "undefined" !== typeof this._fn.requestFullscreen;
        this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown";
      },
      fullScreen: function() {
        return !!this._supportsFullScreen && (void 0 !== document[this._fn.fullscreenElement] && null !== document[this._fn.fullscreenElement]);
      },
      requestFullScreen: function(element, onFullScreenChange) {
        if (!this._supportsFullScreen) return;
        element = element || document.documentElement;
        if (onFullScreenChange) {
          var eventName = this._fn.fullscreenchange;
          this._preOnFullScreenChange && document.removeEventListener(eventName, this._preOnFullScreenChange);
          this._preOnFullScreenChange = onFullScreenChange;
          document.addEventListener(eventName, onFullScreenChange, false);
        }
        return element[this._fn.requestFullscreen]();
      },
      exitFullScreen: function() {
        return !this._supportsFullScreen || document[this._fn.exitFullscreen]();
      },
      autoFullScreen: function(element, onFullScreenChange) {
        element = element || document.body;
        var touchTarget = cc.game.canvas || element;
        var theScreen = this;
        function callback() {
          touchTarget.removeEventListener(theScreen._touchEvent, callback);
          theScreen.requestFullScreen(element, onFullScreenChange);
        }
        this.requestFullScreen(element, onFullScreenChange);
        touchTarget.addEventListener(this._touchEvent, callback);
      }
    };
    cc.screen.init();
  }), {} ],
  97: [ (function(require, module, exports) {
    if (cc.sys) return;
    cc.sys = {};
    var sys = cc.sys;
    sys.LANGUAGE_ENGLISH = "en";
    sys.LANGUAGE_CHINESE = "zh";
    sys.LANGUAGE_FRENCH = "fr";
    sys.LANGUAGE_ITALIAN = "it";
    sys.LANGUAGE_GERMAN = "de";
    sys.LANGUAGE_SPANISH = "es";
    sys.LANGUAGE_DUTCH = "du";
    sys.LANGUAGE_RUSSIAN = "ru";
    sys.LANGUAGE_KOREAN = "ko";
    sys.LANGUAGE_JAPANESE = "ja";
    sys.LANGUAGE_HUNGARIAN = "hu";
    sys.LANGUAGE_PORTUGUESE = "pt";
    sys.LANGUAGE_ARABIC = "ar";
    sys.LANGUAGE_NORWEGIAN = "no";
    sys.LANGUAGE_POLISH = "pl";
    sys.LANGUAGE_TURKISH = "tr";
    sys.LANGUAGE_UKRAINIAN = "uk";
    sys.LANGUAGE_ROMANIAN = "ro";
    sys.LANGUAGE_BULGARIAN = "bg";
    sys.LANGUAGE_UNKNOWN = "unknown";
    sys.OS_IOS = "iOS";
    sys.OS_ANDROID = "Android";
    sys.OS_WINDOWS = "Windows";
    sys.OS_MARMALADE = "Marmalade";
    sys.OS_LINUX = "Linux";
    sys.OS_BADA = "Bada";
    sys.OS_BLACKBERRY = "Blackberry";
    sys.OS_OSX = "OS X";
    sys.OS_WP8 = "WP8";
    sys.OS_WINRT = "WINRT";
    sys.OS_UNKNOWN = "Unknown";
    sys.UNKNOWN = -1;
    sys.WIN32 = 0;
    sys.LINUX = 1;
    sys.MACOS = 2;
    sys.ANDROID = 3;
    sys.IPHONE = 4;
    sys.IPAD = 5;
    sys.BLACKBERRY = 6;
    sys.NACL = 7;
    sys.EMSCRIPTEN = 8;
    sys.TIZEN = 9;
    sys.WINRT = 10;
    sys.WP8 = 11;
    sys.MOBILE_BROWSER = 100;
    sys.DESKTOP_BROWSER = 101;
    sys.EDITOR_PAGE = 102;
    sys.EDITOR_CORE = 103;
    sys.WECHAT_GAME = 104;
    sys.QQ_PLAY = 105;
    sys.BROWSER_TYPE_WECHAT = "wechat";
    sys.BROWSER_TYPE_WECHAT_GAME = "wechatgame";
    sys.BROWSER_TYPE_WECHAT_GAME_SUB = "wechatgamesub";
    sys.BROWSER_TYPE_QQ_PLAY = "qqplay";
    sys.BROWSER_TYPE_ANDROID = "androidbrowser";
    sys.BROWSER_TYPE_IE = "ie";
    sys.BROWSER_TYPE_QQ = "qqbrowser";
    sys.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
    sys.BROWSER_TYPE_UC = "ucbrowser";
    sys.BROWSER_TYPE_UCBS = "ucbs";
    sys.BROWSER_TYPE_360 = "360browser";
    sys.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
    sys.BROWSER_TYPE_BAIDU = "baidubrowser";
    sys.BROWSER_TYPE_MAXTHON = "maxthon";
    sys.BROWSER_TYPE_OPERA = "opera";
    sys.BROWSER_TYPE_OUPENG = "oupeng";
    sys.BROWSER_TYPE_MIUI = "miuibrowser";
    sys.BROWSER_TYPE_FIREFOX = "firefox";
    sys.BROWSER_TYPE_SAFARI = "safari";
    sys.BROWSER_TYPE_CHROME = "chrome";
    sys.BROWSER_TYPE_LIEBAO = "liebao";
    sys.BROWSER_TYPE_QZONE = "qzone";
    sys.BROWSER_TYPE_SOUGOU = "sogou";
    sys.BROWSER_TYPE_UNKNOWN = "unknown";
    sys.NetworkType = {
      NONE: 0,
      LAN: 1,
      WWAN: 2
    };
    sys.getBatteryLevel = function() {
      return 1;
    };
    sys.getNetworkType = function() {
      return sys.NetworkType.LAN;
    };
    sys.isNative = false;
    sys.isBrowser = "object" === typeof window && "object" === typeof document && false;
    cc.create3DContext = function(canvas, opt_attribs, opt_contextType) {
      if (!opt_contextType) return cc.create3DContext(canvas, opt_attribs, "webgl") || cc.create3DContext(canvas, opt_attribs, "experimental-webgl") || cc.create3DContext(canvas, opt_attribs, "webkit-3d") || cc.create3DContext(canvas, opt_attribs, "moz-webgl") || null;
      try {
        return canvas.getContext(opt_contextType, opt_attribs);
      } catch (e) {
        return null;
      }
    };
    false;
    var env;
    var version;
    var w;
    var h;
    var ratio;
    var win, nav, doc, docEle;
    var ua;
    var currLanguage;
    var isAndroid, iOS, osVersion, osMainVersion;
    var uaResult;
    var osName;
    var w;
    var h;
    var ratio;
    var _tmpCanvas1, _tmpCanvas2;
    var fontStyle;
    var localStorage;
    var warn;
    var _supportWebp;
    var _supportCanvas;
    var _supportWebGL;
    var browserVer;
    var capabilities;
    var __audioSupport;
    var detectAudioFormat;
    true;
    var env = wx.getSystemInfoSync();
    sys.isMobile = true;
    sys.platform = sys.WECHAT_GAME;
    sys.language = env.language.substr(0, 2);
    if ("android" === env.platform) sys.os = sys.OS_ANDROID; else if ("ios" === env.platform) sys.os = sys.OS_IOS; else if ("devtools" === env.platform) {
      var system = env.system.toLowerCase();
      system.indexOf("android") > -1 ? sys.os = sys.OS_ANDROID : system.indexOf("ios") > -1 && (sys.os = sys.OS_IOS);
    }
    var version = /[\d\.]+/.exec(env.system);
    sys.osVersion = version[0];
    sys.osMainVersion = parseInt(sys.osVersion);
    wx.getFileSystemManager ? sys.browserType = sys.BROWSER_TYPE_WECHAT_GAME : sys.browserType = sys.BROWSER_TYPE_WECHAT_GAME_SUB;
    sys.browserVersion = env.version;
    var w = env.windowWidth;
    var h = env.windowHeight;
    var ratio = env.pixelRatio || 1;
    sys.windowPixelResolution = {
      width: ratio * w,
      height: ratio * h
    };
    sys.localStorage = window.localStorage;
    sys.capabilities = {
      canvas: true,
      opengl: true,
      webp: false
    };
    sys.__audioSupport = {
      ONLY_ONE: false,
      WEB_AUDIO: false,
      DELAY_CREATE_CTX: false,
      format: [ ".mp3" ]
    };
    sys.garbageCollect = function() {};
    sys.dumpRoot = function() {};
    sys.restartVM = function() {};
    sys.cleanScript = function(jsfile) {};
    sys.isObjectValid = function(obj) {
      return !!obj;
    };
    sys.dump = function() {
      var self = this;
      var str = "";
      str += "isMobile : " + self.isMobile + "\r\n";
      str += "language : " + self.language + "\r\n";
      str += "browserType : " + self.browserType + "\r\n";
      str += "browserVersion : " + self.browserVersion + "\r\n";
      str += "capabilities : " + JSON.stringify(self.capabilities) + "\r\n";
      str += "os : " + self.os + "\r\n";
      str += "osVersion : " + self.osVersion + "\r\n";
      str += "platform : " + self.platform + "\r\n";
      str += "Using " + (cc._renderType === cc.game.RENDER_TYPE_WEBGL ? "WEBGL" : "CANVAS") + " renderer.\r\n";
      cc.log(str);
    };
    sys.openURL = function(url) {
      window.open(url);
    };
    sys.now = function() {
      return Date.now ? Date.now() : +new Date();
    };
    module.exports = sys;
  }), {} ],
  98: [ (function(require, module, exports) {
    var eventManager = require("../event-manager");
    var __BrowserGetter = {
      init: function() {
        false;
      },
      availWidth: function(frame) {
        return frame && frame !== this.html ? frame.clientWidth : window.innerWidth;
      },
      availHeight: function(frame) {
        return frame && frame !== this.html ? frame.clientHeight : window.innerHeight;
      },
      meta: {
        width: "device-width"
      },
      adaptationType: cc.sys.browserType
    };
    cc.sys.os === cc.sys.OS_IOS && (__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI);
    true;
    cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB ? __BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB : __BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_WECHAT_GAME;
    false;
    switch (__BrowserGetter.adaptationType) {
     case cc.sys.BROWSER_TYPE_SAFARI:
      __BrowserGetter.meta["minimal-ui"] = "true";
      __BrowserGetter.availWidth = function(frame) {
        return frame.clientWidth;
      };
      __BrowserGetter.availHeight = function(frame) {
        return frame.clientHeight;
      };
      break;

     case cc.sys.BROWSER_TYPE_CHROME:
      __BrowserGetter.__defineGetter__("target-densitydpi", (function() {
        return cc.view._targetDensityDPI;
      }));
      break;

     case cc.sys.BROWSER_TYPE_SOUGOU:
     case cc.sys.BROWSER_TYPE_UC:
      __BrowserGetter.availWidth = function(frame) {
        return frame.clientWidth;
      };
      __BrowserGetter.availHeight = function(frame) {
        return frame.clientHeight;
      };
      break;

     case cc.sys.BROWSER_TYPE_MIUI:
      __BrowserGetter.init = function(view) {
        if (view.__resizeWithBrowserSize) return;
        var resize = function() {
          view.setDesignResolutionSize(view._designResolutionSize.width, view._designResolutionSize.height, view._resolutionPolicy);
          window.removeEventListener("resize", resize, false);
        };
        window.addEventListener("resize", resize, false);
      };
      break;

     case cc.sys.BROWSER_TYPE_WECHAT_GAME:
      __BrowserGetter.availWidth = function() {
        return window.innerWidth;
      };
      __BrowserGetter.availHeight = function() {
        return window.innerHeight;
      };
      break;

     case cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB:
      var sharedCanvas = wx.getSharedCanvas();
      __BrowserGetter.availWidth = function() {
        return sharedCanvas.width;
      };
      __BrowserGetter.availHeight = function() {
        return sharedCanvas.height;
      };
    }
    var _scissorRect = null;
    var View = cc._Class.extend({
      ctor: function() {
        var _t = this, _strategyer = cc.ContainerStrategy, _strategy = cc.ContentStrategy;
        __BrowserGetter.init(this);
        _t._frameSize = cc.size(0, 0);
        _t._initFrameSize();
        var w = cc.game.canvas.width, h = cc.game.canvas.height;
        _t._designResolutionSize = cc.size(w, h);
        _t._originalDesignResolutionSize = cc.size(w, h);
        _t._viewPortRect = cc.rect(0, 0, w, h);
        _t._visibleRect = cc.rect(0, 0, w, h);
        _t._contentTranslateLeftTop = {
          left: 0,
          top: 0
        };
        _t._autoFullScreen = false;
        _t._devicePixelRatio = 1;
        _t._viewName = "Cocos2dHTML5";
        _t._resizeCallback = null;
        _t._orientationChanging = true;
        _t._resizing = false;
        _t._scaleX = 1;
        _t._originalScaleX = 1;
        _t._scaleY = 1;
        _t._originalScaleY = 1;
        _t._isRotated = false;
        _t._orientation = 3;
        var sys = cc.sys;
        _t.enableRetina(true);
        cc.visibleRect && cc.visibleRect.init(_t._visibleRect);
        _t._resolutionPolicy = null;
        _t._rpExactFit = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT);
        _t._rpShowAll = new cc.ResolutionPolicy(_strategyer.PROPORTION_TO_FRAME, _strategy.SHOW_ALL);
        _t._rpNoBorder = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER);
        _t._rpFixedHeight = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT);
        _t._rpFixedWidth = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH);
        _t._initialized = false;
        _t._contentTranslateLeftTop = null;
        _t._frameZoomFactor = 1;
        _t.__resizeWithBrowserSize = false;
        _t._isAdjustViewPort = true;
        _t._targetDensityDPI = cc.macro.DENSITYDPI_HIGH;
        _t.enableAntiAlias(true);
      },
      _resizeEvent: function() {
        var view;
        view = this.setDesignResolutionSize ? this : cc.view;
        var prevFrameW = view._frameSize.width, prevFrameH = view._frameSize.height, prevRotated = view._isRotated;
        if (cc.sys.isMobile) {
          var containerStyle = cc.game.container.style, margin = containerStyle.margin;
          containerStyle.margin = "0";
          containerStyle.display = "none";
          view._initFrameSize();
          containerStyle.margin = margin;
          containerStyle.display = "block";
        } else view._initFrameSize();
        if (view._isRotated === prevRotated && view._frameSize.width === prevFrameW && view._frameSize.height === prevFrameH) return;
        var width = view._originalDesignResolutionSize.width;
        var height = view._originalDesignResolutionSize.height;
        view._resizing = true;
        width > 0 && view.setDesignResolutionSize(width, height, view._resolutionPolicy);
        view._resizing = false;
        eventManager.dispatchCustomEvent("canvas-resize");
        view._resizeCallback && view._resizeCallback.call();
      },
      _orientationChange: function() {
        cc.view._orientationChanging = true;
        cc.view._resizeEvent();
      },
      setTargetDensityDPI: function(densityDPI) {
        this._targetDensityDPI = densityDPI;
        this._adjustViewportMeta();
      },
      getTargetDensityDPI: function() {
        return this._targetDensityDPI;
      },
      resizeWithBrowserSize: function(enabled) {
        if (enabled) {
          if (!this.__resizeWithBrowserSize) {
            this.__resizeWithBrowserSize = true;
            window.addEventListener("resize", this._resizeEvent);
            window.addEventListener("orientationchange", this._orientationChange);
          }
        } else if (this.__resizeWithBrowserSize) {
          this.__resizeWithBrowserSize = false;
          window.removeEventListener("resize", this._resizeEvent);
          window.removeEventListener("orientationchange", this._orientationChange);
        }
      },
      setResizeCallback: function(callback) {
        "function" !== typeof callback && null != callback || (this._resizeCallback = callback);
      },
      setOrientation: function(orientation) {
        orientation &= cc.macro.ORIENTATION_AUTO;
        if (orientation && this._orientation !== orientation) {
          this._orientation = orientation;
          var designWidth = this._originalDesignResolutionSize.width;
          var designHeight = this._originalDesignResolutionSize.height;
          this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
        }
      },
      _initFrameSize: function() {
        var locFrameSize = this._frameSize;
        var w = __BrowserGetter.availWidth(cc.game.frame);
        var h = __BrowserGetter.availHeight(cc.game.frame);
        var isLandscape = w >= h;
        if ((false, !cc.sys.isMobile) || isLandscape && this._orientation & cc.macro.ORIENTATION_LANDSCAPE || !isLandscape && this._orientation & cc.macro.ORIENTATION_PORTRAIT) {
          locFrameSize.width = w;
          locFrameSize.height = h;
          cc.container.style["-webkit-transform"] = "rotate(0deg)";
          cc.container.style.transform = "rotate(0deg)";
          this._isRotated = false;
        } else {
          locFrameSize.width = h;
          locFrameSize.height = w;
          cc.container.style["-webkit-transform"] = "rotate(90deg)";
          cc.container.style.transform = "rotate(90deg)";
          cc.container.style["-webkit-transform-origin"] = "0px 0px 0px";
          cc.container.style.transformOrigin = "0px 0px 0px";
          this._isRotated = true;
        }
        this._orientationChanging && setTimeout((function() {
          cc.view._orientationChanging = false;
        }), 1e3);
      },
      _adjustSizeKeepCanvasSize: function() {
        var designWidth = this._originalDesignResolutionSize.width;
        var designHeight = this._originalDesignResolutionSize.height;
        designWidth > 0 && this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
      },
      _setViewportMeta: function(metas, overwrite) {
        var vp = document.getElementById("cocosMetaElement");
        vp && overwrite && document.head.removeChild(vp);
        var elems = document.getElementsByName("viewport"), currentVP = elems ? elems[0] : null, content, key, pattern;
        content = currentVP ? currentVP.content : "";
        vp = vp || document.createElement("meta");
        vp.id = "cocosMetaElement";
        vp.name = "viewport";
        vp.content = "";
        for (key in metas) if (-1 == content.indexOf(key)) content += "," + key + "=" + metas[key]; else if (overwrite) {
          pattern = new RegExp(key + "s*=s*[^,]+");
          content.replace(pattern, key + "=" + metas[key]);
        }
        /^,/.test(content) && (content = content.substr(1));
        vp.content = content;
        currentVP && (currentVP.content = content);
        document.head.appendChild(vp);
      },
      _adjustViewportMeta: function() {
        if (this._isAdjustViewPort && false) {
          this._setViewportMeta(__BrowserGetter.meta, false);
          this._isAdjustViewPort = false;
        }
      },
      _resetScale: function() {
        this._scaleX = this._originalScaleX;
        this._scaleY = this._originalScaleY;
      },
      _adjustSizeToBrowser: function() {},
      initialize: function() {
        this._initialized = true;
      },
      adjustViewPort: function(enabled) {
        this._isAdjustViewPort = enabled;
      },
      enableRetina: function(enabled) {
        this._retinaEnabled = !!enabled;
      },
      isRetinaEnabled: function() {
        return this._retinaEnabled;
      },
      enableAntiAlias: function(enabled) {
        if (this._antiAliasEnabled === enabled) return;
        this._antiAliasEnabled = enabled;
        if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
          var cache = cc.loader._cache;
          for (var key in cache) {
            var item = cache[key];
            var tex = item && item.content instanceof cc.Texture2D ? item.content : null;
            tex && (enabled ? tex.setAntiAliasTexParameters() : tex.setAliasTexParameters());
          }
        } else if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
          var ctx = cc._canvas.getContext("2d");
          ctx.imageSmoothingEnabled = enabled;
          ctx.mozImageSmoothingEnabled = enabled;
          var dirtyRegion = cc.rendererCanvas._dirtyRegion;
          if (dirtyRegion) {
            var oldRegion = new cc.Region();
            oldRegion.setTo(0, 0, cc.visibleRect.width, cc.visibleRect.height);
            dirtyRegion.addRegion(oldRegion);
          }
        }
      },
      isAntiAliasEnabled: function() {
        return this._antiAliasEnabled;
      },
      enableAutoFullScreen: function(enabled) {
        if (enabled && enabled !== this._autoFullScreen && cc.sys.isMobile && cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT) {
          this._autoFullScreen = true;
          cc.screen.autoFullScreen(cc.game.frame);
        } else this._autoFullScreen = false;
      },
      isAutoFullScreenEnabled: function() {
        return this._autoFullScreen;
      },
      isViewReady: function() {
        return cc.game.canvas && cc._renderContext;
      },
      setFrameZoomFactor: function(zoomFactor) {
        this._frameZoomFactor = zoomFactor;
        cc.director.setProjection(cc.director.getProjection());
      },
      setContentTranslateLeftTop: function(offsetLeft, offsetTop) {
        this._contentTranslateLeftTop = {
          left: offsetLeft,
          top: offsetTop
        };
      },
      getContentTranslateLeftTop: function() {
        return this._contentTranslateLeftTop;
      },
      setCanvasSize: function(width, height) {
        var canvas = cc.game.canvas;
        var container = cc.game.container;
        canvas.width = width * this._devicePixelRatio;
        canvas.height = height * this._devicePixelRatio;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        container.style.width = width + "px";
        container.style.height = height + "px";
        this._resizeEvent();
      },
      getCanvasSize: function() {
        return cc.size(cc.game.canvas.width, cc.game.canvas.height);
      },
      getFrameSize: function() {
        return cc.size(this._frameSize.width, this._frameSize.height);
      },
      setFrameSize: function(width, height) {
        this._frameSize.width = width;
        this._frameSize.height = height;
        cc.game.frame.style.width = width + "px";
        cc.game.frame.style.height = height + "px";
        this._resizeEvent();
        cc.director.setProjection(cc.director.getProjection());
      },
      getVisibleSize: function() {
        return cc.size(this._visibleRect.width, this._visibleRect.height);
      },
      getVisibleSizeInPixel: function() {
        return cc.size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
      },
      getVisibleOrigin: function() {
        return cc.p(this._visibleRect.x, this._visibleRect.y);
      },
      getVisibleOriginInPixel: function() {
        return cc.p(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
      },
      canSetContentScaleFactor: function() {
        return true;
      },
      getResolutionPolicy: function() {
        return this._resolutionPolicy;
      },
      setResolutionPolicy: function(resolutionPolicy) {
        var _t = this;
        if (resolutionPolicy instanceof cc.ResolutionPolicy) _t._resolutionPolicy = resolutionPolicy; else {
          var _locPolicy = cc.ResolutionPolicy;
          resolutionPolicy === _locPolicy.EXACT_FIT && (_t._resolutionPolicy = _t._rpExactFit);
          resolutionPolicy === _locPolicy.SHOW_ALL && (_t._resolutionPolicy = _t._rpShowAll);
          resolutionPolicy === _locPolicy.NO_BORDER && (_t._resolutionPolicy = _t._rpNoBorder);
          resolutionPolicy === _locPolicy.FIXED_HEIGHT && (_t._resolutionPolicy = _t._rpFixedHeight);
          resolutionPolicy === _locPolicy.FIXED_WIDTH && (_t._resolutionPolicy = _t._rpFixedWidth);
        }
      },
      setDesignResolutionSize: function(width, height, resolutionPolicy) {
        if (!(width > 0 || height > 0)) {
          cc.logID(2200);
          return;
        }
        this.setResolutionPolicy(resolutionPolicy);
        var policy = this._resolutionPolicy;
        policy && policy.preApply(this);
        cc.sys.isMobile && this._adjustViewportMeta();
        this._orientationChanging = true;
        this._resizing || this._initFrameSize();
        if (!policy) {
          cc.logID(2201);
          return;
        }
        this._originalDesignResolutionSize.width = this._designResolutionSize.width = width;
        this._originalDesignResolutionSize.height = this._designResolutionSize.height = height;
        var result = policy.apply(this, this._designResolutionSize);
        if (result.scale && 2 === result.scale.length) {
          this._scaleX = result.scale[0];
          this._scaleY = result.scale[1];
        }
        if (result.viewport) {
          var vp = this._viewPortRect, vb = this._visibleRect, rv = result.viewport;
          vp.x = rv.x;
          vp.y = rv.y;
          vp.width = rv.width;
          vp.height = rv.height;
          vb.x = -vp.x / this._scaleX;
          vb.y = -vp.y / this._scaleY;
          vb.width = cc.game.canvas.width / this._scaleX;
          vb.height = cc.game.canvas.height / this._scaleY;
          cc._renderContext.setOffset && cc._renderContext.setOffset(vp.x, -vp.y);
        }
        var director = cc.director;
        director._winSizeInPoints.width = this._designResolutionSize.width;
        director._winSizeInPoints.height = this._designResolutionSize.height;
        policy.postApply(this);
        cc.winSize.width = director._winSizeInPoints.width;
        cc.winSize.height = director._winSizeInPoints.height;
        cc._renderType === cc.game.RENDER_TYPE_WEBGL ? director.setGLDefaultValues() : cc._renderType === cc.game.RENDER_TYPE_CANVAS && (cc.renderer._allNeedDraw = true);
        this._originalScaleX = this._scaleX;
        this._originalScaleY = this._scaleY;
        cc.visibleRect && cc.visibleRect.init(this._visibleRect);
      },
      getDesignResolutionSize: function() {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height);
      },
      setRealPixelResolution: function(width, height, resolutionPolicy) {
        false;
        this.setDesignResolutionSize(width, height, resolutionPolicy);
      },
      setViewPortInPoints: function(x, y, w, h) {
        var locFrameZoomFactor = this._frameZoomFactor, locScaleX = this._scaleX, locScaleY = this._scaleY;
        cc._renderContext.viewport(x * locScaleX * locFrameZoomFactor + this._viewPortRect.x * locFrameZoomFactor, y * locScaleY * locFrameZoomFactor + this._viewPortRect.y * locFrameZoomFactor, w * locScaleX * locFrameZoomFactor, h * locScaleY * locFrameZoomFactor);
      },
      setScissorInPoints: function(x, y, w, h) {
        var zoomFactor = this._frameZoomFactor, scaleX = this._scaleX, scaleY = this._scaleY;
        var sx = Math.ceil(x * scaleX * zoomFactor + this._viewPortRect.x * zoomFactor);
        var sy = Math.ceil(y * scaleY * zoomFactor + this._viewPortRect.y * zoomFactor);
        var sw = Math.ceil(w * scaleX * zoomFactor);
        var sh = Math.ceil(h * scaleY * zoomFactor);
        if (!_scissorRect) {
          var boxArr = gl.getParameter(gl.SCISSOR_BOX);
          _scissorRect = cc.rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
        }
        if (_scissorRect.x !== sx || _scissorRect.y !== sy || _scissorRect.width !== sw || _scissorRect.height !== sh) {
          _scissorRect.x = sx;
          _scissorRect.y = sy;
          _scissorRect.width = sw;
          _scissorRect.height = sh;
          cc._renderContext.scissor(sx, sy, sw, sh);
        }
      },
      isScissorEnabled: function() {
        return cc._renderContext.isEnabled(gl.SCISSOR_TEST);
      },
      getScissorRect: function() {
        if (!_scissorRect) {
          var boxArr = gl.getParameter(gl.SCISSOR_BOX);
          _scissorRect = cc.rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
        }
        var scaleXFactor = 1 / this._scaleX;
        var scaleYFactor = 1 / this._scaleY;
        return cc.rect((_scissorRect.x - this._viewPortRect.x) * scaleXFactor, (_scissorRect.y - this._viewPortRect.y) * scaleYFactor, _scissorRect.width * scaleXFactor, _scissorRect.height * scaleYFactor);
      },
      setViewName: function(viewName) {
        null != viewName && viewName.length > 0 && (this._viewName = viewName);
      },
      getViewName: function() {
        return this._viewName;
      },
      getViewPortRect: function() {
        return this._viewPortRect;
      },
      getScaleX: function() {
        return this._scaleX;
      },
      getScaleY: function() {
        return this._scaleY;
      },
      getDevicePixelRatio: function() {
        return this._devicePixelRatio;
      },
      convertToLocationInView: function(tx, ty, relatedPos) {
        var x = this._devicePixelRatio * (tx - relatedPos.left);
        var y = this._devicePixelRatio * (relatedPos.top + relatedPos.height - ty);
        return this._isRotated ? {
          x: this._viewPortRect.width - y,
          y: x
        } : {
          x: x,
          y: y
        };
      },
      _convertMouseToLocationInView: function(in_out_point, relatedPos) {
        var viewport = this._viewPortRect, _t = this;
        in_out_point.x = (_t._devicePixelRatio * (in_out_point.x - relatedPos.left) - viewport.x) / _t._scaleX;
        in_out_point.y = (_t._devicePixelRatio * (relatedPos.top + relatedPos.height - in_out_point.y) - viewport.y) / _t._scaleY;
      },
      _convertPointWithScale: function(point) {
        var viewport = this._viewPortRect;
        point.x = (point.x - viewport.x) / this._scaleX;
        point.y = (point.y - viewport.y) / this._scaleY;
      },
      _convertTouchesWithScale: function(touches) {
        var viewport = this._viewPortRect, scaleX = this._scaleX, scaleY = this._scaleY, selTouch, selPoint, selPrePoint;
        for (var i = 0; i < touches.length; i++) {
          selTouch = touches[i];
          selPoint = selTouch._point;
          selPrePoint = selTouch._prevPoint;
          selPoint.x = (selPoint.x - viewport.x) / scaleX;
          selPoint.y = (selPoint.y - viewport.y) / scaleY;
          selPrePoint.x = (selPrePoint.x - viewport.x) / scaleX;
          selPrePoint.y = (selPrePoint.y - viewport.y) / scaleY;
        }
      }
    });
    View._getInstance = function() {
      if (!this._instance) {
        this._instance = this._instance || new View();
        this._instance.initialize();
      }
      return this._instance;
    };
    cc.ContainerStrategy = cc._Class.extend({
      preApply: function(view) {},
      apply: function(view, designedResolution) {},
      postApply: function(view) {},
      _setupContainer: function(view, w, h) {
        var locCanvas = cc.game.canvas, locContainer = cc.game.container;
        if (cc.sys.platform !== cc.sys.WECHAT_GAME) {
          if (cc.sys.os === cc.sys.OS_ANDROID) {
            document.body.style.width = (view._isRotated ? h : w) + "px";
            document.body.style.height = (view._isRotated ? w : h) + "px";
          }
          locContainer.style.width = locCanvas.style.width = w + "px";
          locContainer.style.height = locCanvas.style.height = h + "px";
        }
        var devicePixelRatio = view._devicePixelRatio = 1;
        view.isRetinaEnabled() && (devicePixelRatio = view._devicePixelRatio = Math.min(2, window.devicePixelRatio || 1));
        locCanvas.width = w * devicePixelRatio;
        locCanvas.height = h * devicePixelRatio;
        if (cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME && wx && wx.getOpenDataContext) {
          var openDataContext = wx.getOpenDataContext();
          var sharedCanvas = openDataContext.canvas;
          if (sharedCanvas) {
            sharedCanvas.width = locCanvas.width;
            sharedCanvas.height = locCanvas.height;
          }
        }
        cc._renderContext.resetCache && cc._renderContext.resetCache();
      },
      _fixContainer: function() {
        document.body.insertBefore(cc.container, document.body.firstChild);
        var bs = document.body.style;
        bs.width = window.innerWidth + "px";
        bs.height = window.innerHeight + "px";
        bs.overflow = "hidden";
        var contStyle = cc.container.style;
        contStyle.position = "fixed";
        contStyle.left = contStyle.top = "0px";
        document.body.scrollTop = 0;
      }
    });
    cc.ContentStrategy = cc._Class.extend({
      _result: {
        scale: [ 1, 1 ],
        viewport: null
      },
      _buildResult: function(containerW, containerH, contentW, contentH, scaleX, scaleY) {
        Math.abs(containerW - contentW) < 2 && (contentW = containerW);
        Math.abs(containerH - contentH) < 2 && (contentH = containerH);
        var viewport = cc.rect(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
        cc._renderType === cc.game.RENDER_TYPE_CANVAS;
        this._result.scale = [ scaleX, scaleY ];
        this._result.viewport = viewport;
        return this._result;
      },
      preApply: function(view) {},
      apply: function(view, designedResolution) {
        return {
          scale: [ 1, 1 ]
        };
      },
      postApply: function(view) {}
    });
    (function() {
      var EqualToFrame = cc.ContainerStrategy.extend({
        apply: function(view) {
          var frameH = view._frameSize.height, containerStyle = cc.container.style;
          this._setupContainer(view, view._frameSize.width, view._frameSize.height);
          view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px";
          containerStyle.padding = "0px";
        }
      });
      var ProportionalToFrame = cc.ContainerStrategy.extend({
        apply: function(view, designedResolution) {
          var frameW = view._frameSize.width, frameH = view._frameSize.height, containerStyle = cc.container.style, designW = designedResolution.width, designH = designedResolution.height, scaleX = frameW / designW, scaleY = frameH / designH, containerW, containerH;
          scaleX < scaleY ? (containerW = frameW, containerH = designH * scaleX) : (containerW = designW * scaleY, 
          containerH = frameH);
          var offx = Math.round((frameW - containerW) / 2);
          var offy = Math.round((frameH - containerH) / 2);
          containerW = frameW - 2 * offx;
          containerH = frameH - 2 * offy;
          this._setupContainer(view, containerW, containerH);
          true;
          view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px";
          containerStyle.paddingLeft = offx + "px";
          containerStyle.paddingRight = offx + "px";
          containerStyle.paddingTop = offy + "px";
          containerStyle.paddingBottom = offy + "px";
        }
      });
      var EqualToWindow = EqualToFrame.extend({
        preApply: function(view) {
          this._super(view);
          cc.game.frame = document.documentElement;
        },
        apply: function(view) {
          this._super(view);
          this._fixContainer();
        }
      });
      var ProportionalToWindow = ProportionalToFrame.extend({
        preApply: function(view) {
          this._super(view);
          cc.game.frame = document.documentElement;
        },
        apply: function(view, designedResolution) {
          this._super(view, designedResolution);
          this._fixContainer();
        }
      });
      var OriginalContainer = cc.ContainerStrategy.extend({
        apply: function(view) {
          this._setupContainer(view, cc.game.canvas.width, cc.game.canvas.height);
        }
      });
      cc.ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
      cc.ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();
      cc.ContainerStrategy.ORIGINAL_CONTAINER = new OriginalContainer();
      var ExactFit = cc.ContentStrategy.extend({
        apply: function(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scaleX = containerW / designedResolution.width, scaleY = containerH / designedResolution.height;
          return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
        }
      });
      var ShowAll = cc.ContentStrategy.extend({
        apply: function(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale = 0, contentW, contentH;
          scaleX < scaleY ? (scale = scaleX, contentW = containerW, contentH = designH * scale) : (scale = scaleY, 
          contentW = designW * scale, contentH = containerH);
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
      });
      var NoBorder = cc.ContentStrategy.extend({
        apply: function(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale, contentW, contentH;
          scaleX < scaleY ? (scale = scaleY, contentW = designW * scale, contentH = containerH) : (scale = scaleX, 
          contentW = containerW, contentH = designH * scale);
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
      });
      var FixedHeight = cc.ContentStrategy.extend({
        apply: function(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designH = designedResolution.height, scale = containerH / designH, contentW = containerW, contentH = containerH;
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        },
        postApply: function(view) {
          cc.director._winSizeInPoints = view.getVisibleSize();
        }
      });
      var FixedWidth = cc.ContentStrategy.extend({
        apply: function(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, scale = containerW / designW, contentW = containerW, contentH = containerH;
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        },
        postApply: function(view) {
          cc.director._winSizeInPoints = view.getVisibleSize();
        }
      });
      cc.ContentStrategy.EXACT_FIT = new ExactFit();
      cc.ContentStrategy.SHOW_ALL = new ShowAll();
      cc.ContentStrategy.NO_BORDER = new NoBorder();
      cc.ContentStrategy.FIXED_HEIGHT = new FixedHeight();
      cc.ContentStrategy.FIXED_WIDTH = new FixedWidth();
    })();
    cc.ResolutionPolicy = cc._Class.extend({
      _containerStrategy: null,
      _contentStrategy: null,
      ctor: function(containerStg, contentStg) {
        this.setContainerStrategy(containerStg);
        this.setContentStrategy(contentStg);
      },
      preApply: function(view) {
        this._containerStrategy.preApply(view);
        this._contentStrategy.preApply(view);
      },
      apply: function(view, designedResolution) {
        this._containerStrategy.apply(view, designedResolution);
        return this._contentStrategy.apply(view, designedResolution);
      },
      postApply: function(view) {
        this._containerStrategy.postApply(view);
        this._contentStrategy.postApply(view);
      },
      setContainerStrategy: function(containerStg) {
        containerStg instanceof cc.ContainerStrategy && (this._containerStrategy = containerStg);
      },
      setContentStrategy: function(contentStg) {
        contentStg instanceof cc.ContentStrategy && (this._contentStrategy = contentStg);
      }
    });
    cc.js.get(cc.ResolutionPolicy.prototype, "canvasSize", (function() {
      return cc.v2(cc.game.canvas.width, cc.game.canvas.height);
    }));
    cc.ResolutionPolicy.EXACT_FIT = 0;
    cc.ResolutionPolicy.NO_BORDER = 1;
    cc.ResolutionPolicy.SHOW_ALL = 2;
    cc.ResolutionPolicy.FIXED_HEIGHT = 3;
    cc.ResolutionPolicy.FIXED_WIDTH = 4;
    cc.ResolutionPolicy.UNKNOWN = 5;
    module.exports = View;
  }), {
    "../event-manager": 58
  } ],
  99: [ (function(require, module, exports) {
    cc.visibleRect = {
      topLeft: cc.p(0, 0),
      topRight: cc.p(0, 0),
      top: cc.p(0, 0),
      bottomLeft: cc.p(0, 0),
      bottomRight: cc.p(0, 0),
      bottom: cc.p(0, 0),
      center: cc.p(0, 0),
      left: cc.p(0, 0),
      right: cc.p(0, 0),
      width: 0,
      height: 0,
      init: function(visibleRect) {
        var w = this.width = visibleRect.width;
        var h = this.height = visibleRect.height;
        var l = visibleRect.x, b = visibleRect.y, t = b + h, r = l + w;
        this.topLeft.x = l;
        this.topLeft.y = t;
        this.topRight.x = r;
        this.topRight.y = t;
        this.top.x = l + w / 2;
        this.top.y = t;
        this.bottomLeft.x = l;
        this.bottomLeft.y = b;
        this.bottomRight.x = r;
        this.bottomRight.y = b;
        this.bottom.x = l + w / 2;
        this.bottom.y = b;
        this.center.x = l + w / 2;
        this.center.y = b + h / 2;
        this.left.x = l;
        this.left.y = b + h / 2;
        this.right.x = r;
        this.right.y = b + h / 2;
      }
    };
  }), {} ],
  100: [ (function(require, module, exports) {
    var ClassManager = cc.ClassManager = {
      instanceId: 0 | 998 * Math.random(),
      getNewInstanceId: function() {
        return this.instanceId++;
      }
    };
    var fnTest = /\b_super\b/;
    var Class = function() {};
    Class.extend = function(props) {
      var _super = this.prototype;
      var proto = Object.create(_super);
      var desc = {
        writable: true,
        enumerable: false,
        configurable: true
      };
      var TheClass;
      var ctor;
      false;
      TheClass = function(arg0, arg1, arg2, arg3, arg4) {
        this.__instanceId = ClassManager.getNewInstanceId();
        if (this.ctor) switch (arguments.length) {
         case 0:
          this.ctor();
          break;

         case 1:
          this.ctor(arg0);
          break;

         case 2:
          this.ctor(arg0, arg1);
          break;

         case 3:
          this.ctor(arg0, arg1, arg2);
          break;

         case 4:
          this.ctor(arg0, arg1, arg2, arg3);
          break;

         case 5:
          this.ctor(arg0, arg1, arg2, arg3, arg4);
          break;

         default:
          this.ctor.apply(this, arguments);
        }
      };
      TheClass.prototype = proto;
      desc.value = TheClass;
      Object.defineProperty(proto, "constructor", desc);
      for (var name in props) {
        var isFunc = "function" === typeof props[name];
        var override = isFunc && "function" === typeof _super[name];
        var hasSuperCall = override && fnTest.test(props[name]);
        if (hasSuperCall) {
          desc.value = (function(name, fn) {
            return function() {
              var tmp = this._super;
              this._super = _super[name];
              var ret = fn.apply(this, arguments);
              this._super = tmp;
              return ret;
            };
          })(name, props[name]);
          Object.defineProperty(proto, name, desc);
        } else if (isFunc) {
          desc.value = props[name];
          Object.defineProperty(proto, name, desc);
        } else proto[name] = props[name];
      }
      TheClass.extend = Class.extend;
      TheClass.implement = function(prop) {
        for (var name in prop) proto[name] = prop[name];
      };
      return TheClass;
    };
    cc.defineGetterSetter = function(proto, prop, getter, setter, getterName, setterName) {
      if (proto.__defineGetter__) {
        getter && proto.__defineGetter__(prop, getter);
        setter && proto.__defineSetter__(prop, setter);
      } else {
        if (!Object.defineProperty) throw new Error(cc._getError(3658));
        var desc = {
          configurable: true
        };
        getter && (desc.get = getter);
        setter && (desc.set = setter);
        Object.defineProperty(proto, prop, desc);
      }
    };
    cc.clone = function(obj) {
      var newObj = obj.constructor ? new obj.constructor() : {};
      for (var key in obj) {
        var copy = obj[key];
        "object" !== typeof copy || !copy || copy instanceof _ccsg.Node || (false, copy instanceof HTMLElement) ? newObj[key] = copy : newObj[key] = cc.clone(copy);
      }
      return newObj;
    };
    cc._Class = module.exports = Class;
  }), {} ],
  101: [ (function(require, module, exports) {
    var JS = require("./js");
    var isPlainEmptyObj = require("./utils").isPlainEmptyObj_DEV;
    var DELIMETER = "$_$";
    function createAttrsSingle(owner, ownerCtor, superAttrs) {
      var AttrsCtor;
      var ctorName;
      false;
      AttrsCtor = function() {};
      superAttrs && JS.extend(AttrsCtor, superAttrs.constructor);
      var attrs = new AttrsCtor();
      JS.value(owner, "__attrs__", attrs);
      return attrs;
    }
    function createAttrs(subclass) {
      var superClass;
      var chains = cc.Class.getInheritanceChain(subclass);
      for (var i = chains.length - 1; i >= 0; i--) {
        var cls = chains[i];
        var attrs = cls.hasOwnProperty("__attrs__") && cls.__attrs__;
        if (!attrs) {
          superClass = chains[i + 1];
          createAttrsSingle(cls, cls, superClass && superClass.__attrs__);
        }
      }
      superClass = chains[0];
      createAttrsSingle(subclass, subclass, superClass && superClass.__attrs__);
      return subclass.__attrs__;
    }
    function attr(ctor, propName, newAttrs) {
      var attrs, setter, key;
      if ("function" === typeof ctor) {
        attrs = getClassAttrs(ctor);
        setter = attrs.constructor.prototype;
      } else {
        var instance = ctor;
        attrs = instance.__attrs__;
        if (!attrs) {
          ctor = instance.constructor;
          var clsAttrs = getClassAttrs(ctor);
          attrs = createAttrsSingle(instance, ctor, clsAttrs);
        }
        setter = attrs;
      }
      if ("undefined" === typeof newAttrs) {
        var prefix = propName + DELIMETER;
        var ret = {};
        for (key in attrs) key.startsWith(prefix) && (ret[key.slice(prefix.length)] = attrs[key]);
        return ret;
      }
      if ("object" === typeof newAttrs) for (key in newAttrs) 95 !== key.charCodeAt(0) && (setter[propName + DELIMETER + key] = newAttrs[key]); else false;
    }
    function getClassAttrs(ctor) {
      return ctor.hasOwnProperty("__attrs__") && ctor.__attrs__ || createAttrs(ctor);
    }
    function getClassAttrsProto(ctor) {
      return getClassAttrs(ctor).constructor.prototype;
    }
    function setClassAttr(ctor, propName, key, value) {
      var proto = getClassAttrsProto(ctor);
      proto[propName + DELIMETER + key] = value;
    }
    cc.Integer = "Integer";
    cc.Float = "Float";
    false;
    cc.Boolean = "Boolean";
    cc.String = "String";
    function getTypeChecker(type, attrName) {
      false;
    }
    function ObjectType(typeCtor) {
      return {
        type: "Object",
        ctor: typeCtor,
        _onAfterProp: false
      };
    }
    module.exports = {
      attr: attr,
      getClassAttrs: getClassAttrs,
      getClassAttrsProto: getClassAttrsProto,
      setClassAttr: setClassAttr,
      DELIMETER: DELIMETER,
      getTypeChecker: getTypeChecker,
      ObjectType: ObjectType,
      ScriptUuid: {}
    };
  }), {
    "./CCClass": 89,
    "./js": 109,
    "./utils": 113
  } ],
  102: [ (function(require, module, exports) {
    var JS = require("./js");
    var fastRemoveAt = JS.array.fastRemoveAt;
    function CallbackList() {
      this.callbacks = [];
      this.targets = [];
      this.isInvoking = false;
      this.containCanceled = false;
    }
    var proto = CallbackList.prototype;
    proto.removeBy = function(array, value) {
      var callbacks = this.callbacks;
      var targets = this.targets;
      for (var i = 0; i < array.length; ++i) if (array[i] === value) {
        fastRemoveAt(callbacks, i);
        fastRemoveAt(targets, i);
        --i;
      }
    };
    proto.cancel = function(index) {
      this.callbacks[index] = this.targets[index] = null;
      this.containCanceled = true;
    };
    proto.cancelAll = function() {
      var callbacks = this.callbacks;
      var targets = this.targets;
      for (var i = 0; i < callbacks.length; i++) callbacks[i] = targets[i] = null;
      this.containCanceled = true;
    };
    proto.purgeCanceled = function() {
      this.removeBy(this.callbacks, null);
      this.containCanceled = false;
    };
    var MAX_SIZE = 16;
    var callbackListPool = new JS.Pool(function(list) {
      list.callbacks.length = 0;
      list.targets.length = 0;
      list.isInvoking = false;
      list.containCanceled = false;
    }, MAX_SIZE);
    callbackListPool.get = function() {
      return this._get() || new CallbackList();
    };
    function CallbacksHandler() {
      this._callbackTable = JS.createMap(true);
    }
    proto = CallbacksHandler.prototype;
    proto.add = function(key, callback, target) {
      var list = this._callbackTable[key];
      list || (list = this._callbackTable[key] = callbackListPool.get());
      list.callbacks.push(callback);
      list.targets.push(target || null);
    };
    proto.has = function(key, callback, target) {
      var list = this._callbackTable[key];
      if (!list) return false;
      var callbacks = list.callbacks;
      if (!callback) {
        for (var i = 0; i < callbacks.length; i++) if (callbacks[i]) return true;
        return false;
      }
      target = target || null;
      var targets = list.targets;
      for (var _i = 0; _i < callbacks.length; ++_i) if (callbacks[_i] === callback && targets[_i] === target) return true;
      return false;
    };
    proto.removeAll = function(keyOrTarget) {
      if ("string" === typeof keyOrTarget) {
        var list = this._callbackTable[keyOrTarget];
        if (list) if (list.isInvoking) list.cancelAll(); else {
          callbackListPool.put(list);
          delete this._callbackTable[keyOrTarget];
        }
      } else if (keyOrTarget) for (var key in this._callbackTable) {
        var _list = this._callbackTable[key];
        if (_list.isInvoking) {
          var targets = _list.targets;
          for (var i = 0; i < targets.length; ++i) targets[i] === keyOrTarget && _list.cancel(i);
        } else _list.removeBy(_list.targets, keyOrTarget);
      }
    };
    proto.remove = function(key, callback, target) {
      var list = this._callbackTable[key];
      if (list) {
        target = target || null;
        var callbacks = list.callbacks;
        var targets = list.targets;
        for (var i = 0; i < callbacks.length; ++i) if (callbacks[i] === callback && targets[i] === target) {
          if (list.isInvoking) list.cancel(i); else {
            fastRemoveAt(callbacks, i);
            fastRemoveAt(targets, i);
          }
          break;
        }
      }
    };
    var CallbacksInvoker = function() {
      CallbacksHandler.call(this);
    };
    JS.extend(CallbacksInvoker, CallbacksHandler);
    false;
    CallbacksInvoker.prototype.invoke = function(key, p1, p2, p3, p4, p5) {
      var list = this._callbackTable[key];
      if (list) {
        var rootInvoker = !list.isInvoking;
        list.isInvoking = true;
        var callbacks = list.callbacks;
        var targets = list.targets;
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          var callback = callbacks[i];
          if (callback) {
            var target = targets[i];
            target ? callback.call(target, p1, p2, p3, p4, p5) : callback(p1, p2, p3, p4, p5);
          }
        }
        if (rootInvoker) {
          list.isInvoking = false;
          list.containCanceled && list.purgeCanceled();
        }
      }
    };
    CallbacksInvoker.CallbacksHandler = CallbacksHandler;
    module.exports = CallbacksInvoker;
  }), {
    "./js": 109
  } ],
  103: [ (function(require, module, exports) {
    function deepFlatten(strList, array) {
      for (var i = 0; i < array.length; i++) {
        var item = array[i];
        Array.isArray(item) ? deepFlatten(strList, item) : strList.push(item);
      }
    }
    function flattenCodeArray(array) {
      var separator = "";
      var strList = [];
      deepFlatten(strList, array);
      return strList.join(separator);
    }
    module.exports = {
      flattenCodeArray: flattenCodeArray
    };
  }), {} ],
  104: [ (function(require, module, exports) {
    var JS = require("./js");
    var CCObject = require("./CCObject");
    var Attr = require("./attribute");
    var CCClass = require("./CCClass");
    var Misc = require("../utils/misc");
    var Details = function() {
      this.uuidList = [];
      this.uuidObjList = [];
      this.uuidPropList = [];
      this._stillUseUrl = JS.createMap(true);
    };
    Details.prototype.reset = function() {
      this.uuidList.length = 0;
      this.uuidObjList.length = 0;
      this.uuidPropList.length = 0;
      JS.clear(this._stillUseUrl);
    };
    false, false;
    Details.prototype.push = function(obj, propName, uuid, _stillUseUrl) {
      _stillUseUrl && (this._stillUseUrl[this.uuidList.length] = true);
      this.uuidList.push(uuid);
      this.uuidObjList.push(obj);
      this.uuidPropList.push(propName);
    };
    Details.pool = new JS.Pool(function(obj) {
      obj.reset();
    }, 10);
    Details.pool.get = function() {
      return this._get() || new Details();
    };
    var _Deserializer = (function() {
      function _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly) {
        this.result = result;
        this.customEnv = customEnv;
        this.deserializedList = [];
        this.deserializedData = null;
        this._classFinder = classFinder;
        false;
        this._idList = [];
        this._idObjList = [];
        this._idPropList = [];
      }
      function _dereference(self) {
        var deserializedList = self.deserializedList;
        var idPropList = self._idPropList;
        var idList = self._idList;
        var idObjList = self._idObjList;
        var onDereferenced = self._classFinder && self._classFinder.onDereferenced;
        var i, propName, id;
        false;
        for (i = 0; i < idList.length; i++) {
          propName = idPropList[i];
          id = idList[i];
          idObjList[i][propName] = deserializedList[id];
        }
      }
      var prototype = _Deserializer.prototype;
      prototype.deserialize = function(jsonObj) {
        if (Array.isArray(jsonObj)) {
          var jsonArray = jsonObj;
          var refCount = jsonArray.length;
          this.deserializedList.length = refCount;
          for (var i = 0; i < refCount; i++) if (jsonArray[i]) {
            var mainTarget;
            false, false;
            this.deserializedList[i] = this._deserializeObject(jsonArray[i], false);
          }
          this.deserializedData = refCount > 0 ? this.deserializedList[0] : [];
        } else {
          this.deserializedList.length = 1;
          false, false;
          this.deserializedData = jsonObj ? this._deserializeObject(jsonObj, false) : null;
          this.deserializedList[0] = this.deserializedData;
        }
        _dereference(this);
        return this.deserializedData;
      };
      prototype._deserializeObject = function(serialized, _stillUseUrl, target, owner, propName) {
        var prop;
        var obj = null;
        var klass = null;
        var type = serialized.__type__;
        if (type) {
          klass = this._classFinder(type, serialized, owner, propName);
          if (!klass) {
            var notReported = this._classFinder === JS._getClassById;
            notReported && cc.deserialize.reportMissingClass(type);
            return null;
          }
          if ((false, false) && target) {
            target instanceof klass || cc.warnID(5300, JS.getClassName(target), klass);
            obj = target;
          } else obj = new klass();
          if (obj._deserialize) {
            obj._deserialize(serialized.content, this);
            return obj;
          }
          cc.Class._isCCClass(klass) ? _deserializeFireClass(this, obj, serialized, klass, target) : this._deserializeTypedObject(obj, serialized, klass);
        } else if (Array.isArray(serialized)) {
          if ((false, false) && target) {
            target.length = serialized.length;
            obj = target;
          } else obj = new Array(serialized.length);
          for (var i = 0; i < serialized.length; i++) {
            prop = serialized[i];
            if ("object" === typeof prop && prop) {
              false, false;
              this._deserializeObjField(obj, prop, "" + i, null, _stillUseUrl);
            } else obj[i] = prop;
          }
        } else {
          obj = (false, false) && target || {};
          this._deserializePrimitiveObject(obj, serialized);
        }
        return obj;
      };
      prototype._deserializeObjField = function(obj, jsonObj, propName, target, _stillUseUrl) {
        var id = jsonObj.__id__;
        if ("undefined" === typeof id) {
          var uuid = jsonObj.__uuid__;
          if (uuid) this.result.push(obj, propName, uuid, _stillUseUrl); else {
            false, false;
            obj[propName] = this._deserializeObject(jsonObj, _stillUseUrl);
          }
        } else {
          var dObj = this.deserializedList[id];
          if (dObj) obj[propName] = dObj; else {
            this._idList.push(id);
            this._idObjList.push(obj);
            this._idPropList.push(propName);
          }
        }
      };
      prototype._deserializePrimitiveObject = function(instance, serialized) {
        var self = this;
        for (var propName in serialized) if (serialized.hasOwnProperty(propName)) {
          var prop = serialized[propName];
          if ("object" !== typeof prop) "__type__" !== propName && (instance[propName] = prop); else if (prop) {
            false, false;
            self._deserializeObjField(instance, prop, propName);
          } else instance[propName] = null;
        }
      };
      prototype._deserializeTypedObject = function(instance, serialized, klass) {
        if (klass === cc.Vec2) {
          instance.x = serialized.x || 0;
          instance.y = serialized.y || 0;
          return;
        }
        if (klass === cc.Color) {
          instance.r = serialized.r || 0;
          instance.g = serialized.g || 0;
          instance.b = serialized.b || 0;
          var a = serialized.a;
          instance.a = void 0 === a ? 255 : a;
          return;
        }
        if (klass === cc.Size) {
          instance.width = serialized.width || 0;
          instance.height = serialized.height || 0;
          return;
        }
        var fastDefinedProps = klass.__props__;
        fastDefinedProps || (fastDefinedProps = Object.keys(instance));
        for (var i = 0; i < fastDefinedProps.length; i++) {
          var propName = fastDefinedProps[i];
          var prop = serialized[propName];
          if ("undefined" !== typeof prop && serialized.hasOwnProperty(propName)) if ("object" !== typeof prop) instance[propName] = prop; else if (prop) {
            false, false;
            this._deserializeObjField(instance, prop, propName);
          } else instance[propName] = null;
        }
      };
      var compileObjectType = function(s, o, t, prop, defaultValue, propName, assumeHavePropIfIsValue, stillUseUrl) {
        if (defaultValue instanceof cc.ValueType) {
          var ctor = defaultValue.constructor;
          assumeHavePropIfIsValue ? s._deserializeTypedObject(o[propName], prop, ctor) : prop ? s._deserializeTypedObject(o[propName], prop, ctor) : o[propName] = null;
        } else if (prop) {
          false, false;
          s._deserializeObjField(o, prop, propName, null, stillUseUrl);
        } else o[propName] = null;
      };
      var compileDeserialize = function(self, klass) {
        var TYPE = Attr.DELIMETER + "type";
        var EDITOR_ONLY = Attr.DELIMETER + "editorOnly";
        var SERIALIZABLE = Attr.DELIMETER + "serializable";
        var DEFAULT = Attr.DELIMETER + "default";
        var SAVE_URL_AS_ASSET = Attr.DELIMETER + "saveUrlAsAsset";
        var FORMERLY_SERIALIZED_AS = Attr.DELIMETER + "formerlySerializedAs";
        var attrs = Attr.getClassAttrs(klass);
        var props = klass.__props__;
        var fastMode = Misc.BUILTIN_CLASSID_RE.test(JS._getClassId(klass));
        return function(s, o, d, k, t) {
          var prop;
          for (var p = 0; p < props.length; p++) {
            var propName = props[p];
            if ((false, false) && attrs[propName + EDITOR_ONLY]) {
              var mayUsedInPersistRoot = "_id" === propName && cc.isChildClassOf(klass, cc.Node);
              if (!mayUsedInPersistRoot) continue;
            }
            if (false === attrs[propName + SERIALIZABLE]) continue;
            var propNameToRead = propName;
            attrs[propName + FORMERLY_SERIALIZED_AS] && (propNameToRead = attrs[propName + FORMERLY_SERIALIZED_AS]);
            prop = d[propNameToRead];
            if ("undefined" !== typeof prop) {
              var stillUseUrl = attrs[propName + SAVE_URL_AS_ASSET];
              var defaultValue = CCClass.getDefault(attrs[propName + DEFAULT]);
              if (fastMode) {
                var isPrimitiveType;
                var userType = attrs[propName + TYPE];
                if (void 0 === defaultValue && userType) isPrimitiveType = userType === cc.String || userType === cc.Integer || userType === cc.Float || userType === cc.Boolean; else {
                  var defaultType = typeof defaultValue;
                  isPrimitiveType = "string" === defaultType && !stillUseUrl || "number" === defaultType || "boolean" === defaultType;
                }
                isPrimitiveType ? o[propName] = prop : compileObjectType(s, o, t, prop, defaultValue, propName, true, stillUseUrl);
              } else "object" !== typeof prop ? o[propName] = prop : compileObjectType(s, o, t, prop, defaultValue, propName, false, stillUseUrl);
            }
          }
          if ("_$erialized" === props[props.length - 1]) {
            o._$erialized = JSON.parse(JSON.stringify(d));
            s._deserializePrimitiveObject(o._$erialized, d);
          }
        };
      };
      function unlinkUnusedPrefab(self, serialized, obj) {
        var uuid = serialized["asset"] && serialized["asset"].__uuid__;
        if (uuid) {
          var last = self.result.uuidList.length - 1;
          if (self.result.uuidList[last] === uuid && self.result.uuidObjList[last] === obj && "asset" === self.result.uuidPropList[last]) {
            self.result.uuidList.pop();
            self.result.uuidObjList.pop();
            self.result.uuidPropList.pop();
          } else {
            var debugEnvOnlyInfo = "Failed to skip prefab asset while deserializing PrefabInfo";
            cc.warn(debugEnvOnlyInfo);
          }
        }
      }
      function _deserializeFireClass(self, obj, serialized, klass, target) {
        var deserialize;
        if (klass.hasOwnProperty("__deserialize__")) deserialize = klass.__deserialize__; else {
          deserialize = compileDeserialize(self, klass);
          JS.value(klass, "__deserialize__", deserialize, true);
        }
        deserialize(self, obj, serialized, klass, target);
        false, false;
      }
      _Deserializer.pool = new JS.Pool(function(obj) {
        obj.result = null;
        obj.customEnv = null;
        obj.deserializedList.length = 0;
        obj.deserializedData = null;
        obj._classFinder = null;
        false;
        obj._idList.length = 0;
        obj._idObjList.length = 0;
        obj._idPropList.length = 0;
      }, 1);
      _Deserializer.pool.get = function(result, target, classFinder, customEnv, ignoreEditorOnly) {
        var cache = this._get();
        if (cache) {
          cache.result = result;
          cache.customEnv = customEnv;
          cache._classFinder = classFinder;
          false;
          return cache;
        }
        return new _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly);
      };
      return _Deserializer;
    })();
    cc.deserialize = function(data, details, options) {
      options = options || {};
      var classFinder = options.classFinder || JS._getClassById;
      var createAssetRefs = options.createAssetRefs || cc.sys.platform === cc.sys.EDITOR_CORE;
      var target = (false, false) && options.target;
      var customEnv = options.customEnv;
      var ignoreEditorOnly = options.ignoreEditorOnly;
      false;
      "string" === typeof data && (data = JSON.parse(data));
      var tempDetails = !details;
      details = details || Details.pool.get();
      var deserializer = _Deserializer.pool.get(details, target, classFinder, customEnv, ignoreEditorOnly);
      cc.game._isCloning = true;
      var res = deserializer.deserialize(data);
      cc.game._isCloning = false;
      _Deserializer.pool.put(deserializer);
      createAssetRefs && details.assignAssetsBy(Editor.serialize.asAsset);
      tempDetails && Details.pool.put(details);
      return res;
    };
    cc.deserialize.Details = Details;
    cc.deserialize.reportMissingClass = function(id) {
      false;
      cc.warnID(5302, id);
    };
  }), {
    "../utils/misc": 137,
    "./CCClass": 89,
    "./CCObject": 95,
    "./attribute": 101,
    "./js": 109
  } ],
  105: [ (function(require, module, exports) {
    var NonUuidMark = ".";
    function IdGenerater(category) {
      this.id = 0 | 998 * Math.random();
      this.prefix = category ? category + NonUuidMark : "";
    }
    IdGenerater.prototype.getNewId = function() {
      return this.prefix + ++this.id;
    };
    IdGenerater.global = new IdGenerater("global");
    module.exports = IdGenerater;
  }), {} ],
  106: [ (function(require, module, exports) {
    require("./js");
    require("./CCClass");
    require("./CCClassDecorator");
    require("./CCEnum");
    require("./CCObject");
    require("./callbacks-invoker");
    require("./url");
    require("./deserialize");
    require("./instantiate");
    require("./instantiate-jit");
    require("./requiring-frame");
    require("./CCSys");
    require("./CCMacro");
    true;
    require("./CCAssetLibrary");
    true;
    require("./CCVisibleRect");
  }), {
    "./CCAssetLibrary": 88,
    "./CCClass": 89,
    "./CCClassDecorator": 90,
    "./CCEnum": 91,
    "./CCMacro": 94,
    "./CCObject": 95,
    "./CCSys": 97,
    "./CCVisibleRect": 99,
    "./callbacks-invoker": 102,
    "./deserialize": 104,
    "./instantiate": 108,
    "./instantiate-jit": 107,
    "./js": 109,
    "./requiring-frame": 111,
    "./url": 112
  } ],
  107: [ (function(require, module, exports) {
    var CCObject = require("./CCObject");
    var Destroyed = CCObject.Flags.Destroyed;
    var PersistentMask = CCObject.Flags.PersistentMask;
    var Attr = require("./attribute");
    var JS = require("./js");
    var CCClass = require("./CCClass");
    var Compiler = require("./compiler");
    var SERIALIZABLE = Attr.DELIMETER + "serializable";
    var DEFAULT = Attr.DELIMETER + "default";
    var IDENTIFIER_RE = CCClass.IDENTIFIER_RE;
    var escapeForJS = CCClass.escapeForJS;
    var VAR = "var ";
    var LOCAL_OBJ = "o";
    var LOCAL_TEMP_OBJ = "t";
    var LOCAL_ARRAY = "a";
    var LINE_INDEX_OF_NEW_OBJ = 0;
    var DEFAULT_MODULE_CACHE = {
      "cc.Node": "cc.Node",
      "cc.Sprite": "cc.Sprite",
      "cc.Label": "cc.Label",
      "cc.Button": "cc.Button",
      "cc.Widget": "cc.Widget",
      "cc.Animation": "cc.Animation",
      "cc.ClickEvent": false,
      "cc.PrefabInfo": false
    };
    function Declaration(varName, expression) {
      this.varName = varName;
      this.expression = expression;
    }
    Declaration.prototype.toString = function() {
      return VAR + this.varName + "=" + this.expression + ";";
    };
    function mergeDeclaration(statement, expression) {
      return expression instanceof Declaration ? new Declaration(expression.varName, statement + expression.expression) : statement + expression;
    }
    function writeAssignment(codeArray, statement, expression) {
      if (Array.isArray(expression)) {
        expression[0] = mergeDeclaration(statement, expression[0]);
        codeArray.push(expression);
      } else codeArray.push(mergeDeclaration(statement, expression) + ";");
    }
    function Assignments(targetExpression) {
      this._exps = [];
      this._targetExp = targetExpression;
    }
    Assignments.prototype.append = function(key, expression) {
      this._exps.push([ key, expression ]);
    };
    Assignments.prototype.writeCode = function(codeArray) {
      var targetVar;
      if (this._exps.length > 1) {
        codeArray.push(LOCAL_TEMP_OBJ + "=" + this._targetExp + ";");
        targetVar = LOCAL_TEMP_OBJ;
      } else {
        if (1 !== this._exps.length) return;
        targetVar = this._targetExp;
      }
      for (var i = 0; i < this._exps.length; i++) {
        var pair = this._exps[i];
        writeAssignment(codeArray, targetVar + getPropAccessor(pair[0]) + "=", pair[1]);
      }
    };
    Assignments.pool = new JS.Pool(function(obj) {
      obj._exps.length = 0;
      obj._targetExp = null;
    }, 1);
    Assignments.pool.get = function(targetExpression) {
      var cache = this._get() || new Assignments();
      cache._targetExp = targetExpression;
      return cache;
    };
    function equalsToDefault(def, value) {
      if ("function" === typeof def) try {
        def = def();
      } catch (e) {
        return false;
      }
      if (def === value) return true;
      if (def && value) {
        if (def instanceof cc.ValueType && def.equals(value)) return true;
        if (Array.isArray(def) && Array.isArray(value) || def.constructor === Object && value.constructor === Object) try {
          return JSON.stringify(def) === JSON.stringify(value);
        } catch (e) {}
      }
      return false;
    }
    function getPropAccessor(key) {
      return IDENTIFIER_RE.test(key) ? "." + key : "[" + escapeForJS(key) + "]";
    }
    function Parser(obj, parent) {
      this.parent = parent;
      this.objsToClear_iN$t = [];
      this.codeArray = [];
      this.objs = [];
      this.funcs = [];
      this.funcModuleCache = JS.createMap();
      JS.mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE);
      this.globalVariables = [];
      this.globalVariableId = 0;
      this.localVariableId = 0;
      this.codeArray.push(VAR + LOCAL_OBJ + "," + LOCAL_TEMP_OBJ + ";", "if(R){", LOCAL_OBJ + "=R;", "}else{", LOCAL_OBJ + "=R=new " + this.getFuncModule(obj.constructor, true) + "();", "}");
      obj._iN$t = {
        globalVar: "R"
      };
      this.objsToClear_iN$t.push(obj);
      this.enumerateObject(this.codeArray, obj);
      var globalVariablesDeclaration;
      this.globalVariables.length > 0 && (globalVariablesDeclaration = VAR + this.globalVariables.join(",") + ";");
      var code = Compiler.flattenCodeArray([ "return (function(R){", globalVariablesDeclaration || [], this.codeArray, "return o;", "})" ]);
      this.result = Function("O", "F", code)(this.objs, this.funcs);
      for (var i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) this.objsToClear_iN$t[i]._iN$t = null;
      this.objsToClear_iN$t.length = 0;
    }
    var proto = Parser.prototype;
    proto.getFuncModule = function(func, usedInNew) {
      var clsName = JS.getClassName(func);
      if (clsName) {
        var cache = this.funcModuleCache[clsName];
        if (cache) return cache;
        if (void 0 === cache) {
          var clsNameIsModule = -1 !== clsName.indexOf(".");
          if (clsNameIsModule) try {
            clsNameIsModule = func === Function("return " + clsName)();
            if (clsNameIsModule) {
              this.funcModuleCache[clsName] = clsName;
              return clsName;
            }
          } catch (e) {}
        }
      }
      var index = this.funcs.indexOf(func);
      if (index < 0) {
        index = this.funcs.length;
        this.funcs.push(func);
      }
      var res = "F[" + index + "]";
      usedInNew && (res = "(" + res + ")");
      this.funcModuleCache[clsName] = res;
      return res;
    };
    proto.getObjRef = function(obj) {
      var index = this.objs.indexOf(obj);
      if (index < 0) {
        index = this.objs.length;
        this.objs.push(obj);
      }
      return "O[" + index + "]";
    };
    proto.setValueType = function(codeArray, defaultValue, srcValue, targetExpression) {
      var assignments = Assignments.pool.get(targetExpression);
      var fastDefinedProps = defaultValue.constructor.__props__;
      fastDefinedProps || (fastDefinedProps = Object.keys(defaultValue));
      for (var i = 0; i < fastDefinedProps.length; i++) {
        var propName = fastDefinedProps[i];
        var prop = srcValue[propName];
        if (defaultValue[propName] === prop) continue;
        var expression = this.enumerateField(srcValue, propName, prop);
        assignments.append(propName, expression);
      }
      assignments.writeCode(codeArray);
      Assignments.pool.put(assignments);
    };
    proto.enumerateCCClass = function(codeArray, obj, klass) {
      var props = klass.__props__;
      var attrs = Attr.getClassAttrs(klass);
      for (var p = 0; p < props.length; p++) {
        var key = props[p];
        if ((false, false) && "_id" === key && (obj instanceof cc._BaseNode || obj instanceof cc.Component)) continue;
        if (false !== attrs[key + SERIALIZABLE]) {
          var val = obj[key];
          var defaultValue = attrs[key + DEFAULT];
          if (equalsToDefault(defaultValue, val)) continue;
          if ("object" === typeof val && val instanceof cc.ValueType) {
            var defaultValue = CCClass.getDefault(defaultValue);
            if ((defaultValue && defaultValue.constructor) === val.constructor) {
              var targetExpression = LOCAL_OBJ + getPropAccessor(key);
              this.setValueType(codeArray, defaultValue, val, targetExpression);
              continue;
            }
          }
          this.setObjProp(codeArray, obj, key, val);
        }
      }
    };
    proto.instantiateArray = function(value) {
      if (0 === value.length) return "[]";
      var arrayVar = LOCAL_ARRAY + ++this.localVariableId;
      var declaration = new Declaration(arrayVar, "new Array(" + value.length + ")");
      var codeArray = [ declaration ];
      value._iN$t = {
        globalVar: "",
        source: codeArray
      };
      this.objsToClear_iN$t.push(value);
      for (var i = 0; i < value.length; ++i) {
        var statement = arrayVar + "[" + i + "]=";
        var expression = this.enumerateField(value, i, value[i]);
        writeAssignment(codeArray, statement, expression);
      }
      return codeArray;
    };
    proto.enumerateField = function(obj, key, value) {
      if ("object" === typeof value && value) {
        var _iN$t = value._iN$t;
        if (_iN$t) {
          var globalVar = _iN$t.globalVar;
          if (!globalVar) {
            globalVar = _iN$t.globalVar = "v" + ++this.globalVariableId;
            this.globalVariables.push(globalVar);
            var line = _iN$t.source[LINE_INDEX_OF_NEW_OBJ];
            _iN$t.source[LINE_INDEX_OF_NEW_OBJ] = mergeDeclaration(globalVar + "=", line);
          }
          return globalVar;
        }
        return Array.isArray(value) ? this.instantiateArray(value) : this.instantiateObj(value);
      }
      if ("function" === typeof value) return this.getFuncModule(value);
      if ("string" === typeof value) return escapeForJS(value);
      "_objFlags" === key && cc.Class.isInstanceOf(obj, CCObject) && (value &= PersistentMask);
      return value;
    };
    proto.setObjProp = function(codeArray, obj, key, value) {
      var statement = LOCAL_OBJ + getPropAccessor(key) + "=";
      var expression = this.enumerateField(obj, key, value);
      writeAssignment(codeArray, statement, expression);
    };
    proto.enumerateObject = function(codeArray, obj) {
      var klass = obj.constructor;
      if (cc.Class._isCCClass(klass)) this.enumerateCCClass(codeArray, obj, klass); else for (var key in obj) {
        if (!obj.hasOwnProperty(key) || 95 === key.charCodeAt(0) && 95 === key.charCodeAt(1) && "__type__" !== key) continue;
        var value = obj[key];
        if ("object" === typeof value && value && value === obj._iN$t) continue;
        this.setObjProp(codeArray, obj, key, value);
      }
    };
    proto.instantiateObj = function(obj) {
      if (obj instanceof cc.ValueType) return CCClass.getNewValueTypeCode(obj);
      if (cc.Class.isInstanceOf(obj, cc.Asset)) return this.getObjRef(obj);
      if (obj._objFlags & Destroyed) return null;
      var createCode;
      var ctor = obj.constructor;
      if (cc.Class._isCCClass(ctor)) {
        if (this.parent) if (this.parent instanceof cc.Component) {
          if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return this.getObjRef(obj);
        } else if (this.parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
          if (!obj.isChildOf(this.parent)) return this.getObjRef(obj);
        } else if (obj instanceof cc.Component && !obj.node.isChildOf(this.parent)) return this.getObjRef(obj);
        createCode = new Declaration(LOCAL_OBJ, "new " + this.getFuncModule(ctor, true) + "()");
      } else if (ctor === Object) createCode = new Declaration(LOCAL_OBJ, "{}"); else {
        if (ctor) return this.getObjRef(obj);
        createCode = new Declaration(LOCAL_OBJ, "Object.create(null)");
      }
      var codeArray = [ createCode ];
      obj._iN$t = {
        globalVar: "",
        source: codeArray
      };
      this.objsToClear_iN$t.push(obj);
      this.enumerateObject(codeArray, obj);
      return [ "(function(){", codeArray, "return o;})();" ];
    };
    function compile(node) {
      var root = node instanceof cc._BaseNode && node;
      var parser = new Parser(node, root);
      return parser.result;
    }
    module.exports = {
      compile: compile,
      equalsToDefault: equalsToDefault
    };
    false;
  }), {
    "./CCClass": 89,
    "./CCObject": 95,
    "./attribute": 101,
    "./compiler": 103,
    "./js": 109
  } ],
  108: [ (function(require, module, exports) {
    var CCObject = require("./CCObject");
    var Destroyed = CCObject.Flags.Destroyed;
    var PersistentMask = CCObject.Flags.PersistentMask;
    var Attr = require("./attribute");
    var _isDomNode = require("./utils").isDomNode;
    function instantiate(original, internal_force) {
      if (!internal_force) {
        if ("object" !== typeof original || Array.isArray(original)) {
          false;
          return null;
        }
        if (!original) {
          false;
          return null;
        }
        if (!cc.isValid(original)) {
          false;
          return null;
        }
        false;
      }
      var clone;
      if (cc.Class.isInstanceOf(original, CCObject)) {
        if (original._instantiate) {
          cc.game._isCloning = true;
          clone = original._instantiate();
          cc.game._isCloning = false;
          return clone;
        }
        if (cc.Class.isInstanceOf(original, cc.Asset)) {
          false;
          return null;
        }
      }
      cc.game._isCloning = true;
      clone = doInstantiate(original);
      cc.game._isCloning = false;
      return clone;
    }
    var objsToClearTmpVar = [];
    function doInstantiate(obj, parent) {
      if (Array.isArray(obj)) {
        false;
        return null;
      }
      if ((true, _isDomNode) && _isDomNode(obj)) {
        false;
        return null;
      }
      var clone;
      if (obj._iN$t) clone = obj._iN$t; else if (obj.constructor) {
        var klass = obj.constructor;
        clone = new klass();
      } else clone = Object.create(null);
      enumerateObject(obj, clone, parent);
      for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) objsToClearTmpVar[i]._iN$t = null;
      objsToClearTmpVar.length = 0;
      return clone;
    }
    var SERIALIZABLE = Attr.DELIMETER + "serializable";
    function enumerateCCClass(klass, obj, clone, parent) {
      var props = klass.__props__;
      var attrs = Attr.getClassAttrs(klass);
      for (var p = 0; p < props.length; p++) {
        var key = props[p];
        if (false !== attrs[key + SERIALIZABLE]) {
          var value = obj[key];
          clone[key] = "object" === typeof value && value ? value._iN$t || instantiateObj(value, parent) : value;
        }
      }
      (false, false) && (obj instanceof cc._BaseNode || obj instanceof cc.Component) && (clone._id = "");
    }
    function enumerateObject(obj, clone, parent) {
      obj._iN$t = clone;
      objsToClearTmpVar.push(obj);
      var klass = obj.constructor;
      if (cc.Class._isCCClass(klass)) enumerateCCClass(klass, obj, clone, parent); else for (var key in obj) {
        if (!obj.hasOwnProperty(key) || 95 === key.charCodeAt(0) && 95 === key.charCodeAt(1) && "__type__" !== key) continue;
        var value = obj[key];
        if ("object" === typeof value && value) {
          if (value === clone) continue;
          clone[key] = value._iN$t || instantiateObj(value, parent);
        } else clone[key] = value;
      }
      cc.Class.isInstanceOf(obj, CCObject) && (clone._objFlags &= PersistentMask);
    }
    function instantiateObj(obj, parent) {
      if (obj instanceof cc.ValueType) return obj.clone();
      if (cc.Class.isInstanceOf(obj, cc.Asset)) return obj;
      var clone;
      if (Array.isArray(obj)) {
        var len = obj.length;
        clone = new Array(len);
        obj._iN$t = clone;
        for (var i = 0; i < len; ++i) {
          var value = obj[i];
          clone[i] = "object" === typeof value && value ? value._iN$t || instantiateObj(value, parent) : value;
        }
        objsToClearTmpVar.push(obj);
        return clone;
      }
      if (obj._objFlags & Destroyed) return null;
      var ctor = obj.constructor;
      if (cc.Class._isCCClass(ctor)) {
        if (parent) if (parent instanceof cc.Component) {
          if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return obj;
        } else if (parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
          if (!obj.isChildOf(parent)) return obj;
        } else if (obj instanceof cc.Component && !obj.node.isChildOf(parent)) return obj;
        clone = new ctor();
      } else if (ctor === Object) clone = {}; else {
        if (ctor) return obj;
        clone = Object.create(null);
      }
      enumerateObject(obj, clone, parent);
      return clone;
    }
    instantiate._clone = doInstantiate;
    cc.instantiate = instantiate;
    module.exports = instantiate;
  }), {
    "./CCObject": 95,
    "./attribute": 101,
    "./utils": 113
  } ],
  109: [ (function(require, module, exports) {
    var tempCIDGenerater = new (require("./id-generater"))("TmpCId.");
    function _getPropertyDescriptor(obj, name) {
      while (obj) {
        var pd = Object.getOwnPropertyDescriptor(obj, name);
        if (pd) return pd;
        obj = Object.getPrototypeOf(obj);
      }
      return null;
    }
    function _copyprop(name, source, target) {
      var pd = _getPropertyDescriptor(source, name);
      Object.defineProperty(target, name, pd);
    }
    var js = {
      isNumber: function(obj) {
        return "number" === typeof obj || obj instanceof Number;
      },
      isString: function(obj) {
        return "string" === typeof obj || obj instanceof String;
      },
      addon: function(obj) {
        "use strict";
        obj = obj || {};
        for (var i = 1, length = arguments.length; i < length; i++) {
          var source = arguments[i];
          if (source) {
            if ("object" !== typeof source) {
              cc.errorID(5402, source);
              continue;
            }
            for (var name in source) name in obj || _copyprop(name, source, obj);
          }
        }
        return obj;
      },
      mixin: function(obj) {
        "use strict";
        obj = obj || {};
        for (var i = 1, length = arguments.length; i < length; i++) {
          var source = arguments[i];
          if (source) {
            if ("object" !== typeof source) {
              cc.errorID(5403, source);
              continue;
            }
            for (var name in source) _copyprop(name, source, obj);
          }
        }
        return obj;
      },
      extend: function(cls, base) {
        false;
        for (var p in base) base.hasOwnProperty(p) && (cls[p] = base[p]);
        cls.prototype = Object.create(base.prototype, {
          constructor: {
            value: cls,
            writable: true,
            configurable: true
          }
        });
        return cls;
      },
      getSuper: function(ctor) {
        false;
        var proto = ctor.prototype;
        var dunderProto = proto && Object.getPrototypeOf(proto);
        return dunderProto && dunderProto.constructor;
      },
      clear: function(obj) {
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) delete obj[keys[i]];
      },
      getPropertyDescriptor: _getPropertyDescriptor
    };
    var tmpValueDesc = {
      value: void 0,
      enumerable: false,
      writable: false,
      configurable: true
    };
    js.value = function(obj, prop, value, writable, enumerable) {
      tmpValueDesc.value = value;
      tmpValueDesc.writable = writable;
      tmpValueDesc.enumerable = enumerable;
      Object.defineProperty(obj, prop, tmpValueDesc);
      tmpValueDesc.value = void 0;
    };
    var tmpGetSetDesc = {
      get: null,
      set: null,
      enumerable: false
    };
    js.getset = function(obj, prop, getter, setter, enumerable) {
      if ("function" !== typeof setter) {
        enumerable = setter;
        setter = void 0;
      }
      tmpGetSetDesc.get = getter;
      tmpGetSetDesc.set = setter;
      tmpGetSetDesc.enumerable = enumerable;
      Object.defineProperty(obj, prop, tmpGetSetDesc);
      tmpGetSetDesc.get = null;
      tmpGetSetDesc.set = null;
    };
    var tmpGetDesc = {
      get: null,
      enumerable: false,
      configurable: false
    };
    js.get = function(obj, prop, getter, enumerable, configurable) {
      tmpGetDesc.get = getter;
      tmpGetDesc.enumerable = enumerable;
      tmpGetDesc.configurable = configurable;
      Object.defineProperty(obj, prop, tmpGetDesc);
      tmpGetDesc.get = null;
    };
    var tmpSetDesc = {
      set: null,
      enumerable: false,
      configurable: false
    };
    js.set = function(obj, prop, setter, enumerable, configurable) {
      tmpSetDesc.set = setter;
      tmpSetDesc.enumerable = enumerable;
      tmpSetDesc.configurable = configurable;
      Object.defineProperty(obj, prop, tmpSetDesc);
      tmpSetDesc.set = null;
    };
    js.getClassName = function(objOrCtor) {
      if ("function" === typeof objOrCtor) {
        var prototype = objOrCtor.prototype;
        if (prototype && prototype.hasOwnProperty("__classname__") && prototype.__classname__) return prototype.__classname__;
        var retval = "";
        objOrCtor.name && (retval = objOrCtor.name);
        if (objOrCtor.toString) {
          var arr, str = objOrCtor.toString();
          arr = "[" === str.charAt(0) ? str.match(/\[\w+\s*(\w+)\]/) : str.match(/function\s*(\w+)/);
          arr && 2 === arr.length && (retval = arr[1]);
        }
        return "Object" !== retval ? retval : "";
      }
      if (objOrCtor && objOrCtor.constructor) return js.getClassName(objOrCtor.constructor);
      return "";
    };
    function isTempClassId(id) {
      return "string" !== typeof id || id.startsWith(tempCIDGenerater.prefix);
    }
    (function() {
      var _idToClass = {};
      var _nameToClass = {};
      function getRegister(key, table) {
        return function(id, constructor) {
          constructor.prototype.hasOwnProperty(key) && delete table[constructor.prototype[key]];
          js.value(constructor.prototype, key, id);
          if (id) {
            var registered = table[id];
            if (registered && registered !== constructor) {
              var error = "A Class already exists with the same " + key + ' : "' + id + '".';
              false;
              cc.error(error);
            } else table[id] = constructor;
          }
        };
      }
      js._setClassId = getRegister("__cid__", _idToClass);
      var doSetClassName = getRegister("__classname__", _nameToClass);
      js.setClassName = function(className, constructor) {
        doSetClassName(className, constructor);
        if (!constructor.prototype.hasOwnProperty("__cid__")) {
          var id = className || tempCIDGenerater.getNewId();
          id && js._setClassId(id, constructor);
        }
      };
      js.unregisterClass = function() {
        for (var i = 0; i < arguments.length; i++) {
          var p = arguments[i].prototype;
          var classId = p.__cid__;
          classId && delete _idToClass[classId];
          var classname = p.__classname__;
          classname && delete _nameToClass[classname];
        }
      };
      js._getClassById = function(classId) {
        return _idToClass[classId];
      };
      js.getClassByName = function(classname) {
        return _nameToClass[classname];
      };
      js._getClassId = function(obj, allowTempId) {
        allowTempId = "undefined" === typeof allowTempId || allowTempId;
        var res;
        if ("function" === typeof obj && obj.prototype.hasOwnProperty("__cid__")) {
          res = obj.prototype.__cid__;
          if (!allowTempId && (false, false) && isTempClassId(res)) return "";
          return res;
        }
        if (obj && obj.constructor) {
          var prototype = obj.constructor.prototype;
          if (prototype && prototype.hasOwnProperty("__cid__")) {
            res = obj.__cid__;
            if (!allowTempId && (false, false) && isTempClassId(res)) return "";
            return res;
          }
        }
        return "";
      };
      false;
    })();
    js.obsolete = function(obj, obsoleted, newExpr, writable) {
      var extractPropName = /([^.]+)$/;
      var oldProp = extractPropName.exec(obsoleted)[0];
      var newProp = extractPropName.exec(newExpr)[0];
      function get() {
        false;
        return this[newProp];
      }
      writable ? js.getset(obj, oldProp, get, (function(value) {
        false;
        this[newProp] = value;
      })) : js.get(obj, oldProp, get);
    };
    js.obsoletes = function(obj, objName, props, writable) {
      for (var obsoleted in props) {
        var newName = props[obsoleted];
        js.obsolete(obj, objName + "." + obsoleted, newName, writable);
      }
    };
    var REGEXP_NUM_OR_STR = /(%d)|(%s)/;
    var REGEXP_STR = /%s/;
    js.formatStr = function() {
      var argLen = arguments.length;
      if (0 === argLen) return "";
      var msg = arguments[0];
      if (1 === argLen) return "" + msg;
      var hasSubstitution = "string" === typeof msg && REGEXP_NUM_OR_STR.test(msg);
      if (hasSubstitution) for (var i = 1; i < argLen; ++i) {
        var arg = arguments[i];
        var regExpToTest = "number" === typeof arg ? REGEXP_NUM_OR_STR : REGEXP_STR;
        regExpToTest.test(msg) ? msg = msg.replace(regExpToTest, arg) : msg += " " + arg;
      } else for (var _i = 1; _i < argLen; ++_i) msg += " " + arguments[_i];
      return msg;
    };
    js.shiftArguments = function() {
      var len = arguments.length - 1;
      var args = new Array(len);
      for (var i = 0; i < len; ++i) args[i] = arguments[i + 1];
      return args;
    };
    js.createMap = function(forceDictMode) {
      var map = Object.create(null);
      if (forceDictMode) {
        var INVALID_IDENTIFIER_1 = ".";
        var INVALID_IDENTIFIER_2 = "/";
        map[INVALID_IDENTIFIER_1] = true;
        map[INVALID_IDENTIFIER_2] = true;
        delete map[INVALID_IDENTIFIER_1];
        delete map[INVALID_IDENTIFIER_2];
      }
      return map;
    };
    function removeAt(array, index) {
      array.splice(index, 1);
    }
    function fastRemoveAt(array, index) {
      var length = array.length;
      if (index < 0 || index >= length) return;
      array[index] = array[length - 1];
      array.length = length - 1;
    }
    function remove(array, value) {
      var index = array.indexOf(value);
      if (index >= 0) {
        removeAt(array, index);
        return true;
      }
      return false;
    }
    function fastRemove(array, value) {
      var index = array.indexOf(value);
      if (index >= 0) {
        array[index] = array[array.length - 1];
        --array.length;
      }
    }
    function verifyType(array, type) {
      if (array && array.length > 0) for (var i = 0; i < array.length; i++) if (!(array[i] instanceof type)) {
        cc.logID(1300);
        return false;
      }
      return true;
    }
    function removeArray(array, minusArr) {
      for (var i = 0, l = minusArr.length; i < l; i++) remove(array, minusArr[i]);
    }
    function appendObjectsAt(array, addObjs, index) {
      array.splice.apply(array, [ index, 0 ].concat(addObjs));
      return array;
    }
    var indexOf = Array.prototype.indexOf;
    function contains(array, value) {
      return array.indexOf(value) >= 0;
    }
    function copy(array) {
      var i, len = array.length, arr_clone = new Array(len);
      for (i = 0; i < len; i += 1) arr_clone[i] = array[i];
      return arr_clone;
    }
    js.array = {
      remove: remove,
      fastRemove: fastRemove,
      removeAt: removeAt,
      fastRemoveAt: fastRemoveAt,
      contains: contains,
      verifyType: verifyType,
      removeArray: removeArray,
      appendObjectsAt: appendObjectsAt,
      copy: copy,
      indexOf: indexOf,
      MutableForwardIterator: require("../utils/mutable-forward-iterator")
    };
    function Pool(cleanupFunc, size) {
      if ("number" === typeof cleanupFunc) {
        size = cleanupFunc;
        cleanupFunc = null;
      }
      this.get = null;
      this.count = 0;
      this._pool = new Array(size);
      this._cleanup = cleanupFunc;
    }
    Pool.prototype._get = function() {
      if (this.count > 0) {
        --this.count;
        var cache = this._pool[this.count];
        this._pool[this.count] = null;
        return cache;
      }
      return null;
    };
    Pool.prototype.put = function(obj) {
      var pool = this._pool;
      if (this.count < pool.length) {
        if (this._cleanup && false === this._cleanup(obj)) return;
        pool[this.count] = obj;
        ++this.count;
      }
    };
    Pool.prototype.resize = function(length) {
      if (length >= 0) {
        this._pool.length = length;
        this.count > length && (this.count = length);
      }
    };
    js.Pool = Pool;
    cc.js = js;
    module.exports = js;
  }), {
    "../utils/mutable-forward-iterator": 138,
    "./id-generater": 105
  } ],
  110: [ (function(require, module, exports) {
    var SerializableAttrs = {
      url: {
        canUsedInGet: true
      },
      default: {},
      serializable: {},
      editorOnly: {},
      formerlySerializedAs: {}
    };
    var TYPO_TO_CORRECT_DEV = false;
    function parseNotify(val, propName, notify, properties) {
      if (val.get || val.set) {
        false;
        return;
      }
      if (val.hasOwnProperty("default")) {
        var newKey = "_N$" + propName;
        val.get = function() {
          return this[newKey];
        };
        val.set = function(value) {
          var oldValue = this[newKey];
          this[newKey] = value;
          notify.call(this, oldValue);
        };
        var newValue = {};
        properties[newKey] = newValue;
        for (var attr in SerializableAttrs) {
          var v = SerializableAttrs[attr];
          if (val.hasOwnProperty(attr)) {
            newValue[attr] = val[attr];
            v.canUsedInGet || delete val[attr];
          }
        }
      } else false;
    }
    function checkUrl(val, className, propName, url) {
      Array.isArray(url) && url.length > 0 && (url = url[0]);
      false;
      val.type = url;
    }
    function parseType(val, type, className, propName) {
      if (Array.isArray(type)) {
        var isArray;
        false;
        if (!(type.length > 0)) return cc.errorID(5508, className, propName);
        if (cc.RawAsset.isRawAssetType(type[0])) {
          val.url = type[0];
          delete val.type;
          return;
        }
        val.type = type = type[0];
      }
      false;
    }
    function postCheckType(val, type, className, propName) {
      false;
    }
    function getBaseClassWherePropertyDefined_DEV(propName, cls) {
      var res;
      false;
    }
    exports.getFullFormOfProperty = function(options, propname_dev, classname_dev) {
      var isLiteral = options && options.constructor === Object;
      if (!isLiteral) {
        if (Array.isArray(options) && options.length > 0) {
          var type = options[0];
          false;
          return {
            default: [],
            type: options,
            _short: true
          };
        }
        if ("function" === typeof options) {
          var type = options;
          if (!cc.RawAsset.isRawAssetType(type)) {
            if (!cc.RawAsset.wasRawAssetType(type)) return {
              default: cc.isChildClassOf(type, cc.ValueType) ? new type() : null,
              type: type,
              _short: true
            };
            false;
          }
          return {
            default: "",
            url: type,
            _short: true
          };
        }
        return {
          default: options,
          _short: true
        };
      }
      return null;
    };
    exports.preprocessAttrs = function(properties, className, cls, es6) {
      for (var propName in properties) {
        var val = properties[propName];
        var fullForm = exports.getFullFormOfProperty(val, propName, className);
        fullForm && (val = properties[propName] = fullForm);
        if (val) {
          var maybeTypeScript;
          false;
          var baseClass;
          false;
          var notify = val.notify;
          if (notify) {
            false;
            parseNotify(val, propName, notify, properties);
          }
          "type" in val && parseType(val, val.type, className, propName);
          "url" in val && checkUrl(val, className, propName, val.url);
          "type" in val && postCheckType(val, val.type, className, propName);
        }
      }
    };
    false;
    exports.validateMethodWithProps = function(func, funcName, className, cls, base) {
      false;
      if ("function" !== typeof func && null !== func) {
        var overrided;
        var baseFuc;
        var subFuc;
        var correct;
        false;
        return false;
      }
      false;
      return true;
    };
  }), {
    "./CCClass": 89
  } ],
  111: [ (function(require, module, exports) {
    var requiringFrames = [];
    cc._RF = {
      push: function(module, uuid, script) {
        if (void 0 === script) {
          script = uuid;
          uuid = "";
        }
        requiringFrames.push({
          uuid: uuid,
          script: script,
          module: module,
          exports: module.exports,
          beh: null
        });
      },
      pop: function() {
        var frameInfo = requiringFrames.pop();
        var module = frameInfo.module;
        var exports = module.exports;
        if (exports === frameInfo.exports) {
          for (var anyKey in exports) return;
          module.exports = exports = frameInfo.cls;
        }
      },
      peek: function() {
        return requiringFrames[requiringFrames.length - 1];
      }
    };
    false;
  }), {} ],
  112: [ (function(require, module, exports) {
    cc.url = {
      _rawAssets: "",
      normalize: function(url) {
        url && (46 === url.charCodeAt(0) && 47 === url.charCodeAt(1) ? url = url.slice(2) : 47 === url.charCodeAt(0) && (url = url.slice(1)));
        return url;
      },
      raw: function(url) {
        false;
        url = this.normalize(url);
        if (url.startsWith("resources/")) {
          var uuid = cc.loader._getResUuid(url.slice(10), cc.Asset, true);
          if (uuid) return cc.AssetLibrary.getLibUrlNoExt(uuid, true) + cc.path.extname(url);
        } else cc.errorID(7002, url);
        return this._rawAssets + url;
      },
      _init: function(assets) {
        this._rawAssets = cc.path.stripSep(assets) + "/";
      }
    };
    module.exports = cc.url;
  }), {} ],
  113: [ (function(require, module, exports) {
    module.exports = {
      contains: function(refNode, otherNode) {
        if ("function" == typeof refNode.contains) return refNode.contains(otherNode);
        if ("function" == typeof refNode.compareDocumentPosition) return !!(16 & refNode.compareDocumentPosition(otherNode));
        var node = otherNode.parentNode;
        if (node) do {
          if (node === refNode) return true;
          node = node.parentNode;
        } while (null !== node);
        return false;
      },
      isDomNode: "object" === typeof window && ("function" === typeof Node ? function(obj) {
        return obj instanceof Node;
      } : function(obj) {
        return obj && "object" === typeof obj && "number" === typeof obj.nodeType && "string" === typeof obj.nodeName;
      }),
      callInNextTick: function(callback, p1, p2) {
        callback && setTimeout((function() {
          callback(p1, p2);
        }), 0);
      }
    };
    false;
    false;
  }), {} ],
  114: [ (function(require, module, exports) {
    require("./platform/js");
    require("./value-types");
    require("./utils");
    require("./platform/CCInputManager");
    require("./platform/CCInputExtension");
    require("./event");
    require("./platform/CCSys");
    require("./platform/CCMacro");
    require("./load-pipeline");
    require("./textures");
    require("./CCDirector");
    require("./CCDirectorWebGL");
    require("./CCDirectorCanvas");
    true;
    require("./platform/CCView");
    require("./platform/CCScreen");
    require("./CCScheduler");
    require("./event-manager");
    require("./renderer");
  }), {
    "./CCDirector": 8,
    "./CCDirectorCanvas": 9,
    "./CCDirectorWebGL": 10,
    "./CCScheduler": 17,
    "./event": 62,
    "./event-manager": 58,
    "./load-pipeline": 75,
    "./platform/CCInputExtension": 92,
    "./platform/CCInputManager": 93,
    "./platform/CCMacro": 94,
    "./platform/CCScreen": 96,
    "./platform/CCSys": 97,
    "./platform/CCView": 98,
    "./platform/js": 109,
    "./renderer": 118,
    "./textures": 130,
    "./utils": 136,
    "./value-types": 150
  } ],
  115: [ (function(require, module, exports) {
    var Region = function() {
      this._minX = 0;
      this._minY = 0;
      this._maxX = 0;
      this._maxY = 0;
      this._width = 0;
      this._height = 0;
      this._area = 0;
    };
    var regionProto = Region.prototype;
    var regionPool = [];
    function regionCreate() {
      var region = regionPool.pop();
      region || (region = new Region());
      return region;
    }
    function regionRelease(region) {
      regionPool.push(region);
    }
    regionProto.setTo = function(minX, minY, maxX, maxY) {
      this._minX = minX;
      this._minY = minY;
      this._maxX = maxX;
      this._maxY = maxY;
      this.updateArea();
      return this;
    };
    regionProto.intValues = function() {
      this._minX = Math.floor(this._minX);
      this._minY = Math.floor(this._minY);
      this._maxX = Math.ceil(this._maxX);
      this._maxY = Math.ceil(this._maxY);
      this.updateArea();
    };
    regionProto.updateArea = function() {
      this._width = this._maxX - this._minX;
      this._height = this._maxY - this._minY;
      this._area = this._width * this._height;
    };
    regionProto.union = function(target) {
      if (this.isEmpty()) {
        this.setTo(target._minX, target._minY, target._maxX, target._maxY);
        return;
      }
      this._minX > target._minX && (this._minX = target._minX);
      this._minY > target._minY && (this._minY = target._minY);
      this._maxX < target._maxX && (this._maxX = target._maxX);
      this._maxY < target._maxY && (this._maxY = target._maxY);
      this.updateArea();
    };
    regionProto.setEmpty = function() {
      this._minX = 0;
      this._minY = 0;
      this._maxX = 0;
      this._maxY = 0;
      this._width = 0;
      this._height = 0;
      this._area = 0;
    };
    regionProto.isEmpty = function() {
      return this._width <= 0 || this._height <= 0;
    };
    regionProto.intersects = function(target) {
      if (this.isEmpty() || target.isEmpty()) return false;
      var max = this._minX > target._minX ? this._minX : target._minX;
      var min = this._maxX < target._maxX ? this._maxX : target._maxX;
      if (max > min) return false;
      max = this._minY > target._minY ? this._minY : target._minY;
      min = this._maxY < target._maxY ? this._maxY : target._maxY;
      return max <= min;
    };
    regionProto.updateRegion = function(bounds, matrix) {
      if (0 === bounds.width || 0 === bounds.height) {
        this.setEmpty();
        return;
      }
      var m = matrix;
      var a = m.a;
      var b = m.b;
      var c = m.c;
      var d = m.d;
      var tx = m.tx;
      var ty = m.ty;
      var x = bounds.x;
      var y = bounds.y;
      var xMax = x + bounds.width;
      var yMax = y + bounds.height;
      var minX, minY, maxX, maxY;
      if (1 === a && 0 === b && 0 === c && 1 === d) {
        minX = x + tx - 1;
        minY = y + ty - 1;
        maxX = xMax + tx + 1;
        maxY = yMax + ty + 1;
      } else {
        var x0 = a * x + c * y + tx;
        var y0 = b * x + d * y + ty;
        var x1 = a * xMax + c * y + tx;
        var y1 = b * xMax + d * y + ty;
        var x2 = a * xMax + c * yMax + tx;
        var y2 = b * xMax + d * yMax + ty;
        var x3 = a * x + c * yMax + tx;
        var y3 = b * x + d * yMax + ty;
        var tmp = 0;
        if (x0 > x1) {
          tmp = x0;
          x0 = x1;
          x1 = tmp;
        }
        if (x2 > x3) {
          tmp = x2;
          x2 = x3;
          x3 = tmp;
        }
        minX = (x0 < x2 ? x0 : x2) - 1;
        maxX = (x1 > x3 ? x1 : x3) + 1;
        if (y0 > y1) {
          tmp = y0;
          y0 = y1;
          y1 = tmp;
        }
        if (y2 > y3) {
          tmp = y2;
          y2 = y3;
          y3 = tmp;
        }
        minY = (y0 < y2 ? y0 : y2) - 1;
        maxY = (y1 > y3 ? y1 : y3) + 1;
      }
      this._minX = minX;
      this._minY = minY;
      this._maxX = maxX;
      this._maxY = maxY;
      this._width = maxX - minX;
      this._height = maxY - minY;
      this._area = this._width * this._height;
    };
    function unionArea(r1, r2) {
      var minX = r1._minX < r2._minX ? r1._minX : r2._minX;
      var minY = r1._minY < r2._minY ? r1._minY : r2._minY;
      var maxX = r1._maxX > r2._maxX ? r1._maxX : r2._maxX;
      var maxY = r1._maxY > r2._maxY ? r1._maxY : r2._maxY;
      return (maxX - minX) * (maxY - minY);
    }
    var DirtyRegion = function() {
      this.dirtyList = [];
      this.hasClipRect = false;
      this.clipWidth = 0;
      this.clipHeight = 0;
      this.clipArea = 0;
      this.clipRectChanged = false;
    };
    var dirtyRegionProto = DirtyRegion.prototype;
    dirtyRegionProto.setClipRect = function(width, height) {
      this.hasClipRect = true;
      this.clipRectChanged = true;
      this.clipWidth = Math.ceil(width);
      this.clipHeight = Math.ceil(height);
      this.clipArea = this.clipWidth * this.clipHeight;
    };
    dirtyRegionProto.addRegion = function(target) {
      var minX = target._minX, minY = target._minY, maxX = target._maxX, maxY = target._maxY;
      if (this.hasClipRect) {
        minX < 0 && (minX = 0);
        minY < 0 && (minY = 0);
        maxX > this.clipWidth && (maxX = this.clipWidth);
        maxY > this.clipHeight && (maxY = this.clipHeight);
      }
      if (minX >= maxX || minY >= maxY) return false;
      if (this.clipRectChanged) return true;
      var dirtyList = this.dirtyList;
      var region = regionCreate();
      dirtyList.push(region.setTo(minX, minY, maxX, maxY));
      this.mergeDirtyList(dirtyList);
      return true;
    };
    dirtyRegionProto.clear = function() {
      var dirtyList = this.dirtyList;
      var length = dirtyList.length;
      for (var i = 0; i < length; i++) regionRelease(dirtyList[i]);
      dirtyList.length = 0;
    };
    dirtyRegionProto.getDirtyRegions = function() {
      var dirtyList = this.dirtyList;
      if (this.clipRectChanged) {
        this.clipRectChanged = false;
        this.clear();
        var region = regionCreate();
        dirtyList.push(region.setTo(0, 0, this.clipWidth, this.clipHeight));
      } else while (this.mergeDirtyList(dirtyList)) ;
      var numDirty = this.dirtyList.length;
      if (numDirty > 0) for (var i = 0; i < numDirty; i++) this.dirtyList[i].intValues();
      return this.dirtyList;
    };
    dirtyRegionProto.mergeDirtyList = function(dirtyList) {
      var length = dirtyList.length;
      if (length < 2) return false;
      var hasClipRect = this.hasClipRect;
      var bestDelta = length > 3 ? Number.POSITIVE_INFINITY : 0;
      var mergeA = 0;
      var mergeB = 0;
      var totalArea = 0;
      for (var i = 0; i < length - 1; i++) {
        var regionA = dirtyList[i];
        hasClipRect && (totalArea += regionA.area);
        for (var j = i + 1; j < length; j++) {
          var regionB = dirtyList[j];
          var delta = unionArea(regionA, regionB) - regionA.area - regionB.area;
          if (bestDelta > delta) {
            mergeA = i;
            mergeB = j;
            bestDelta = delta;
          }
        }
      }
      hasClipRect && totalArea / this.clipArea > .95 && (this.clipRectChanged = true);
      if (mergeA !== mergeB) {
        var region = dirtyList[mergeB];
        dirtyList[mergeA].union(region);
        regionRelease(region);
        dirtyList.splice(mergeB, 1);
        return true;
      }
      return false;
    };
    cc.Region = Region;
    cc.DirtyRegion = DirtyRegion;
  }), {} ],
  116: [ (function(require, module, exports) {
    cc.rendererCanvas = {
      childrenOrderDirty: true,
      assignedZ: 0,
      assignedZStep: 1e-4,
      _transformNodePool: [],
      _renderCmds: [],
      _isCacheToCanvasOn: false,
      _cacheToCanvasCmds: {},
      _cacheInstanceIds: [],
      _currentID: 0,
      _clearColor: cc.color(),
      _clearFillStyle: "rgb(0, 0, 0)",
      _dirtyRegion: null,
      _allNeedDraw: true,
      _enableDirtyRegion: false,
      _debugDirtyRegion: false,
      _dirtyRegionCountThreshold: 10,
      init: function() {
        cc.sys.browserType === cc.sys.BROWSER_TYPE_IE && this.enableDirtyRegion(false);
      },
      getRenderCmd: function(renderableObject) {
        return renderableObject._createRenderCmd();
      },
      enableDirtyRegion: function(enabled) {
        this._enableDirtyRegion = enabled;
      },
      isDirtyRegionEnabled: function() {
        return this._enableDirtyRegion;
      },
      setDirtyRegionCountThreshold: function(threshold) {
        this._dirtyRegionCountThreshold = threshold;
      },
      _collectDirtyRegion: function() {
        var locCmds = this._renderCmds, i, len;
        var dirtyRegion = this._dirtyRegion;
        var localStatus = _ccsg.Node.CanvasRenderCmd.RegionStatus;
        var dirtryRegionCount = 0;
        var result = true;
        for (i = 0, len = locCmds.length; i < len; i++) {
          var cmd = locCmds[i];
          var regionFlag = cmd._regionFlag;
          var oldRegion = cmd._oldRegion;
          var currentRegion = cmd._currentRegion;
          if (regionFlag > localStatus.NotDirty) {
            ++dirtryRegionCount;
            dirtryRegionCount > this._dirtyRegionCountThreshold && (result = false);
            if (result) {
              !currentRegion.isEmpty() && dirtyRegion.addRegion(currentRegion);
              cmd._regionFlag > localStatus.Dirty && !oldRegion.isEmpty() && dirtyRegion.addRegion(oldRegion);
            }
            cmd._regionFlag = localStatus.NotDirty;
          }
        }
        return result;
      },
      _beginDrawDirtyRegion: function(ctxWrapper) {
        var ctx = ctxWrapper.getContext();
        var dirtyList = this._dirtyRegion.getDirtyRegions();
        ctx.save();
        ctxWrapper.setTransform({
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          tx: 0,
          ty: 0
        }, 1, 1);
        ctx.beginPath();
        var x = 0, y = 0, width = 0, height = 0, scaleX = ctxWrapper._scaleX, scaleY = ctxWrapper._scaleY;
        for (var index = 0, count = dirtyList.length; index < count; ++index) {
          var region = dirtyList[index];
          x = (region._minX * scaleX | 0) - 1;
          y = (-region._maxY * scaleX | 0) - 1;
          width = 2 + (region._width * scaleX | 0);
          height = 2 + (region._height * scaleY | 0);
          ctx.rect(x, y, width, height);
        }
        ctx.clip();
      },
      _endDrawDirtyRegion: function(ctx) {
        ctx.restore();
      },
      _debugDrawDirtyRegion: function(ctxWrapper) {
        if (!this._debugDirtyRegion) return;
        var ctx = ctxWrapper.getContext();
        var dirtyList = this._dirtyRegion.getDirtyRegions();
        ctxWrapper.setTransform({
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          tx: 0,
          ty: 0
        }, 1, 1);
        ctx.beginPath();
        var x = 0, y = 0, width = 0, height = 0, scaleX = ctxWrapper._scaleX, scaleY = ctxWrapper._scaleY;
        for (var index = 0, count = dirtyList.length; index < count; ++index) {
          var region = dirtyList[index];
          x = (region._minX * scaleX | 0) - 1;
          y = (-region._maxY * scaleX | 0) - 1;
          width = 2 + (region._width * scaleX | 0);
          height = 2 + (region._height * scaleY | 0);
          ctx.rect(x, y, width, height);
        }
        var oldstyle = ctx.fillStyle;
        ctx.fillStyle = "green";
        ctx.fill();
        ctx.fillStyle = oldstyle;
      },
      rendering: function(ctxWrapper) {
        var dirtyRegion = this._dirtyRegion = this._dirtyRegion || new cc.DirtyRegion();
        var viewport = cc._canvas;
        var wrapper = ctxWrapper || cc._renderContext;
        var ctx = wrapper.getContext();
        var scaleX = cc.view.getScaleX(), scaleY = cc.view.getScaleY();
        wrapper.setViewScale(scaleX, scaleY);
        wrapper.computeRealOffsetY();
        var dirtyList = this._dirtyRegion.getDirtyRegions();
        var locCmds = this._renderCmds, i, len;
        var allNeedDraw = this._allNeedDraw || !this._enableDirtyRegion;
        allNeedDraw || (allNeedDraw = allNeedDraw || !this._collectDirtyRegion());
        allNeedDraw || this._beginDrawDirtyRegion(wrapper);
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, viewport.width, viewport.height);
        if (0 !== this._clearColor.r || 0 !== this._clearColor.g || 0 !== this._clearColor.b) {
          wrapper.setFillStyle(this._clearFillStyle);
          wrapper.setGlobalAlpha(this._clearColor.a);
          ctx.fillRect(0, 0, viewport.width, viewport.height);
        }
        for (i = 0, len = locCmds.length; i < len; i++) {
          var cmd = locCmds[i];
          if (!cmd._needDraw) continue;
          var needRendering = false;
          var cmdRegion = cmd._currentRegion;
          if (!cmdRegion || allNeedDraw) needRendering = true; else for (var index = 0, count = dirtyList.length; index < count; ++index) if (dirtyList[index].intersects(cmdRegion)) {
            needRendering = true;
            break;
          }
          needRendering && cmd.rendering(wrapper, scaleX, scaleY);
        }
        if (!allNeedDraw) {
          this._debugDrawDirtyRegion(wrapper);
          this._endDrawDirtyRegion(ctx);
        }
        dirtyRegion.clear();
        this._allNeedDraw = false;
      },
      _renderingToCacheCanvas: function(ctx, instanceID, scaleX, scaleY) {
        ctx || cc.logID(7600);
        scaleX = void 0 === scaleX ? 1 : scaleX;
        scaleY = void 0 === scaleY ? 1 : scaleY;
        instanceID = instanceID || this._currentID;
        var locCmds = this._cacheToCanvasCmds[instanceID], i, len;
        ctx.computeRealOffsetY();
        for (i = 0, len = locCmds.length; i < len; i++) locCmds[i].rendering(ctx, scaleX, scaleY);
        this._removeCache(instanceID);
        var locIDs = this._cacheInstanceIds;
        0 === locIDs.length ? this._isCacheToCanvasOn = false : this._currentID = locIDs[locIDs.length - 1];
      },
      _turnToCacheMode: function(renderTextureID) {
        this._isCacheToCanvasOn = true;
        renderTextureID = renderTextureID || 0;
        this._cacheToCanvasCmds[renderTextureID] = [];
        -1 === this._cacheInstanceIds.indexOf(renderTextureID) && this._cacheInstanceIds.push(renderTextureID);
        this._currentID = renderTextureID;
      },
      _turnToNormalMode: function() {
        this._isCacheToCanvasOn = false;
      },
      _removeCache: function(instanceID) {
        instanceID = instanceID || this._currentID;
        var cmds = this._cacheToCanvasCmds[instanceID];
        if (cmds) {
          cmds.length = 0;
          delete this._cacheToCanvasCmds[instanceID];
        }
        var locIDs = this._cacheInstanceIds;
        cc.js.array.remove(locIDs, instanceID);
      },
      resetFlag: function() {
        this.childrenOrderDirty = false;
        this._transformNodePool.length = 0;
      },
      transform: function() {
        var locPool = this._transformNodePool;
        locPool.sort(this._sortNodeByLevelAsc);
        for (var i = 0, len = locPool.length; i < len; i++) locPool[i].updateStatus();
        locPool.length = 0;
      },
      transformDirty: function() {
        return this._transformNodePool.length > 0;
      },
      _sortNodeByLevelAsc: function(n1, n2) {
        return n1._curLevel - n2._curLevel;
      },
      pushDirtyNode: function(node) {
        this._transformNodePool.push(node);
      },
      clear: function() {},
      clearRenderCommands: function() {
        this._renderCmds.length = 0;
        this._cacheInstanceIds.length = 0;
        this._isCacheToCanvasOn = false;
        this._allNeedDraw = true;
      },
      pushRenderCommand: function(cmd) {
        if (!cmd.rendering) return;
        if (this._isCacheToCanvasOn) {
          var currentId = this._currentID, locCmdBuffer = this._cacheToCanvasCmds;
          var cmdList = locCmdBuffer[currentId];
          -1 === cmdList.indexOf(cmd) && cmdList.push(cmd);
        } else -1 === this._renderCmds.indexOf(cmd) && this._renderCmds.push(cmd);
      }
    };
    (function() {
      cc.CanvasContextWrapper = function(context) {
        this._context = context;
        this._saveCount = 0;
        this._currentAlpha = context.globalAlpha;
        this._currentCompositeOperation = context.globalCompositeOperation;
        this._currentFillStyle = context.fillStyle;
        this._currentStrokeStyle = context.strokeStyle;
        this._offsetX = 0;
        this._offsetY = 0;
        this._realOffsetY = this.height;
        this._armatureMode = 0;
      };
      var proto = cc.CanvasContextWrapper.prototype;
      proto.resetCache = function() {
        var context = this._context;
        this._currentAlpha = context.globalAlpha;
        this._currentCompositeOperation = context.globalCompositeOperation;
        this._currentFillStyle = context.fillStyle;
        this._currentStrokeStyle = context.strokeStyle;
        this._realOffsetY = this._context.canvas.height + this._offsetY;
      };
      proto.setOffset = function(x, y) {
        this._offsetX = x;
        this._offsetY = y;
        this._realOffsetY = this._context.canvas.height + this._offsetY;
      };
      proto.computeRealOffsetY = function() {
        this._realOffsetY = this._context.canvas.height + this._offsetY;
      };
      proto.setViewScale = function(scaleX, scaleY) {
        this._scaleX = scaleX;
        this._scaleY = scaleY;
      };
      proto.getContext = function() {
        return this._context;
      };
      proto.save = function() {
        this._context.save();
        this._saveCount++;
      };
      proto.restore = function() {
        this._context.restore();
        this._currentAlpha = this._context.globalAlpha;
        this._saveCount--;
      };
      proto.setGlobalAlpha = function(alpha) {
        if (this._saveCount > 0) this._context.globalAlpha = alpha; else if (this._currentAlpha !== alpha) {
          this._currentAlpha = alpha;
          this._context.globalAlpha = alpha;
        }
      };
      proto.setCompositeOperation = function(compositionOperation) {
        if (this._saveCount > 0) this._context.globalCompositeOperation = compositionOperation; else if (this._currentCompositeOperation !== compositionOperation) {
          this._currentCompositeOperation = compositionOperation;
          this._context.globalCompositeOperation = compositionOperation;
        }
      };
      proto.setFillStyle = function(fillStyle) {
        this._context.fillStyle = fillStyle;
      };
      proto.setStrokeStyle = function(strokeStyle) {
        if (this._saveCount > 0) this._context.strokeStyle = strokeStyle; else if (this._currentStrokeStyle !== strokeStyle) {
          this._currentStrokeStyle = strokeStyle;
          this._context.strokeStyle = strokeStyle;
        }
      };
      proto.setTransform = function(t, scaleX, scaleY) {
        if (this._armatureMode > 0) {
          this.restore();
          this.save();
          this._context.transform(t.a, -t.b, -t.c, t.d, t.tx * scaleX, -t.ty * scaleY);
        } else this._context.setTransform(t.a * scaleX, -t.b * scaleY, -t.c * scaleX, t.d * scaleY, this._offsetX + t.tx * scaleX, this._realOffsetY - t.ty * scaleY);
      };
      proto._switchToArmatureMode = function(enable, t, scaleX, scaleY) {
        if (enable) {
          this._armatureMode++;
          this._context.setTransform(t.a, t.c, t.b, t.d, this._offsetX + t.tx * scaleX, this._realOffsetY - t.ty * scaleY);
          this.save();
        } else {
          this._armatureMode--;
          this.restore();
        }
      };
    })();
  }), {} ],
  117: [ (function(require, module, exports) {
    var _batchedInfo = {
      texture: null,
      blendSrc: null,
      blendDst: null,
      shader: null
    }, _batchBroken = false, _indexBuffer = null, _vertexBuffer = null, _maxVertexSize = 0, _batchingSize = 0, _indexSize = 0, _sizePerVertex = 6, _vertexData = null, _vertexDataSize = 0, _vertexDataF32 = null, _vertexDataUI32 = null, _indexData = null, _prevIndexSize = 0, _pureQuad = true, _IS_IOS = false;
    function updateBuffer(numVertex) {
      var gl = cc._renderContext;
      if (_indexBuffer) {
        var indexCount = 6 * Math.ceil(numVertex / 4);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _indexBuffer);
        _indexData = new Uint16Array(indexCount);
        var currentQuad = 0;
        for (var i = 0, len = indexCount; i < len; i += 6) {
          _indexData[i] = currentQuad + 0;
          _indexData[i + 1] = currentQuad + 1;
          _indexData[i + 2] = currentQuad + 2;
          _indexData[i + 3] = currentQuad + 1;
          _indexData[i + 4] = currentQuad + 2;
          _indexData[i + 5] = currentQuad + 3;
          currentQuad += 4;
        }
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, _indexData, gl.DYNAMIC_DRAW);
      }
      if (_vertexBuffer) {
        _vertexDataSize = numVertex * _sizePerVertex;
        var byteLength = 4 * _vertexDataSize;
        _vertexData = new ArrayBuffer(byteLength);
        _vertexDataF32 = new Float32Array(_vertexData);
        _vertexDataUI32 = new Uint32Array(_vertexData);
        gl.bindBuffer(gl.ARRAY_BUFFER, _vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, _vertexDataF32, gl.DYNAMIC_DRAW);
      }
      _maxVertexSize = numVertex - 200;
    }
    function initQuadBuffer(numVertex) {
      var gl = cc._renderContext;
      if (null === _indexBuffer) {
        _vertexBuffer = gl.createBuffer();
        _indexBuffer = gl.createBuffer();
      }
      updateBuffer(numVertex);
    }
    var VertexType = cc.Enum({
      QUAD: 0,
      TRIANGLE: 1,
      CUSTOM: 2
    });
    cc.rendererWebGL = {
      mat4Identity: null,
      childrenOrderDirty: true,
      assignedZ: 0,
      assignedZStep: .01,
      VertexType: VertexType,
      _transformNodePool: [],
      _renderCmds: [],
      _isCacheToBufferOn: false,
      _cacheToBufferCmds: {},
      _cacheInstanceIds: [],
      _currentID: 0,
      _clearColor: {
        r: 0,
        g: 0,
        b: 0,
        a: 1
      },
      init: function() {
        var gl = cc._renderContext;
        gl.disable(gl.CULL_FACE);
        gl.disable(gl.DEPTH_TEST);
        this._initExtensions([ "OES_element_index_uint" ]);
        this.mat4Identity = new cc.math.Matrix4();
        this.mat4Identity.identity();
        initQuadBuffer(cc.macro.BATCH_VERTEX_COUNT);
        cc.sys.os === cc.sys.OS_IOS && (_IS_IOS = true);
      },
      _initExtensions: function(extensions) {
        this._extensions = this._extensions || {};
        for (var i = 0; i < extensions.length; ++i) {
          var name = extensions[i];
          try {
            var ext = gl.getExtension(name);
            ext && (this._extensions[name] = ext);
          } catch (e) {
            cc.error(e);
          }
        }
      },
      getVertexSize: function() {
        return _maxVertexSize;
      },
      getRenderCmd: function(renderableObject) {
        return renderableObject._createRenderCmd();
      },
      _turnToCacheMode: function(renderTextureID) {
        this._isCacheToBufferOn = true;
        renderTextureID = renderTextureID || 0;
        this._cacheToBufferCmds[renderTextureID] ? this._cacheToBufferCmds[renderTextureID].length = 0 : this._cacheToBufferCmds[renderTextureID] = [];
        -1 === this._cacheInstanceIds.indexOf(renderTextureID) && this._cacheInstanceIds.push(renderTextureID);
        this._currentID = renderTextureID;
      },
      _turnToNormalMode: function() {
        this._isCacheToBufferOn = false;
      },
      _removeCache: function(instanceID) {
        instanceID = instanceID || this._currentID;
        var cmds = this._cacheToBufferCmds[instanceID];
        if (cmds) {
          cmds.length = 0;
          delete this._cacheToBufferCmds[instanceID];
        }
        var locIDs = this._cacheInstanceIds;
        cc.js.array.remove(locIDs, instanceID);
      },
      _renderingToBuffer: function(renderTextureId) {
        renderTextureId = renderTextureId || this._currentID;
        var locCmds = this._cacheToBufferCmds[renderTextureId];
        var ctx = cc._renderContext;
        this.rendering(ctx, locCmds);
        this._removeCache(renderTextureId);
        var locIDs = this._cacheInstanceIds;
        0 === locIDs.length ? this._isCacheToBufferOn = false : this._currentID = locIDs[locIDs.length - 1];
      },
      resetFlag: function() {
        this.childrenOrderDirty && (this.childrenOrderDirty = false);
        this._transformNodePool.length = 0;
      },
      transform: function() {
        var locPool = this._transformNodePool;
        locPool.sort(this._sortNodeByLevelAsc);
        var i, len, cmd;
        for (i = 0, len = locPool.length; i < len; i++) {
          cmd = locPool[i];
          cmd.updateStatus();
        }
        locPool.length = 0;
      },
      transformDirty: function() {
        return this._transformNodePool.length > 0;
      },
      _sortNodeByLevelAsc: function(n1, n2) {
        return n1._curLevel - n2._curLevel;
      },
      pushDirtyNode: function(node) {
        this._transformNodePool.push(node);
      },
      clearRenderCommands: function() {
        this._renderCmds.length = 0;
      },
      clear: function() {
        var gl = cc._renderContext;
        gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      },
      setDepthTest: function(enable) {
        var gl = cc._renderContext;
        if (enable) {
          gl.clearDepth(1);
          gl.enable(gl.DEPTH_TEST);
          gl.depthFunc(gl.LEQUAL);
        } else gl.disable(gl.DEPTH_TEST);
      },
      pushRenderCommand: function(cmd) {
        if (!cmd.rendering && !cmd.uploadData) return;
        if (this._isCacheToBufferOn) {
          var currentId = this._currentID, locCmdBuffer = this._cacheToBufferCmds;
          var cmdList = locCmdBuffer[currentId];
          -1 === cmdList.indexOf(cmd) && cmdList.push(cmd);
        } else this._renderCmds.push(cmd);
      },
      _increaseBatchingSize: function(increment, vertexType, indices) {
        vertexType = vertexType || VertexType.QUAD;
        var i, curr;
        switch (vertexType) {
         case VertexType.QUAD:
          for (i = 0; i < increment; i += 4) {
            curr = _batchingSize + i;
            _indexData[_indexSize++] = curr + 0;
            _indexData[_indexSize++] = curr + 1;
            _indexData[_indexSize++] = curr + 2;
            _indexData[_indexSize++] = curr + 1;
            _indexData[_indexSize++] = curr + 2;
            _indexData[_indexSize++] = curr + 3;
          }
          break;

         case VertexType.TRIANGLE:
          _pureQuad = false;
          for (i = 0; i < increment; i += 3) {
            curr = _batchingSize + i;
            _indexData[_indexSize++] = curr + 0;
            _indexData[_indexSize++] = curr + 1;
            _indexData[_indexSize++] = curr + 2;
          }
          break;

         case VertexType.CUSTOM:
          _pureQuad = false;
          var len = indices.length;
          for (i = 0; i < len; i++) _indexData[_indexSize++] = _batchingSize + indices[i];
          break;

         default:
          return;
        }
        _batchingSize += increment;
      },
      _updateBatchedInfo: function(texture, blendFunc, shaderProgram) {
        if (texture !== _batchedInfo.texture || blendFunc.src !== _batchedInfo.blendSrc || blendFunc.dst !== _batchedInfo.blendDst || shaderProgram !== _batchedInfo.shader) {
          this._batchRendering();
          _batchedInfo.texture = texture;
          _batchedInfo.blendSrc = blendFunc.src;
          _batchedInfo.blendDst = blendFunc.dst;
          _batchedInfo.shader = shaderProgram;
          return true;
        }
        return false;
      },
      _breakBatch: function() {
        _batchBroken = true;
      },
      _uploadBufferData: function(cmd) {
        _batchingSize >= _maxVertexSize && this._batchRendering();
        var node = cmd._node;
        var texture = cmd._texture || node._texture || node._spriteFrame && node._spriteFrame._texture;
        var blendSrc = node._blendFunc.src;
        var blendDst = node._blendFunc.dst;
        var shader = cmd._shaderProgram;
        if (_batchBroken || _batchedInfo.texture !== texture || _batchedInfo.blendSrc !== blendSrc || _batchedInfo.blendDst !== blendDst || _batchedInfo.shader !== shader) {
          this._batchRendering();
          _batchedInfo.texture = texture;
          _batchedInfo.blendSrc = blendSrc;
          _batchedInfo.blendDst = blendDst;
          _batchedInfo.shader = shader;
          _batchBroken = false;
        }
        var len = cmd.uploadData(_vertexDataF32, _vertexDataUI32, _batchingSize * _sizePerVertex);
        if (len > 0) {
          var i, curr, type = cmd.vertexType || VertexType.QUAD;
          switch (type) {
           case VertexType.QUAD:
            for (i = 0; i < len; i += 4) {
              curr = _batchingSize + i;
              _indexData[_indexSize++] = curr + 0;
              _indexData[_indexSize++] = curr + 1;
              _indexData[_indexSize++] = curr + 2;
              _indexData[_indexSize++] = curr + 1;
              _indexData[_indexSize++] = curr + 2;
              _indexData[_indexSize++] = curr + 3;
            }
            break;

           case VertexType.TRIANGLE:
            _pureQuad = false;
            for (i = 0; i < len; i += 3) {
              curr = _batchingSize + i;
              _indexData[_indexSize++] = curr + 0;
              _indexData[_indexSize++] = curr + 1;
              _indexData[_indexSize++] = curr + 2;
            }
            break;

           case VertexType.CUSTOM:
            _pureQuad = false;
            cmd.uploadIndexData && (_indexSize += cmd.uploadIndexData(_indexData, _indexSize, _batchingSize));
            break;

           default:
            return;
          }
          _batchingSize += len;
        }
      },
      _batchRendering: function() {
        if (0 === _batchingSize || !_batchedInfo.texture) return;
        var gl = cc._renderContext;
        var texture = _batchedInfo.texture;
        var shader = _batchedInfo.shader;
        var uploadAll = _batchingSize > .5 * _maxVertexSize;
        if (shader) {
          shader.use();
          shader._updateProjectionUniform();
        }
        cc.gl.blendFunc(_batchedInfo.blendSrc, _batchedInfo.blendDst);
        cc.gl.bindTexture2DN(0, texture);
        gl.bindBuffer(gl.ARRAY_BUFFER, _vertexBuffer);
        if (uploadAll) {
          false;
          gl.bufferData(gl.ARRAY_BUFFER, _vertexDataF32, gl.DYNAMIC_DRAW);
        } else {
          var view = _vertexDataF32.subarray(0, _batchingSize * _sizePerVertex);
          var viewUI32;
          false;
          gl.bufferData(gl.ARRAY_BUFFER, view, gl.DYNAMIC_DRAW);
        }
        gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_POSITION);
        gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_COLOR);
        gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_TEX_COORDS);
        gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 24, 0);
        gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, 24, 12);
        gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 24, 16);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _indexBuffer);
        (!_prevIndexSize || !_pureQuad || _indexSize > _prevIndexSize) && (uploadAll ? gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, _indexData, gl.DYNAMIC_DRAW) : gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, _indexData.subarray(0, _indexSize), gl.DYNAMIC_DRAW));
        gl.drawElements(gl.TRIANGLES, _indexSize, gl.UNSIGNED_SHORT, 0);
        cc.g_NumberOfDraws++;
        if (_pureQuad) _prevIndexSize = _indexSize; else {
          _prevIndexSize = 0;
          _pureQuad = true;
        }
        _batchingSize = 0;
        _indexSize = 0;
      },
      rendering: function(ctx, cmds) {
        var locCmds = cmds || this._renderCmds, i, len, cmd, context = ctx || cc._renderContext;
        context.bindBuffer(context.ARRAY_BUFFER, null);
        cc.gl.bindTexture2DN(0, null);
        for (i = 0, len = locCmds.length; i < len; ++i) {
          cmd = locCmds[i];
          if (!cmd._needDraw) continue;
          if (cmd.uploadData) this._uploadBufferData(cmd); else {
            _batchingSize > 0 && this._batchRendering();
            cmd.rendering(context);
          }
        }
        this._batchRendering();
        _batchedInfo.texture = null;
      }
    };
  }), {} ],
  118: [ (function(require, module, exports) {
    require("./RendererCanvas");
    require("./RendererWebGL");
    require("./DirtyRegion");
  }), {
    "./DirtyRegion": 115,
    "./RendererCanvas": 116,
    "./RendererWebGL": 117
  } ],
  119: [ (function(require, module, exports) {
    _ccsg.Scene = _ccsg.Node.extend({
      _className: "Scene",
      ctor: function() {
        _ccsg.Node.prototype.ctor.call(this);
        this._ignoreAnchorPointForPosition = true;
        this.setAnchorPoint(.5, .5);
        this.setContentSize(cc.director.getWinSize());
      }
    });
  }), {} ],
  120: [ (function(require, module, exports) {
    var EventTarget = require("../event/event-target");
    var Misc = require("../utils/misc");
    _ccsg.Sprite = _ccsg.Node.extend({
      dirty: false,
      _recursiveDirty: null,
      _shouldBeHidden: false,
      _transformToBatch: null,
      _blendFunc: null,
      _texture: null,
      _rect: null,
      _rectRotated: false,
      _offsetPosition: null,
      _unflippedOffsetPositionFromCenter: null,
      _opacityModifyRGB: false,
      _flippedX: false,
      _flippedY: false,
      _textureLoaded: false,
      _className: "Sprite",
      ctor: function(textureOrSpriteFrame, rect, rotated) {
        var self = this;
        _ccsg.Node.prototype.ctor.call(self);
        EventTarget.call(self);
        self._shouldBeHidden = false;
        self._offsetPosition = cc.p(0, 0);
        self._unflippedOffsetPositionFromCenter = cc.p(0, 0);
        self._blendFunc = {
          src: cc.macro.BLEND_SRC,
          dst: cc.macro.BLEND_DST
        };
        self._rect = cc.rect(0, 0, 0, 0);
        self._softInit(textureOrSpriteFrame, rect, rotated);
      },
      textureLoaded: function() {
        return this._textureLoaded;
      },
      addLoadedEventListener: function(callback, target) {
        this.once("load", callback, target);
      },
      isDirty: function() {
        return this.dirty;
      },
      setDirty: function(bDirty) {
        this.dirty = bDirty;
      },
      isTextureRectRotated: function() {
        return this._rectRotated;
      },
      getTextureRect: function() {
        return cc.rect(this._rect);
      },
      getOffsetPosition: function() {
        return cc.p(this._offsetPosition);
      },
      _getOffsetX: function() {
        return this._offsetPosition.x;
      },
      _getOffsetY: function() {
        return this._offsetPosition.y;
      },
      getBlendFunc: function() {
        return this._blendFunc;
      },
      initWithSpriteFrame: function(spriteFrame) {
        cc.assertID(spriteFrame, 2606);
        if (!spriteFrame.textureLoaded()) {
          this._textureLoaded = false;
          spriteFrame.once("load", this._renderCmd._spriteFrameLoadedCallback, this._renderCmd);
        }
        var rotated = cc._renderType !== cc.game.RENDER_TYPE_CANVAS && spriteFrame._rotated;
        var ret = this.initWithTexture(spriteFrame.getTexture(), spriteFrame.getRect(), rotated);
        this.setSpriteFrame(spriteFrame);
        return ret;
      },
      initWithSpriteFrameName: function() {
        cc.warnID(2608);
        return;
      },
      setVertexRect: function(rect) {
        var locRect = this._rect;
        locRect.x = rect.x;
        locRect.y = rect.y;
        locRect.width = rect.width;
        locRect.height = rect.height;
      },
      setFlippedX: function(flippedX) {
        if (this._flippedX !== flippedX) {
          this._flippedX = flippedX;
          this.setTextureRect(this._rect, this._rectRotated, this._contentSize);
          this.setNodeDirty(true);
        }
      },
      setFlippedY: function(flippedY) {
        if (this._flippedY !== flippedY) {
          this._flippedY = flippedY;
          this.setTextureRect(this._rect, this._rectRotated, this._contentSize);
          this.setNodeDirty(true);
        }
      },
      isFlippedX: function() {
        return this._flippedX;
      },
      isFlippedY: function() {
        return this._flippedY;
      },
      setOpacityModifyRGB: function(modify) {
        if (this._opacityModifyRGB !== modify) {
          this._opacityModifyRGB = modify;
          this._renderCmd._setColorDirty();
        }
      },
      isOpacityModifyRGB: function() {
        return this._opacityModifyRGB;
      },
      setDisplayFrameWithAnimationName: function(animationName, frameIndex) {
        cc.assertID(animationName, 2610);
        var cache = cc.spriteFrameAnimationCache.getAnimation(animationName);
        if (!cache) {
          cc.logID(2602);
          return;
        }
        var animFrame = cache.getFrames()[frameIndex];
        if (!animFrame) {
          cc.logID(2603);
          return;
        }
        this.setSpriteFrame(animFrame.getSpriteFrame());
      },
      getTexture: function() {
        return this._texture;
      },
      _softInit: function(textureOrSpriteFrame, rect, rotated) {
        void 0 === textureOrSpriteFrame ? _ccsg.Sprite.prototype.init.call(this) : textureOrSpriteFrame instanceof cc.Texture2D ? this.initWithTexture(textureOrSpriteFrame, rect, rotated) : textureOrSpriteFrame instanceof cc.SpriteFrame && this.initWithSpriteFrame(textureOrSpriteFrame);
      },
      setBlendFunc: function(src, dst) {
        var locBlendFunc = this._blendFunc;
        if (void 0 === dst) {
          locBlendFunc.src = src.src;
          locBlendFunc.dst = src.dst;
        } else {
          locBlendFunc.src = src;
          locBlendFunc.dst = dst;
        }
        this._renderCmd.updateBlendFunc(locBlendFunc);
      },
      init: function() {
        var _t = this;
        if (arguments.length > 0) return _t.initWithFile(arguments[0], arguments[1]);
        _t.dirty = _t._recursiveDirty = false;
        _t._blendFunc.src = cc.macro.BLEND_SRC;
        _t._blendFunc.dst = cc.macro.BLEND_DST;
        _t.texture = null;
        _t._flippedX = _t._flippedY = false;
        _t.anchorX = .5;
        _t.anchorY = .5;
        _t._offsetPosition.x = 0;
        _t._offsetPosition.y = 0;
        _t.setTextureRect(cc.rect(0, 0, 0, 0), false, cc.size(0, 0));
        return true;
      },
      initWithFile: function(filename, rect) {
        cc.assertID(filename, 2609);
        var tex = cc.textureCache.getTextureForKey(filename);
        if (tex) {
          if (!rect) {
            var size = tex.getContentSize();
            rect = cc.rect(0, 0, size.width, size.height);
          }
          return this.initWithTexture(tex, rect);
        }
        tex = cc.textureCache.addImage(filename);
        return this.initWithTexture(tex, rect || cc.rect(0, 0, tex.width, tex.height));
      },
      initWithTexture: function(texture, rect, rotated, counterclockwise) {
        var _t = this;
        cc.assertID(0 !== arguments.length, 2710);
        rotated = rotated || false;
        texture = this._renderCmd._handleTextureForRotatedTexture(texture, rect, rotated, counterclockwise);
        _t._recursiveDirty = false;
        _t.dirty = false;
        _t._opacityModifyRGB = true;
        _t._blendFunc.src = cc.macro.BLEND_SRC;
        _t._blendFunc.dst = cc.macro.BLEND_DST;
        _t._flippedX = _t._flippedY = false;
        _t.setAnchorPoint(.5, .5);
        _t._offsetPosition.x = 0;
        _t._offsetPosition.y = 0;
        var locTextureLoaded = texture.loaded;
        _t._textureLoaded = locTextureLoaded;
        if (!locTextureLoaded) {
          _t._rectRotated = rotated;
          if (rect) {
            _t._rect.x = rect.x;
            _t._rect.y = rect.y;
            _t._rect.width = rect.width;
            _t._rect.height = rect.height;
          }
          _t.texture && _t.texture.off("load", _t._renderCmd._textureLoadedCallback, _t._renderCmd);
          texture.once("load", _t._renderCmd._textureLoadedCallback, _t._renderCmd);
          _t.setTexture(texture);
          return true;
        }
        rect || (rect = cc.rect(0, 0, texture.width, texture.height));
        this._renderCmd._checkTextureBoundary(texture, rect, rotated);
        _t.setTexture(texture);
        _t.setTextureRect(rect, rotated);
        this.emit("load");
        return true;
      },
      setTextureRect: function(rect, rotated, untrimmedSize, needConvert) {
        var _t = this;
        _t._rectRotated = rotated || false;
        _t.setContentSize(untrimmedSize || rect);
        _t.setVertexRect(rect);
        _t._renderCmd._setTextureCoords(rect, needConvert);
        var relativeOffsetX = _t._unflippedOffsetPositionFromCenter.x, relativeOffsetY = _t._unflippedOffsetPositionFromCenter.y;
        _t._flippedX && (relativeOffsetX = -relativeOffsetX);
        _t._flippedY && (relativeOffsetY = -relativeOffsetY);
        var locRect = _t._rect;
        _t._offsetPosition.x = relativeOffsetX + (_t._contentSize.width - locRect.width) / 2;
        _t._offsetPosition.y = relativeOffsetY + (_t._contentSize.height - locRect.height) / 2;
      },
      setSpriteFrame: function(newFrame) {
        var _t = this;
        cc.assertID(newFrame, 2712);
        this.setNodeDirty(true);
        var frameOffset = newFrame.getOffset();
        _t._unflippedOffsetPositionFromCenter.x = frameOffset.x;
        _t._unflippedOffsetPositionFromCenter.y = frameOffset.y;
        var pNewTexture = newFrame.getTexture();
        var locTextureLoaded = newFrame.textureLoaded();
        if (locTextureLoaded) {
          _t._textureLoaded = true;
          if (pNewTexture !== _t._texture) {
            _t._setTexture(pNewTexture);
            _t.setColor(_t._realColor);
          }
          _t.setTextureRect(newFrame.getRect(), newFrame.isRotated(), newFrame.getOriginalSize());
        } else {
          _t._textureLoaded = false;
          newFrame.once("load", (function(event) {
            var sender = event.currentTarget;
            _t._textureLoaded = true;
            var locNewTexture = sender.getTexture();
            locNewTexture !== _t._texture && _t._setTexture(locNewTexture);
            _t.setTextureRect(sender.getRect(), sender.isRotated(), sender.getOriginalSize());
            _t.emit("load");
            _t.setColor(_t._realColor);
          }), _t);
        }
        this._renderCmd._updateForSetSpriteFrame(pNewTexture);
      },
      setDisplayFrame: function(newFrame) {
        cc.logID(2604);
        this.setSpriteFrame(newFrame);
      },
      isFrameDisplayed: function(frame) {
        return this._renderCmd.isFrameDisplayed(frame);
      },
      displayFrame: function() {
        return this.getSpriteFrame();
      },
      getSpriteFrame: function() {
        return new cc.SpriteFrame(this._texture, this._rect, this._rectRotated, this._unflippedOffsetPositionFromCenter, this._contentSize);
      },
      setTexture: function(texture) {
        if (!texture) return this._renderCmd._setTexture(null);
        var isFileName = cc.js.isString(texture);
        isFileName && (texture = cc.textureCache.addImage(texture));
        if (texture.loaded) {
          this._setTexture(texture, isFileName);
          this.setColor(this._realColor);
          this._textureLoaded = true;
          this.emit("load");
        } else {
          this._renderCmd._setTexture(texture);
          texture.once("load", (function(event) {
            this._setTexture(texture, isFileName);
            this.setColor(this._realColor);
            this._textureLoaded = true;
            this.emit("load");
          }), this);
        }
      },
      _setTexture: function(texture, change) {
        this._renderCmd._setTexture(texture);
        change && this._changeRectWithTexture(texture);
      },
      _changeRectWithTexture: function(texture) {
        var rect = cc.rect(0, 0, texture.width, texture.height);
        this.setTextureRect(rect);
      },
      _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new _ccsg.Sprite.CanvasRenderCmd(this) : new _ccsg.Sprite.WebGLRenderCmd(this);
      }
    });
    cc.js.addon(_ccsg.Sprite.prototype, EventTarget.prototype);
    var SameNameGetSets = [ "opacity", "color", "texture" ];
    var DiffNameGetSets = {
      opacityModifyRGB: [ "isOpacityModifyRGB", "setOpacityModifyRGB" ],
      flippedX: [ "isFlippedX", "setFlippedX" ],
      flippedY: [ "isFlippedY", "setFlippedY" ],
      offsetX: [ "_getOffsetX" ],
      offsetY: [ "_getOffsetY" ],
      textureRectRotated: [ "isTextureRectRotated" ]
    };
    Misc.propertyDefine(_ccsg.Sprite, SameNameGetSets, DiffNameGetSets);
  }), {
    "../event/event-target": 60,
    "../utils/misc": 137
  } ],
  121: [ (function(require, module, exports) {
    function CanvasRenderCmd(renderable) {
      this._rootCtor(renderable);
      this._needDraw = true;
      this._textureCoord = {
        renderX: 0,
        renderY: 0,
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        validRect: false
      };
      this._blendFuncStr = "source-over";
      this._colorized = false;
      this._textureToRender = null;
    }
    var proto = CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
    proto.constructor = CanvasRenderCmd;
    proto.setDirtyRecursively = function(value) {};
    proto._setTexture = function(texture) {
      var node = this._node;
      if (node._texture !== texture) {
        node._textureLoaded = !!texture && texture.loaded;
        node._texture = texture;
        var rect = cc.rect(0, 0, texture.width, texture.height);
        node.setTextureRect(rect);
        this._updateColor();
      }
    };
    proto._setColorDirty = function() {
      this.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty | _ccsg.Node._dirtyFlags.opacityDirty);
    };
    proto.isFrameDisplayed = function(frame) {
      var node = this._node;
      if (frame.getTexture() !== node._texture) return false;
      return cc.rectEqualToRect(frame.getRect(), node._rect);
    };
    proto.updateBlendFunc = function(blendFunc) {
      this._blendFuncStr = _ccsg.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(blendFunc);
    };
    proto._handleTextureForRotatedTexture = function(texture, rect, rotated, counterclockwise) {
      if (rotated && texture.loaded) {
        texture = CanvasRenderCmd._createRotatedTexture(texture, rect, counterclockwise);
        rect.x = rect.y = 0;
        this._node._rect = cc.rect(0, 0, rect.width, rect.height);
      }
      return texture;
    };
    proto._checkTextureBoundary = function(texture, rect, rotated) {
      if (texture && texture.url) {
        var _x = rect.x + rect.width, _y = rect.y + rect.height;
        _x > texture.width && cc.errorID(3300, texture.url);
        _y > texture.height && cc.errorID(3400, texture.url);
      }
    };
    proto.rendering = function(ctx, scaleX, scaleY) {
      var node = this._node;
      var locTextureCoord = this._textureCoord, alpha = this._displayedOpacity / 255;
      var texture = this._textureToRender || node._texture;
      if (texture && (0 === locTextureCoord.width || 0 === locTextureCoord.height || !texture.loaded) || 0 === alpha) return;
      var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
      var locX = node._offsetPosition.x, locHeight = node._rect.height, locWidth = node._rect.width, locY = -node._offsetPosition.y - locHeight, image;
      wrapper.setTransform(this._worldTransform, scaleX, scaleY);
      wrapper.setCompositeOperation(this._blendFuncStr);
      wrapper.setGlobalAlpha(alpha);
      (node._flippedX || node._flippedY) && wrapper.save();
      if (node._flippedX) {
        locX = -locX - locWidth;
        context.scale(-1, 1);
      }
      if (node._flippedY) {
        locY = node._offsetPosition.y;
        context.scale(1, -1);
      }
      var sx, sy, sw, sh, x, y, w, h;
      if (this._colorized) {
        sx = 0;
        sy = 0;
      } else {
        sx = locTextureCoord.renderX;
        sy = locTextureCoord.renderY;
      }
      sw = locTextureCoord.width;
      sh = locTextureCoord.height;
      x = locX;
      y = locY;
      w = locWidth;
      h = locHeight;
      if (texture && texture._image) {
        image = texture._image;
        if ("" !== texture._pattern) {
          wrapper.setFillStyle(context.createPattern(image, texture._pattern));
          context.fillRect(x, y, w, h);
        } else context.drawImage(image, sx, sy, sw, sh, x, y, w, h);
      } else {
        var contentSize = node._contentSize;
        if (locTextureCoord.validRect) {
          var curColor = this._displayedColor;
          wrapper.setFillStyle("rgba(" + curColor.r + "," + curColor.g + "," + curColor.b + ",1)");
          context.fillRect(x, y, contentSize.width, contentSize.height);
        }
      }
      (node._flippedX || node._flippedY) && wrapper.restore();
      cc.g_NumberOfDraws++;
    };
    proto._updateColor = function() {
      var node = this._node;
      var texture = node._texture, rect = this._textureCoord;
      var dColor = this._displayedColor;
      if (texture) if (255 !== dColor.r || 255 !== dColor.g || 255 !== dColor.b) {
        this._textureToRender = texture._generateColorTexture(dColor.r, dColor.g, dColor.b, rect);
        this._colorized = true;
      } else if (texture) {
        this._textureToRender = texture;
        this._colorized = false;
      }
    };
    proto._updateForSetSpriteFrame = function(pNewTexture, textureLoaded) {
      this._colorized = false;
      this._textureCoord.renderX = this._textureCoord.x;
      this._textureCoord.renderY = this._textureCoord.y;
      textureLoaded = textureLoaded || pNewTexture.loaded;
      if (textureLoaded) {
        var curColor = this._node.getColor();
        255 === curColor.r && 255 === curColor.g && 255 === curColor.b || this._updateColor();
      }
    };
    proto._spriteFrameLoadedCallback = function(event) {
      var node = this._node, spriteFrame = event.currentTarget;
      node.setTextureRect(spriteFrame.getRect(), spriteFrame.isRotated(), spriteFrame.getOriginalSize());
      this._updateColor();
      node.emit("load");
    };
    proto._textureLoadedCallback = function(event) {
      var node = this._node, sender = event.currentTarget;
      if (node._textureLoaded) return;
      node._textureLoaded = true;
      var locRect = node._rect;
      if (locRect) {
        if (cc._rectEqualToZero(locRect)) {
          locRect.width = sender.width;
          locRect.height = sender.height;
        }
      } else locRect = cc.rect(0, 0, sender.width, sender.height);
      node.texture = sender;
      node.setTextureRect(locRect, node._rectRotated);
      var locColor = this._displayedColor;
      255 === locColor.r && 255 === locColor.g && 255 === locColor.b || this._updateColor();
      node.emit("load");
    };
    proto._setTextureCoords = function(rect) {
      var locTextureRect = this._textureCoord;
      locTextureRect.renderX = locTextureRect.x = 0 | rect.x;
      locTextureRect.renderY = locTextureRect.y = 0 | rect.y;
      locTextureRect.width = 0 | rect.width;
      locTextureRect.height = 0 | rect.height;
      locTextureRect.validRect = !(0 === locTextureRect.width || 0 === locTextureRect.height || locTextureRect.x < 0 || locTextureRect.y < 0);
    };
    CanvasRenderCmd._cutRotateImageToCanvas = function(texture, rect, counterclockwise) {
      if (!texture) return null;
      if (!rect) return texture;
      counterclockwise = null == counterclockwise || counterclockwise;
      var nCanvas = document.createElement("canvas");
      nCanvas.width = rect.width;
      nCanvas.height = rect.height;
      var ctx = nCanvas.getContext("2d");
      ctx.translate(nCanvas.width / 2, nCanvas.height / 2);
      counterclockwise ? ctx.rotate(-1.5707963267948966) : ctx.rotate(1.5707963267948966);
      ctx.drawImage(texture, rect.x, rect.y, rect.height, rect.width, -rect.height / 2, -rect.width / 2, rect.height, rect.width);
      return nCanvas;
    };
    CanvasRenderCmd._createRotatedTexture = function(texture, rect, counterclockwise) {
      var rotatedTexture = new cc.Texture2D();
      rotatedTexture._nativeAsset = CanvasRenderCmd._cutRotateImageToCanvas(texture._nativeAsset, rect, counterclockwise);
      return rotatedTexture;
    };
    _ccsg.Sprite.CanvasRenderCmd = CanvasRenderCmd;
  }), {} ],
  122: [ (function(require, module, exports) {
    var macro = cc.macro;
    _ccsg.Sprite.WebGLRenderCmd = function(renderable) {
      this._rootCtor(renderable);
      this._needDraw = true;
      this._vertices = [ {
        x: 0,
        y: 0,
        u: 0,
        v: 0
      }, {
        x: 0,
        y: 0,
        u: 0,
        v: 0
      }, {
        x: 0,
        y: 0,
        u: 0,
        v: 0
      }, {
        x: 0,
        y: 0,
        u: 0,
        v: 0
      } ];
      this._dirty = false;
      this._recursiveDirty = false;
      this._shaderProgram = cc.shaderCache.programForKey(macro.SHADER_SPRITE_POSITION_TEXTURECOLOR);
    };
    var proto = _ccsg.Sprite.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
    proto.constructor = _ccsg.Sprite.WebGLRenderCmd;
    proto.updateBlendFunc = function(blendFunc) {};
    proto.setDirtyFlag = function(dirtyFlag) {
      _ccsg.Node.WebGLRenderCmd.prototype.setDirtyFlag.call(this, dirtyFlag);
      this._dirty = true;
    };
    proto.setDirtyRecursively = function(value) {
      this._recursiveDirty = value;
      this._dirty = value;
      var locChildren = this._node._children, child, l = locChildren ? locChildren.length : 0;
      for (var i = 0; i < l; i++) {
        child = locChildren[i];
        child instanceof _ccsg.Sprite && child._renderCmd.setDirtyRecursively(value);
      }
    };
    proto._handleTextureForRotatedTexture = function(texture) {
      return texture;
    };
    proto.isFrameDisplayed = function(frame) {
      var node = this._node;
      return cc.rectEqualToRect(frame.getRect(), node._rect) && frame.getTexture().url === node._texture.url && cc.pointEqualToPoint(frame.getOffset(), node._unflippedOffsetPositionFromCenter);
    };
    proto._updateForSetSpriteFrame = function() {};
    proto._spriteFrameLoadedCallback = function(event) {
      var spriteFrame = event.currentTarget;
      this._node.setTextureRect(spriteFrame.getRect(), spriteFrame.isRotated(), spriteFrame.getOriginalSize());
      this._node.emit("load");
    };
    proto._textureLoadedCallback = function(event) {
      var node = this._node, sender = event.currentTarget;
      if (node._textureLoaded) return;
      node._textureLoaded = true;
      var locRect = node._rect;
      if (locRect) {
        if (cc._rectEqualToZero(locRect)) {
          locRect.width = sender.width;
          locRect.height = sender.height;
        }
      } else locRect = cc.rect(0, 0, sender.width, sender.height);
      node.texture = sender;
      node.setTextureRect(locRect, node._rectRotated);
      node.emit("load");
      cc.renderer.childrenOrderDirty = true;
    };
    proto._setTextureCoords = function(rect) {
      var node = this._node;
      var tex = node._texture;
      var uvs = this._vertices;
      if (!tex) return;
      var atlasWidth = tex.pixelWidth;
      var atlasHeight = tex.pixelHeight;
      var left, right, top, bottom, tempSwap;
      if (node._rectRotated) {
        if (macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
          left = (2 * rect.x + 1) / (2 * atlasWidth);
          right = left + (2 * rect.height - 2) / (2 * atlasWidth);
          top = (2 * rect.y + 1) / (2 * atlasHeight);
          bottom = top + (2 * rect.width - 2) / (2 * atlasHeight);
        } else {
          left = rect.x / atlasWidth;
          right = (rect.x + rect.height) / atlasWidth;
          top = rect.y / atlasHeight;
          bottom = (rect.y + rect.width) / atlasHeight;
        }
        if (node._flippedX) {
          tempSwap = top;
          top = bottom;
          bottom = tempSwap;
        }
        if (node._flippedY) {
          tempSwap = left;
          left = right;
          right = tempSwap;
        }
        uvs[0].u = right;
        uvs[0].v = top;
        uvs[1].u = left;
        uvs[1].v = top;
        uvs[2].u = right;
        uvs[2].v = bottom;
        uvs[3].u = left;
        uvs[3].v = bottom;
      } else {
        if (macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
          left = (2 * rect.x + 1) / (2 * atlasWidth);
          right = left + (2 * rect.width - 2) / (2 * atlasWidth);
          top = (2 * rect.y + 1) / (2 * atlasHeight);
          bottom = top + (2 * rect.height - 2) / (2 * atlasHeight);
        } else {
          left = rect.x / atlasWidth;
          right = (rect.x + rect.width) / atlasWidth;
          top = rect.y / atlasHeight;
          bottom = (rect.y + rect.height) / atlasHeight;
        }
        if (node._flippedX) {
          tempSwap = left;
          left = right;
          right = tempSwap;
        }
        if (node._flippedY) {
          tempSwap = top;
          top = bottom;
          bottom = tempSwap;
        }
        uvs[0].u = left;
        uvs[0].v = top;
        uvs[1].u = left;
        uvs[1].v = bottom;
        uvs[2].u = right;
        uvs[2].v = top;
        uvs[3].u = right;
        uvs[3].v = bottom;
      }
    };
    proto._setColorDirty = function() {};
    proto._updateBlendFunc = function() {
      var node = this._node;
      if (node._texture && node._texture.hasPremultipliedAlpha()) {
        node._blendFunc.src = macro.BLEND_SRC;
        node._blendFunc.dst = macro.BLEND_DST;
        node.opacityModifyRGB = true;
      } else {
        node._blendFunc.src = macro.SRC_ALPHA;
        node._blendFunc.dst = macro.ONE_MINUS_SRC_ALPHA;
        node.opacityModifyRGB = false;
      }
    };
    proto._setTexture = function(texture) {
      var node = this._node;
      if (node._texture !== texture) {
        node._textureLoaded = !!texture && texture.loaded;
        node._texture = texture;
        this._updateBlendFunc();
        node._textureLoaded && (cc.renderer.childrenOrderDirty = true);
      }
    };
    proto._checkTextureBoundary = function(texture, rect, rotated) {
      if (texture && texture.url) {
        var _x, _y;
        if (rotated) {
          _x = rect.x + rect.height;
          _y = rect.y + rect.width;
        } else {
          _x = rect.x + rect.width;
          _y = rect.y + rect.height;
        }
        _x > texture.width && cc.errorID(3300, texture.url);
        _y > texture.height && cc.errorID(3400, texture.url);
      }
    };
    proto.transform = function(parentCmd, recursive) {
      this.originTransform(parentCmd, recursive);
      var node = this._node, lx = node._offsetPosition.x, rx = lx + node._rect.width, by = node._offsetPosition.y, ty = by + node._rect.height, wt = this._worldTransform;
      var vertices = this._vertices;
      vertices[0].x = lx * wt.a + ty * wt.c + wt.tx;
      vertices[0].y = lx * wt.b + ty * wt.d + wt.ty;
      vertices[1].x = lx * wt.a + by * wt.c + wt.tx;
      vertices[1].y = lx * wt.b + by * wt.d + wt.ty;
      vertices[2].x = rx * wt.a + ty * wt.c + wt.tx;
      vertices[2].y = rx * wt.b + ty * wt.d + wt.ty;
      vertices[3].x = rx * wt.a + by * wt.c + wt.tx;
      vertices[3].y = rx * wt.b + by * wt.d + wt.ty;
    };
    proto.needDraw = function() {
      var node = this._node, locTexture = node._texture;
      return this._needDraw && locTexture;
    };
    proto.uploadData = function(f32buffer, ui32buffer, vertexDataOffset) {
      var node = this._node, locTexture = node._texture;
      if (!(locTexture && locTexture.loaded && node._rect.width && node._rect.height) || !this._displayedOpacity) return 0;
      var opacity = this._displayedOpacity;
      var color, colorVal = this._displayedColor._val;
      if (node._opacityModifyRGB) {
        var a = opacity / 255, r = this._displayedColor.r * a, g = this._displayedColor.g * a, b = this._displayedColor.b * a;
        color = (opacity << 24 >>> 0) + (b << 16) + (g << 8) + r;
      } else color = (opacity << 24 >>> 0) + ((65280 & colorVal) << 8) + ((16711680 & colorVal) >> 8) + (colorVal >>> 24);
      var z = node._vertexZ;
      var vertices = this._vertices;
      var i, len = vertices.length, vertex, offset = vertexDataOffset;
      for (i = 0; i < len; ++i) {
        vertex = vertices[i];
        f32buffer[offset] = vertex.x;
        f32buffer[offset + 1] = vertex.y;
        f32buffer[offset + 2] = z;
        ui32buffer[offset + 3] = color;
        f32buffer[offset + 4] = vertex.u;
        f32buffer[offset + 5] = vertex.v;
        offset += 6;
      }
      return len;
    };
  }), {} ],
  123: [ (function(require, module, exports) {
    var EventTarget = require("../event/event-target");
    function sortIndex(a, b) {
      return a - b;
    }
    var dataPool = {
      _pool: {},
      _lengths: [],
      put: function(data) {
        var length = data.length;
        if (this._pool[length]) this._pool[length].push(data); else {
          this._pool[length] = [ data ];
          this._lengths.push(length);
          this._lengths.sort(sortIndex);
        }
      },
      get: function(length) {
        var id;
        for (var i = 0; i < this._lengths.length; i++) if (this._lengths[i] >= length) {
          id = this._lengths[i];
          break;
        }
        return id ? this._pool[id].pop() : void 0;
      }
    };
    var macro = cc.macro, webgl;
    var simpleQuadGenerator = {
      _rebuildQuads_base: function(sprite) {
        var spriteFrame = sprite._spriteFrame, contentSize = sprite._contentSize, isTrimmedContentSize = sprite._isTrimmedContentSize;
        var vertices = sprite._vertices, corner = sprite._corner, l, b, r, t;
        if (isTrimmedContentSize) {
          l = 0;
          b = 0;
          r = contentSize.width;
          t = contentSize.height;
        } else {
          var originalSize = spriteFrame._originalSize;
          var rect = spriteFrame._rect;
          var offset = spriteFrame._offset;
          var cw = contentSize.width, ch = contentSize.height;
          var ow = originalSize.width, oh = originalSize.height;
          var rw = rect.width, rh = rect.height;
          var scaleX = cw / ow;
          var scaleY = ch / oh;
          var trimmLeft = offset.x + (ow - rw) / 2;
          var trimmRight = offset.x - (ow - rw) / 2;
          var trimmedBottom = offset.y + (oh - rh) / 2;
          var trimmedTop = offset.y - (oh - rh) / 2;
          l = trimmLeft * scaleX;
          b = trimmedBottom * scaleY;
          r = cw + trimmRight * scaleX;
          t = ch + trimmedTop * scaleY;
        }
        if (vertices.length < 8) {
          dataPool.put(vertices);
          vertices = dataPool.get(8) || new Float32Array(8);
          sprite._vertices = vertices;
        }
        if (webgl) {
          var wt = sprite._renderCmd._worldTransform;
          var wta = wt.a, wtb = wt.b, wtc = wt.c, wtd = wt.d, wtx = wt.tx, wty = wt.ty;
          var la = l * wta, lb = l * wtb, ra = r * wta, rb = r * wtb, tcx = t * wtc + wtx, tdy = t * wtd + wty, bcx = b * wtc + wtx, bdy = b * wtd + wty;
          vertices[0] = la + bcx;
          vertices[1] = lb + bdy;
          vertices[2] = ra + bcx;
          vertices[3] = rb + bdy;
          vertices[4] = la + tcx;
          vertices[5] = lb + tdy;
          vertices[6] = ra + tcx;
          vertices[7] = rb + tdy;
        } else {
          vertices[0] = l;
          vertices[1] = b;
          vertices[2] = r;
          vertices[3] = b;
          vertices[4] = l;
          vertices[5] = t;
          vertices[6] = r;
          vertices[7] = t;
        }
        corner[0] = 0;
        corner[1] = 2;
        corner[2] = 4;
        corner[3] = 6;
        sprite._uvsDirty && this._calculateUVs(sprite, spriteFrame);
        sprite._vertCount = 4;
      },
      _calculateUVs: function(sprite, spriteFrame) {
        var uvs = sprite._uvs;
        var atlasWidth = spriteFrame._texture.width;
        var atlasHeight = spriteFrame._texture.height;
        var textureRect = spriteFrame._rect;
        if (uvs.length < 8) {
          dataPool.put(uvs);
          uvs = dataPool.get(8) || new Float32Array(8);
          sprite._uvs = uvs;
        }
        var l, b, r, t;
        var texelCorrect = macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? .5 : 0;
        if (spriteFrame._rotated) {
          l = (textureRect.x + texelCorrect) / atlasWidth;
          b = (textureRect.y + textureRect.width - texelCorrect) / atlasHeight;
          r = (textureRect.x + textureRect.height - texelCorrect) / atlasWidth;
          t = (textureRect.y + texelCorrect) / atlasHeight;
          uvs[0] = l;
          uvs[1] = t;
          uvs[2] = l;
          uvs[3] = b;
          uvs[4] = r;
          uvs[5] = t;
          uvs[6] = r;
          uvs[7] = b;
        } else {
          l = (textureRect.x + texelCorrect) / atlasWidth;
          b = (textureRect.y + textureRect.height - texelCorrect) / atlasHeight;
          r = (textureRect.x + textureRect.width - texelCorrect) / atlasWidth;
          t = (textureRect.y + texelCorrect) / atlasHeight;
          uvs[0] = l;
          uvs[1] = b;
          uvs[2] = r;
          uvs[3] = b;
          uvs[4] = l;
          uvs[5] = t;
          uvs[6] = r;
          uvs[7] = t;
        }
      }
    };
    var scale9QuadGenerator = {
      x: new Array(4),
      y: new Array(4),
      _rebuildQuads_base: function(sprite) {
        var spriteFrame = sprite._spriteFrame, contentSize = sprite._contentSize, insetLeft = sprite._insetLeft, insetRight = sprite._insetRight, insetTop = sprite._insetTop, insetBottom = sprite._insetBottom;
        var vertices = sprite._vertices;
        var wt = sprite._renderCmd._worldTransform;
        var leftWidth, rightWidth;
        var topHeight, bottomHeight;
        var corner = sprite._corner;
        leftWidth = insetLeft;
        rightWidth = insetRight;
        topHeight = insetTop;
        bottomHeight = insetBottom;
        var preferSize = contentSize;
        var sizableWidth = preferSize.width - leftWidth - rightWidth;
        var sizableHeight = preferSize.height - topHeight - bottomHeight;
        var xScale = preferSize.width / (leftWidth + rightWidth);
        var yScale = preferSize.height / (topHeight + bottomHeight);
        xScale = isNaN(xScale) || xScale > 1 ? 1 : xScale;
        yScale = isNaN(yScale) || yScale > 1 ? 1 : yScale;
        sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
        sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
        var x = this.x;
        var y = this.y;
        x[0] = 0;
        x[1] = leftWidth * xScale;
        x[2] = x[1] + sizableWidth;
        x[3] = preferSize.width;
        y[0] = 0;
        y[1] = bottomHeight * yScale;
        y[2] = y[1] + sizableHeight;
        y[3] = preferSize.height;
        if (vertices.length < 32) {
          dataPool.put(vertices);
          vertices = dataPool.get(32) || new Float32Array(32);
          sprite._vertices = vertices;
        }
        var offset = 0, row, col;
        if (webgl) for (row = 0; row < 4; row++) for (col = 0; col < 4; col++) {
          vertices[offset] = x[col] * wt.a + y[row] * wt.c + wt.tx;
          vertices[offset + 1] = x[col] * wt.b + y[row] * wt.d + wt.ty;
          offset += 2;
        } else for (row = 0; row < 4; row++) for (col = 0; col < 4; col++) {
          vertices[offset] = x[col];
          vertices[offset + 1] = y[row];
          offset += 2;
        }
        corner[0] = 0;
        corner[1] = 6;
        corner[2] = 24;
        corner[3] = 30;
        sprite._uvsDirty && this._calculateUVs(sprite, spriteFrame, insetLeft, insetRight, insetTop, insetBottom);
      },
      _calculateUVs: function(sprite, spriteFrame, insetLeft, insetRight, insetTop, insetBottom) {
        var uvs = sprite._uvs;
        var rect = spriteFrame._rect;
        var atlasWidth = spriteFrame._texture.width;
        var atlasHeight = spriteFrame._texture.height;
        var leftWidth, centerWidth, rightWidth;
        var topHeight, centerHeight, bottomHeight;
        var textureRect = spriteFrame._rect;
        leftWidth = insetLeft;
        rightWidth = insetRight;
        centerWidth = rect.width - leftWidth - rightWidth;
        topHeight = insetTop;
        bottomHeight = insetBottom;
        centerHeight = rect.height - topHeight - bottomHeight;
        if (uvs.length < 32) {
          dataPool.put(uvs);
          uvs = dataPool.get(32) || new Float32Array(32);
          sprite._uvs = uvs;
        }
        var u = this.x;
        var v = this.y;
        var texelCorrect = macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? .5 : 0;
        var offset = 0, row, col;
        if (spriteFrame._rotated) {
          u[0] = (textureRect.x + texelCorrect) / atlasWidth;
          u[1] = (bottomHeight + textureRect.x) / atlasWidth;
          u[2] = (bottomHeight + centerHeight + textureRect.x) / atlasWidth;
          u[3] = (textureRect.x + textureRect.height - texelCorrect) / atlasWidth;
          v[3] = (textureRect.y + texelCorrect) / atlasHeight;
          v[2] = (leftWidth + textureRect.y) / atlasHeight;
          v[1] = (leftWidth + centerWidth + textureRect.y) / atlasHeight;
          v[0] = (textureRect.y + textureRect.width - texelCorrect) / atlasHeight;
          for (row = 0; row < 4; row++) for (col = 0; col < 4; col++) {
            uvs[offset] = u[row];
            uvs[offset + 1] = v[3 - col];
            offset += 2;
          }
        } else {
          u[0] = (textureRect.x + texelCorrect) / atlasWidth;
          u[1] = (leftWidth + textureRect.x) / atlasWidth;
          u[2] = (leftWidth + centerWidth + textureRect.x) / atlasWidth;
          u[3] = (textureRect.x + textureRect.width - texelCorrect) / atlasWidth;
          v[3] = (textureRect.y + texelCorrect) / atlasHeight;
          v[2] = (topHeight + textureRect.y) / atlasHeight;
          v[1] = (topHeight + centerHeight + textureRect.y) / atlasHeight;
          v[0] = (textureRect.y + textureRect.height - texelCorrect) / atlasHeight;
          for (row = 0; row < 4; row++) for (col = 0; col < 4; col++) {
            uvs[offset] = u[col];
            uvs[offset + 1] = v[row];
            offset += 2;
          }
        }
      }
    };
    var tiledQuadGenerator = {
      _rebuildQuads_base: function(sprite, spriteFrame, contentSize) {
        var spriteFrame = sprite._spriteFrame, contentSize = sprite._contentSize, vertices = sprite._vertices, corner = sprite._corner, wt = sprite._renderCmd._worldTransform, uvs = sprite._uvs;
        var atlasWidth = spriteFrame._texture.width;
        var atlasHeight = spriteFrame._texture.height;
        var textureRect = spriteFrame._rect;
        var u0, v0, u1, v1;
        var texelCorrect = macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? .5 : 0;
        if (spriteFrame._rotated) {
          u0 = (textureRect.x + texelCorrect) / atlasWidth;
          u1 = (textureRect.x + textureRect.height - texelCorrect) / atlasWidth;
          v0 = (textureRect.y + textureRect.width - texelCorrect) / atlasHeight;
          v1 = (textureRect.y + texelCorrect) / atlasHeight;
        } else {
          u0 = (textureRect.x + texelCorrect) / atlasWidth;
          u1 = (textureRect.x + textureRect.width - texelCorrect) / atlasWidth;
          v0 = (textureRect.y + textureRect.height - texelCorrect) / atlasHeight;
          v1 = (textureRect.y + texelCorrect) / atlasHeight;
        }
        var rectWidth = textureRect.width;
        var rectHeight = textureRect.height;
        var hRepeat = contentSize.width / rectWidth;
        var vRepeat = contentSize.height / rectHeight;
        var row = Math.ceil(vRepeat), col = Math.ceil(hRepeat);
        row * col > 16384 && cc.errorID(2625);
        var dataLength = row * col * 4 * 2;
        if (vertices.length < dataLength) {
          dataPool.put(vertices);
          vertices = dataPool.get(dataLength) || new Float32Array(dataLength);
          sprite._vertices = vertices;
        }
        if (uvs.length < dataLength) {
          dataPool.put(uvs);
          uvs = dataPool.get(dataLength) || new Float32Array(dataLength);
          sprite._uvs = uvs;
        }
        var offset = 0, l, b, r, t;
        sprite._vertCount = 0;
        for (var vindex = 0; vindex < row; ++vindex) for (var hindex = 0; hindex < col; ++hindex) {
          l = rectWidth * hindex;
          b = rectHeight * vindex;
          r = rectWidth * Math.min(hindex + 1, hRepeat);
          t = rectHeight * Math.min(vindex + 1, vRepeat);
          if (webgl) {
            var la = l * wt.a, lb = l * wt.b, ra = r * wt.a, rb = r * wt.b, tcx = t * wt.c + wt.tx, tdy = t * wt.d + wt.ty, bcx = b * wt.c + wt.tx, bdy = b * wt.d + wt.ty;
            vertices[offset] = la + bcx;
            vertices[offset + 1] = lb + bdy;
            vertices[offset + 2] = ra + bcx;
            vertices[offset + 3] = rb + bdy;
            vertices[offset + 4] = la + tcx;
            vertices[offset + 5] = lb + tdy;
            vertices[offset + 6] = ra + tcx;
            vertices[offset + 7] = rb + tdy;
          } else {
            vertices[offset] = l;
            vertices[offset + 1] = b;
            vertices[offset + 2] = r;
            vertices[offset + 3] = b;
            vertices[offset + 4] = l;
            vertices[offset + 5] = t;
            vertices[offset + 6] = r;
            vertices[offset + 7] = t;
          }
          if (spriteFrame._rotated) {
            uvs[offset] = u0;
            uvs[offset + 1] = v1;
            uvs[offset + 2] = u0;
            uvs[offset + 3] = t = v1 + (v0 - v1) * Math.min(1, hRepeat - hindex);
            uvs[offset + 4] = r = u0 + (u1 - u0) * Math.min(1, vRepeat - vindex);
            uvs[offset + 5] = v1;
            uvs[offset + 6] = r;
            uvs[offset + 7] = t;
          } else {
            uvs[offset] = u0;
            uvs[offset + 1] = v0;
            uvs[offset + 2] = r = u0 + (u1 - u0) * Math.min(1, hRepeat - hindex);
            uvs[offset + 3] = v0;
            uvs[offset + 4] = u0;
            uvs[offset + 5] = t = v0 + (v1 - v0) * Math.min(1, vRepeat - vindex);
            uvs[offset + 6] = r;
            uvs[offset + 7] = t;
          }
          offset += 8;
          sprite._vertCount += 4;
          if (offset > dataLength) return;
        }
        corner[0] = 0;
        corner[1] = 8 * (col - 1) + 2;
        corner[2] = (row - 1) * col * 8 + 4;
        corner[3] = dataLength - 2;
      }
    };
    var fillQuadGeneratorBar = {
      _rebuildQuads_base: function(sprite) {
        var spriteFrame = sprite._spriteFrame, contentSize = sprite._contentSize;
        var fillStart = sprite._fillStart;
        var fillRange = sprite._fillRange;
        if (fillRange < 0) {
          fillStart += fillRange;
          fillRange = -fillRange;
        }
        fillRange = fillStart + fillRange;
        fillStart = fillStart > 1 ? 1 : fillStart;
        fillStart = fillStart < 0 ? 0 : fillStart;
        fillRange = fillRange > 1 ? 1 : fillRange;
        fillRange = fillRange < 0 ? 0 : fillRange;
        fillRange -= fillStart;
        var fillType = sprite._fillType;
        var vertices = sprite._vertices, corner = sprite._corner, wt = sprite._renderCmd._worldTransform, uvs = sprite._uvs;
        var fillEnd;
        var l = 0, b = 0, r = contentSize.width, t = contentSize.height;
        var atlasWidth = spriteFrame._texture.width;
        var atlasHeight = spriteFrame._texture.height;
        var textureRect = spriteFrame._rect;
        var ul, vb, ur, vt;
        var texelCorrect = macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? .5 : 0;
        if (spriteFrame._rotated) {
          ul = (textureRect.x + texelCorrect) / atlasWidth;
          vb = (textureRect.y + textureRect.width - texelCorrect) / atlasHeight;
          ur = (textureRect.x + textureRect.height - texelCorrect) / atlasWidth;
          vt = (textureRect.y + texelCorrect) / atlasHeight;
        } else {
          ul = (textureRect.x + texelCorrect) / atlasWidth;
          vb = (textureRect.y + textureRect.height - texelCorrect) / atlasHeight;
          ur = (textureRect.x + textureRect.width - texelCorrect) / atlasWidth;
          vt = (textureRect.y + texelCorrect) / atlasHeight;
        }
        if (vertices.length < 8) {
          dataPool.put(vertices);
          vertices = dataPool.get(8) || new Float32Array(8);
          sprite._vertices = vertices;
        }
        if (uvs.length < 8) {
          dataPool.put(uvs);
          uvs = dataPool.get(8) || new Float32Array(8);
          sprite._uvs = uvs;
        }
        var quadUV = new Array(8);
        if (spriteFrame._rotated) {
          quadUV[0] = quadUV[2] = ul;
          quadUV[4] = quadUV[6] = ur;
          quadUV[3] = quadUV[7] = vb;
          quadUV[1] = quadUV[5] = vt;
        } else {
          quadUV[0] = quadUV[4] = ul;
          quadUV[2] = quadUV[6] = ur;
          quadUV[1] = quadUV[3] = vb;
          quadUV[5] = quadUV[7] = vt;
        }
        fillStart = fillStart > 1 ? 1 : fillStart;
        fillStart = fillStart < 0 ? 0 : fillStart;
        fillRange = fillRange < 0 ? 0 : fillRange;
        fillEnd = fillStart + fillRange;
        fillEnd = fillEnd > 1 ? 1 : fillEnd;
        var progressStart, progressEnd;
        switch (fillType) {
         case FillType.HORIZONTAL:
          progressStart = l + (r - l) * fillStart;
          progressEnd = l + (r - l) * fillEnd;
          l = progressStart;
          r = progressEnd;
          uvs[0] = quadUV[0] + (quadUV[2] - quadUV[0]) * fillStart;
          uvs[1] = quadUV[1];
          uvs[2] = quadUV[0] + (quadUV[2] - quadUV[0]) * fillEnd;
          uvs[3] = quadUV[3];
          uvs[4] = quadUV[4] + (quadUV[6] - quadUV[4]) * fillStart;
          uvs[5] = quadUV[5];
          uvs[6] = quadUV[4] + (quadUV[6] - quadUV[4]) * fillEnd;
          uvs[7] = quadUV[7];
          break;

         case FillType.VERTICAL:
          progressStart = b + (t - b) * fillStart;
          progressEnd = b + (t - b) * fillEnd;
          b = progressStart;
          t = progressEnd;
          uvs[0] = quadUV[0];
          uvs[1] = quadUV[1] + (quadUV[5] - quadUV[1]) * fillStart;
          uvs[2] = quadUV[2];
          uvs[3] = quadUV[3] + (quadUV[7] - quadUV[3]) * fillStart;
          uvs[4] = quadUV[4];
          uvs[5] = quadUV[1] + (quadUV[5] - quadUV[1]) * fillEnd;
          uvs[6] = quadUV[6];
          uvs[7] = quadUV[3] + (quadUV[7] - quadUV[3]) * fillEnd;
          break;

         default:
          cc.errorID(2626);
        }
        if (webgl) {
          var la = l * wt.a, lb = l * wt.b, ra = r * wt.a, rb = r * wt.b, tcx = t * wt.c + wt.tx, tdy = t * wt.d + wt.ty, bcx = b * wt.c + wt.tx, bdy = b * wt.d + wt.ty;
          vertices[0] = la + bcx;
          vertices[1] = lb + bdy;
          vertices[2] = ra + bcx;
          vertices[3] = rb + bdy;
          vertices[4] = la + tcx;
          vertices[5] = lb + tdy;
          vertices[6] = ra + tcx;
          vertices[7] = rb + tdy;
        } else {
          vertices[0] = l;
          vertices[1] = b;
          vertices[2] = r;
          vertices[3] = b;
          vertices[4] = l;
          vertices[5] = t;
          vertices[6] = r;
          vertices[7] = t;
        }
        sprite._vertCount = 4;
        corner[0] = 0;
        corner[1] = 2;
        corner[2] = 4;
        corner[3] = 6;
      }
    };
    var fillQuadGeneratorRadial = {
      _vertPos: [ cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0) ],
      _vertices: [ cc.v2(0, 0), cc.v2(0, 0) ],
      _uvs: [ cc.v2(0, 0), cc.v2(0, 0) ],
      _intersectPoint_1: [ cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0) ],
      _intersectPoint_2: [ cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0) ],
      outVerts: null,
      outUvs: null,
      rawVerts: null,
      rawUvs: null,
      _rebuildQuads_base: function(sprite) {
        var spriteFrame = sprite._spriteFrame, contentSize = sprite._contentSize;
        var fillStart = sprite._fillStart;
        var fillRange = sprite._fillRange;
        if (fillRange < 0) {
          fillStart += fillRange;
          fillRange = -fillRange;
        }
        sprite._isTriangle = true;
        if (!sprite._rawVerts) {
          sprite._rawVerts = dataPool.get(8) || new Float32Array(8);
          sprite._rawUvs = dataPool.get(8) || new Float32Array(8);
        }
        var fillCenter = sprite._fillCenter;
        var vertices = sprite._vertices, corner = sprite._corner, uvs = sprite._uvs, rawVerts = sprite._rawVerts, rawUvs = sprite._rawUvs, wt = sprite._renderCmd._worldTransform;
        while (fillStart >= 1) fillStart -= 1;
        while (fillStart < 0) fillStart += 1;
        var cx = fillCenter.x * contentSize.width, cy = fillCenter.y * contentSize.height;
        var center = cc.v2(cx, cy);
        fillStart *= 2 * Math.PI;
        fillRange *= 2 * Math.PI;
        var fillEnd = fillStart + fillRange;
        this.outVerts = vertices;
        this.outUvs = uvs;
        this.rawVerts = rawVerts;
        this.rawUvs = rawUvs;
        this._calculateVertices(wt, spriteFrame, contentSize);
        this._calculateUVs(spriteFrame);
        var _vertPos = this._vertPos, _vertices = this._vertices;
        _vertPos[0].x = _vertPos[3].x = _vertices[0].x;
        _vertPos[1].x = _vertPos[2].x = _vertices[1].x;
        _vertPos[0].y = _vertPos[1].y = _vertices[0].y;
        _vertPos[2].y = _vertPos[3].y = _vertices[1].y;
        center.x > _vertices[1].x && (center.x = _vertices[1].x);
        center.x < _vertices[0].x && (center.x = _vertices[0].x);
        center.y < _vertices[0].y && (center.y = _vertices[0].y);
        center.y > _vertices[1].y && (center.y = _vertices[1].y);
        rawVerts[0] = rawVerts[4] = this._vertices[0].x;
        rawVerts[2] = rawVerts[6] = this._vertices[1].x;
        rawVerts[1] = rawVerts[3] = this._vertices[0].y;
        rawVerts[5] = rawVerts[7] = this._vertices[1].y;
        if (spriteFrame._rotated) {
          rawUvs[0] = rawUvs[2] = this._uvs[0].x;
          rawUvs[4] = rawUvs[6] = this._uvs[1].x;
          rawUvs[3] = rawUvs[7] = this._uvs[0].y;
          rawUvs[1] = rawUvs[5] = this._uvs[1].y;
        } else {
          rawUvs[0] = rawUvs[4] = this._uvs[0].x;
          rawUvs[2] = rawUvs[6] = this._uvs[1].x;
          rawUvs[1] = rawUvs[3] = this._uvs[0].y;
          rawUvs[5] = rawUvs[7] = this._uvs[1].y;
        }
        var triangles = [ null, null, null, null ];
        center.x !== this._vertices[0].x && (triangles[0] = [ 3, 0 ]);
        center.x !== this._vertices[1].x && (triangles[2] = [ 1, 2 ]);
        center.y !== this._vertices[0].y && (triangles[1] = [ 0, 1 ]);
        center.y !== this._vertices[1].y && (triangles[3] = [ 2, 3 ]);
        this._getInsectedPoints(this._vertices[0].x, this._vertices[1].x, this._vertices[0].y, this._vertices[1].y, center, fillStart, this._intersectPoint_1);
        this._getInsectedPoints(this._vertices[0].x, this._vertices[1].x, this._vertices[0].y, this._vertices[1].y, center, fillStart + fillRange, this._intersectPoint_2);
        var dataLength = 30;
        if (vertices.length < dataLength) {
          dataPool.put(vertices);
          vertices = dataPool.get(dataLength) || new Float32Array(dataLength);
          this.outVerts = sprite._vertices = vertices;
        }
        if (uvs.length < dataLength) {
          dataPool.put(uvs);
          uvs = dataPool.get(dataLength) || new Float32Array(dataLength);
          this.outUvs = sprite._uvs = uvs;
        }
        var offset = 0, count = 0;
        for (var triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
          var triangle = triangles[triangleIndex];
          if (null === triangle) continue;
          if (fillRange >= 2 * Math.PI) {
            this._generateTriangle(wt, offset, center, this._vertPos[triangle[0]], this._vertPos[triangle[1]]);
            offset += 6;
            count += 3;
            continue;
          }
          var startAngle = this._getVertAngle(center, this._vertPos[triangle[0]]);
          var endAngle = this._getVertAngle(center, this._vertPos[triangle[1]]);
          endAngle < startAngle && (endAngle += 2 * Math.PI);
          startAngle -= 2 * Math.PI;
          endAngle -= 2 * Math.PI;
          for (var testIndex = 0; testIndex < 3; ++testIndex) {
            if (startAngle >= fillEnd) ; else if (startAngle >= fillStart) {
              endAngle >= fillEnd ? this._generateTriangle(wt, offset, center, this._vertPos[triangle[0]], this._intersectPoint_2[triangleIndex]) : this._generateTriangle(wt, offset, center, this._vertPos[triangle[0]], this._vertPos[triangle[1]]);
              offset += 6;
              count += 3;
            } else if (endAngle <= fillStart) ; else if (endAngle <= fillEnd) {
              this._generateTriangle(wt, offset, center, this._intersectPoint_1[triangleIndex], this._vertPos[triangle[1]]);
              offset += 6;
              count += 3;
            } else {
              this._generateTriangle(wt, offset, center, this._intersectPoint_1[triangleIndex], this._intersectPoint_2[triangleIndex]);
              offset += 6;
              count += 3;
            }
            startAngle += 2 * Math.PI;
            endAngle += 2 * Math.PI;
          }
        }
        sprite._vertCount = count;
        var minx = Infinity, miny = Infinity, maxx = -Infinity, maxy = -Infinity;
        var x, y;
        for (var i = 0, l = offset; i < l; i += 2) {
          x = vertices[i];
          y = vertices[i + 1];
          if (x <= minx) {
            minx = x;
            corner[0] = i;
          } else if (x >= maxx) {
            maxx = x;
            corner[1] = i;
          }
          if (y <= miny) {
            miny = y;
            corner[2] = i;
          } else if (y >= maxy) {
            maxy = y;
            corner[3] = i;
          }
        }
      },
      _generateTriangle: function(wt, offset, vert0, vert1, vert2) {
        var rawVerts = this.rawVerts;
        var rawUvs = this.rawUvs;
        var vertices = this.outVerts;
        var v0x = rawVerts[0];
        var v0y = rawVerts[1];
        var v1x = rawVerts[6];
        var v1y = rawVerts[7];
        var progressX, progressY;
        if (webgl) {
          vertices[offset] = vert0.x * wt.a + vert0.y * wt.c + wt.tx;
          vertices[offset + 1] = vert0.x * wt.b + vert0.y * wt.d + wt.ty;
          vertices[offset + 2] = vert1.x * wt.a + vert1.y * wt.c + wt.tx;
          vertices[offset + 3] = vert1.x * wt.b + vert1.y * wt.d + wt.ty;
          vertices[offset + 4] = vert2.x * wt.a + vert2.y * wt.c + wt.tx;
          vertices[offset + 5] = vert2.x * wt.b + vert2.y * wt.d + wt.ty;
        } else {
          vertices[offset] = vert0.x;
          vertices[offset + 1] = vert0.y;
          vertices[offset + 2] = vert1.x;
          vertices[offset + 3] = vert1.y;
          vertices[offset + 4] = vert2.x;
          vertices[offset + 5] = vert2.y;
        }
        progressX = (vert0.x - v0x) / (v1x - v0x);
        progressY = (vert0.y - v0y) / (v1y - v0y);
        this._generateUV(progressX, progressY, rawUvs, offset);
        progressX = (vert1.x - v0x) / (v1x - v0x);
        progressY = (vert1.y - v0y) / (v1y - v0y);
        this._generateUV(progressX, progressY, rawUvs, offset + 2);
        progressX = (vert2.x - v0x) / (v1x - v0x);
        progressY = (vert2.y - v0y) / (v1y - v0y);
        this._generateUV(progressX, progressY, rawUvs, offset + 4);
      },
      _generateUV: function(progressX, progressY, uvs, offset) {
        var out = this.outUvs;
        var px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX;
        var px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX;
        var py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX;
        var py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX;
        out[offset] = px1 + (px2 - px1) * progressY;
        out[offset + 1] = py1 + (py2 - py1) * progressY;
      },
      _isAngleIn: function(angle, start, rangeAngle) {
        var pi_2 = 2 * Math.PI;
        while (angle < start || angle >= start + pi_2) {
          angle < start && (angle += pi_2);
          angle >= start + pi_2 && (angle -= pi_2);
        }
        return angle <= start + rangeAngle;
      },
      _getVertAngle: function(start, end) {
        var placementX, placementY;
        placementX = end.x - start.x;
        placementY = end.y - start.y;
        if (0 === placementX && 0 === placementY) return;
        if (0 === placementX) return placementY > 0 ? .5 * Math.PI : 1.5 * Math.PI;
        var angle = Math.atan(placementY / placementX);
        placementX < 0 && (angle += Math.PI);
        return angle;
      },
      _getInsectedPoints: function(left, right, bottom, top, center, angle, intersectPoints) {
        var result = [ null, null, null, null ];
        var sinAngle = Math.sin(angle);
        var cosAngle = Math.cos(angle);
        var tanAngle, cotAngle;
        if (0 !== Math.cos(angle)) {
          tanAngle = sinAngle / cosAngle;
          if ((left - center.x) * cosAngle > 0) {
            var yleft = center.y + tanAngle * (left - center.x);
            intersectPoints[0].x = left;
            intersectPoints[0].y = yleft;
          }
          if ((right - center.x) * cosAngle > 0) {
            var yright = center.y + tanAngle * (right - center.x);
            intersectPoints[2].x = right;
            intersectPoints[2].y = yright;
          }
        }
        if (0 !== Math.sin(angle)) {
          cotAngle = cosAngle / sinAngle;
          if ((top - center.y) * sinAngle > 0) {
            var xtop = center.x + cotAngle * (top - center.y);
            intersectPoints[3].x = xtop;
            intersectPoints[3].y = top;
          }
          if ((bottom - center.y) * sinAngle > 0) {
            var xbottom = center.x + cotAngle * (bottom - center.y);
            intersectPoints[1].x = xbottom;
            intersectPoints[1].y = bottom;
          }
        }
        return result;
      },
      _calculateVertices: function(wt, spriteFrame, contentSize) {
        var x0, x3, y0, y3;
        x0 = 0;
        y0 = 0;
        x3 = contentSize.width;
        y3 = contentSize.height;
        this._vertices[0].x = x0;
        this._vertices[0].y = y0;
        this._vertices[1].x = x3;
        this._vertices[1].y = y3;
      },
      _calculateUVs: function(spriteFrame) {
        var atlasWidth = spriteFrame._texture.width;
        var atlasHeight = spriteFrame._texture.height;
        var textureRect = spriteFrame._rect;
        var u0, u3, v0, v3;
        var texelCorrect = macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? .5 : 0;
        if (spriteFrame._rotated) {
          u0 = (textureRect.x + texelCorrect) / atlasWidth;
          u3 = (textureRect.x + textureRect.height - texelCorrect) / atlasWidth;
          v0 = (textureRect.y + texelCorrect) / atlasHeight;
          v3 = (textureRect.y + textureRect.width - texelCorrect) / atlasHeight;
        } else {
          u0 = (textureRect.x + texelCorrect) / atlasWidth;
          u3 = (textureRect.x + textureRect.width - texelCorrect) / atlasWidth;
          v0 = (textureRect.y + texelCorrect) / atlasHeight;
          v3 = (textureRect.y + textureRect.height - texelCorrect) / atlasHeight;
        }
        this._uvs[0].x = u0;
        this._uvs[0].y = v3;
        this._uvs[1].x = u3;
        this._uvs[1].y = v0;
      }
    };
    var meshQuadGenerator = {
      _rebuildQuads_base: function(sprite, spriteFrame, polygonInfo) {
        if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) return;
        var polygonInfo = sprite._meshPolygonInfo;
        if (!polygonInfo) return;
        var wt = sprite._renderCmd._worldTransform;
        var srcVerts = polygonInfo.triangles.verts;
        var vertices = sprite._vertices;
        var uvs = sprite._uvs;
        var count = srcVerts.length;
        var corner = sprite._corner;
        var dataLength = 2 * count;
        if (vertices.length < dataLength) {
          dataPool.put(vertices);
          vertices = dataPool.get(dataLength) || new Float32Array(dataLength);
          sprite._vertices = vertices;
        }
        if (uvs.length < dataLength) {
          dataPool.put(uvs);
          uvs = dataPool.get(dataLength) || new Float32Array(dataLength);
          sprite._uvs = uvs;
        }
        var l = Infinity, b = Infinity, r = -Infinity, t = -Infinity;
        for (var i = 0; i < count; i++) {
          var x = srcVerts[i].x * wt.a + srcVerts[i].y * wt.c + wt.tx;
          var y = srcVerts[i].x * wt.b + srcVerts[i].y * wt.d + wt.ty;
          vertices[2 * i] = x;
          vertices[2 * i + 1] = y;
          uvs[2 * i] = srcVerts[i].u;
          uvs[2 * i + 1] = srcVerts[i].v;
          if (x < l) {
            l = x;
            corner[0] = 2 * i;
          }
          if (x > r) {
            r = x;
            corner[1] = 2 * i;
          }
          if (y < b) {
            b = y;
            corner[2] = 2 * i;
          }
          if (y > t) {
            t = y;
            corner[3] = 2 * i;
          }
        }
        sprite._vertCount = count;
      }
    };
    cc.Scale9Sprite = _ccsg.Node.extend({
      _spriteFrame: null,
      _insetLeft: 0,
      _insetRight: 0,
      _insetTop: 0,
      _insetBottom: 0,
      _blendFunc: null,
      _renderingType: 1,
      _brightState: 0,
      _rawVerts: null,
      _rawUvs: null,
      _vertices: null,
      _uvs: null,
      _vertCount: 0,
      _quadsDirty: true,
      _uvsDirty: true,
      _isTriangle: false,
      _isTrimmedContentSize: true,
      _fillType: 0,
      _fillCenter: null,
      _fillStart: 0,
      _fillRange: 2 * Math.PI,
      _distortionOffset: null,
      _distortionTiling: null,
      _meshPolygonInfo: null,
      ctor: function(spiteFrame) {
        _ccsg.Node.prototype.ctor.call(this);
        this._renderCmd.setState(this._brightState);
        this._blendFunc = cc.BlendFunc._alphaNonPremultiplied();
        this._fillCenter = cc.v2(0, 0);
        this.setAnchorPoint(cc.p(.5, .5));
        this._rawVerts = null;
        this._rawUvs = null;
        this._vertices = dataPool.get(8) || new Float32Array(8);
        this._uvs = dataPool.get(8) || new Float32Array(8);
        spiteFrame && this.setSpriteFrame(spiteFrame);
        void 0 === webgl && (webgl = cc._renderType === cc.game.RENDER_TYPE_WEBGL);
        this._corner = [];
      },
      loaded: function() {
        return null !== this._spriteFrame && this._spriteFrame.textureLoaded();
      },
      setTexture: function(textureOrTextureFile) {
        var spriteFrame = new cc.SpriteFrame(textureOrTextureFile);
        this.setSpriteFrame(spriteFrame);
      },
      setSpriteFrame: function(spriteFrame) {
        if (spriteFrame) {
          this._spriteFrame = spriteFrame;
          this._quadsDirty = true;
          this._uvsDirty = true;
          this._renderCmd._needDraw = false;
          var self = this;
          function onResourceDataLoaded() {
            self._spriteFrame && 0 === self._contentSize.width && 0 === self._contentSize.height && self.setContentSize(self._spriteFrame._rect);
            self._renderCmd._needDraw = true;
            self._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
          }
          spriteFrame.textureLoaded() ? onResourceDataLoaded() : spriteFrame.once("load", onResourceDataLoaded, this);
        }
      },
      setBlendFunc: function(blendFunc, dst) {
        if (void 0 === dst) {
          this._blendFunc.src = blendFunc.src;
          this._blendFunc.dst = blendFunc.dst;
        } else {
          this._blendFunc.src = blendFunc;
          this._blendFunc.dst = dst;
        }
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
      },
      getBlendFunc: function() {
        return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst);
      },
      setContentSize: function(width, height) {
        if (void 0 === height) {
          height = width.height;
          width = width.width;
        }
        if (width === this._contentSize.width && height === this._contentSize.height) return;
        _ccsg.Node.prototype.setContentSize.call(this, width, height);
        this._quadsDirty = true;
      },
      enableTrimmedContentSize: function(isTrimmed) {
        if (this._isTrimmedContentSize !== isTrimmed) {
          this._isTrimmedContentSize = isTrimmed;
          this._quadsDirty = true;
          this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
        }
      },
      setState: function(state) {
        this._brightState = state;
        this._renderCmd.setState(state);
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
      },
      getState: function() {
        return this._brightState;
      },
      setRenderingType: function(type) {
        if (this._renderingType === type) return;
        this._renderingType = type;
        this._quadsDirty = true;
        this._uvsDirty = true;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
      },
      getRenderingType: function() {
        return this._renderingType;
      },
      setInsetLeft: function(insetLeft) {
        this._insetLeft = insetLeft;
        this._quadsDirty = true;
        this._uvsDirty = true;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
      },
      getInsetLeft: function() {
        return this._insetLeft;
      },
      setInsetTop: function(insetTop) {
        this._insetTop = insetTop;
        this._quadsDirty = true;
        this._uvsDirty = true;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
      },
      getInsetTop: function() {
        return this._insetTop;
      },
      setInsetRight: function(insetRight) {
        this._insetRight = insetRight;
        this._quadsDirty = true;
        this._uvsDirty = true;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
      },
      getInsetRight: function() {
        return this._insetRight;
      },
      setInsetBottom: function(insetBottom) {
        this._insetBottom = insetBottom;
        this._quadsDirty = true;
        this._uvsDirty = true;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
      },
      getInsetBottom: function() {
        return this._insetBottom;
      },
      setFillType: function(value) {
        if (this._fillType === value) return;
        this._fillType = value;
        if (this._renderingType === RenderingType.FILLED) {
          this._quadsDirty = true;
          this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
        }
      },
      getFillType: function() {
        return this._fillType;
      },
      setFillCenter: function(value, y) {
        this._fillCenter = cc.v2(value, y);
        if (this._renderingType === RenderingType.FILLED && this._fillType === FillType.RADIAL) {
          this._quadsDirty = true;
          this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
        }
      },
      setDistortionTiling: function(valueOrX, y) {
        if (void 0 === y) {
          y = valueOrX.y;
          valueOrX = valueOrX.x;
        }
        this._distortionTiling = this._distortionTiling || cc.v2(0, 0);
        this._distortionTiling.x = valueOrX;
        this._distortionTiling.y = y;
      },
      setDistortionOffset: function(valueOrX, y) {
        if (void 0 === y) {
          y = valueOrX.y;
          valueOrX = valueOrX.x;
        }
        this._distortionOffset = this._distortionOffset || cc.v2(0, 0);
        this._distortionOffset.x = valueOrX;
        this._distortionOffset.y = y;
      },
      getFillCenter: function() {
        return cc.v2(this._fillCenter);
      },
      setFillStart: function(value) {
        if (this._fillStart === value) return;
        this._fillStart = value;
        if (this._renderingType === RenderingType.FILLED) {
          this._quadsDirty = true;
          this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
        }
      },
      getFillStart: function() {
        return this._fillStart;
      },
      setFillRange: function(value) {
        if (this._fillRange === value) return;
        this._fillRange = value;
        if (this._renderingType === RenderingType.FILLED) {
          this._quadsDirty = true;
          this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
        }
      },
      getFillRange: function() {
        return this._fillRange;
      },
      _rebuildQuads: function() {
        if (!this._spriteFrame || !this._spriteFrame.textureLoaded()) {
          this._renderCmd._needDraw = false;
          return;
        }
        this._isTriangle = false;
        var quadGenerator;
        switch (this._renderingType) {
         case RenderingType.SIMPLE:
          quadGenerator = simpleQuadGenerator;
          break;

         case RenderingType.SLICED:
          quadGenerator = scale9QuadGenerator;
          break;

         case RenderingType.TILED:
          quadGenerator = tiledQuadGenerator;
          break;

         case RenderingType.FILLED:
          quadGenerator = this._fillType === FillType.RADIAL ? fillQuadGeneratorRadial : fillQuadGeneratorBar;
          break;

         case RenderingType.MESH:
          quadGenerator = meshQuadGenerator;
        }
        if (quadGenerator) quadGenerator._rebuildQuads_base(this); else {
          this._quadsDirty = false;
          this._uvsDirty = false;
          this._renderCmd._needDraw = false;
          cc.errorID(2627);
        }
        this._quadsDirty = false;
        this._uvsDirty = false;
      },
      _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.Scale9Sprite.CanvasRenderCmd(this) : new cc.Scale9Sprite.WebGLRenderCmd(this);
      },
      setMeshPolygonInfo: function(polygonInfo) {
        this.setRenderingType(RenderingType.MESH);
        this._meshPolygonInfo = polygonInfo;
        this._quadsDirty = true;
        this._uvsDirty = true;
      },
      getMeshPolygonInfo: function() {
        return this._meshPolygonInfo;
      }
    });
    var _p = cc.Scale9Sprite.prototype;
    cc.js.addon(_p, EventTarget.prototype);
    cc.defineGetterSetter(_p, "insetLeft", _p.getInsetLeft, _p.setInsetLeft);
    cc.defineGetterSetter(_p, "insetTop", _p.getInsetTop, _p.setInsetTop);
    cc.defineGetterSetter(_p, "insetRight", _p.getInsetRight, _p.setInsetRight);
    cc.defineGetterSetter(_p, "insetBottom", _p.getInsetBottom, _p.setInsetBottom);
    cc.Scale9Sprite.state = {
      NORMAL: 0,
      GRAY: 1,
      DISTORTION: 2
    };
    var RenderingType = cc.Scale9Sprite.RenderingType = cc.Enum({
      SIMPLE: 0,
      SLICED: 1,
      TILED: 2,
      FILLED: 3,
      MESH: 4
    });
    var FillType = cc.Scale9Sprite.FillType = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1,
      RADIAL: 2
    });
  }), {
    "../event/event-target": 60
  } ],
  124: [ (function(require, module, exports) {
    cc.Scale9Sprite.CanvasRenderCmd = function(renderable) {
      this._rootCtor(renderable);
      this._node.loaded() ? this._needDraw = true : this._needDraw = false;
      this._state = cc.Scale9Sprite.state.NORMAL;
      this._originalTexture = this._textureToRender = null;
    };
    var proto = cc.Scale9Sprite.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
    proto.constructor = cc.Scale9Sprite.CanvasRenderCmd;
    proto.updateTransform = function(parentCmd) {
      this.originUpdateTransform(parentCmd);
      this._node._rebuildQuads();
    };
    proto._doCulling = function() {
      var rect = cc.visibleRect, bb = this._currentRegion, l = bb._minX, r = bb._maxX, b = bb._minY, t = bb._maxY, vl = rect.left.x, vr = rect.right.x, vt = rect.top.y, vb = rect.bottom.y;
      this._needDraw = !(r < vl || l > vr || t < vb || b > vt);
    };
    proto._updateDisplayColor = function(parentColor) {
      _ccsg.Node.WebGLRenderCmd.prototype._updateDisplayColor.call(this, parentColor);
      this._originalTexture = this._textureToRender = null;
    };
    proto._syncDisplayColor = function(parentColor) {
      _ccsg.Node.WebGLRenderCmd.prototype._syncDisplayColor.call(this, parentColor);
      this._originalTexture = this._textureToRender = null;
    };
    proto.setState = function(state) {
      if (this._state === state) return;
      this._state = state;
      this._originalTexture = this._textureToRender = null;
    };
    proto.rendering = function(ctx, scaleX, scaleY) {
      var node = this._node;
      var locDisplayOpacity = this._displayedOpacity;
      var alpha = locDisplayOpacity / 255;
      var locTexture = null;
      node._spriteFrame && (locTexture = node._spriteFrame._texture);
      if (!node.loaded() || 0 === locDisplayOpacity) return;
      if (null === this._textureToRender || this._originalTexture !== locTexture) {
        this._textureToRender = this._originalTexture = locTexture;
        cc.Scale9Sprite.state.GRAY === this._state && (this._textureToRender = this._textureToRender._generateGrayTexture());
        if (cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB) {
          var color = node.getDisplayedColor();
          !locTexture || 255 === color.r && 255 === color.g && 255 === color.b || (this._textureToRender = this._textureToRender._generateColorTexture(color.r, color.g, color.b));
        }
      }
      var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
      wrapper.setTransform(this._worldTransform, scaleX, scaleY);
      wrapper.setCompositeOperation(_ccsg.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(node._blendFunc));
      wrapper.setGlobalAlpha(alpha);
      if (this._textureToRender) {
        node._quadsDirty && node._rebuildQuads();
        var sx, sy, sw, sh;
        var x, y, w, h;
        var textureWidth = this._textureToRender.width;
        var textureHeight = this._textureToRender.height;
        var image = this._textureToRender._image;
        var vertices = node._vertices;
        var uvs = node._uvs;
        var i = 0, off = 0;
        if (node._isTriangle) {
          var rawVerts = node._rawVerts, rawUvs = node._rawUvs;
          x = rawVerts[0];
          y = rawVerts[1];
          w = rawVerts[6] - x;
          h = rawVerts[7] - y;
          y = -y - h;
          sx = rawUvs[4] * textureWidth;
          sy = rawUvs[5] * textureHeight;
          sw = (rawUvs[6] - rawUvs[0]) * textureWidth;
          sh = (rawUvs[1] - rawUvs[7]) * textureHeight;
          wrapper.save();
          context.beginPath();
          var triangleCount = Math.floor(node._vertCount / 3);
          for (i = 0, off = 0; i < triangleCount; i++) {
            context.moveTo(vertices[off++], -vertices[off++]);
            context.lineTo(vertices[off++], -vertices[off++]);
            context.lineTo(vertices[off++], -vertices[off++]);
          }
          context.clip();
          if ("" !== this._textureToRender._pattern) {
            wrapper.setFillStyle(context.createPattern(image, this._textureToRender._pattern));
            context.fillRect(x, y, w, h);
          } else sw > 0 && sh > 0 && w > 0 && h > 0 && context.drawImage(image, sx, sy, sw, sh, x, y, w, h);
          wrapper.restore();
          cc.g_NumberOfDraws += triangleCount;
        } else if (node._renderingType === cc.Scale9Sprite.RenderingType.SLICED) {
          for (var r = 0; r < 3; ++r) for (var c = 0; c < 3; ++c) {
            off = 8 * r + 2 * c;
            x = vertices[off];
            y = vertices[off + 1];
            w = vertices[off + 10] - x;
            h = vertices[off + 11] - y;
            y = -y - h;
            sx = uvs[off] * textureWidth;
            sy = uvs[off + 11] * textureHeight;
            sw = (uvs[off + 10] - uvs[off]) * textureWidth;
            sh = (uvs[off + 1] - uvs[off + 11]) * textureHeight;
            sw > 0 && sh > 0 && w > 0 && h > 0 && context.drawImage(image, sx, sy, sw, sh, x, y, w, h);
          }
          cc.g_NumberOfDraws += 9;
        } else {
          var quadCount = Math.floor(node._vertCount / 4);
          for (i = 0, off = 0; i < quadCount; i++) {
            x = vertices[off];
            y = vertices[off + 1];
            w = vertices[off + 6] - x;
            h = vertices[off + 7] - y;
            y = -y - h;
            sx = uvs[off] * textureWidth;
            sy = uvs[off + 7] * textureHeight;
            sw = (uvs[off + 6] - uvs[off]) * textureWidth;
            sh = (uvs[off + 1] - uvs[off + 7]) * textureHeight;
            if ("" !== this._textureToRender._pattern) {
              wrapper.setFillStyle(context.createPattern(image, this._textureToRender._pattern));
              context.fillRect(x, y, w, h);
            } else sw > 0 && sh > 0 && w > 0 && h > 0 && context.drawImage(image, sx, sy, sw, sh, x, y, w, h);
            off += 8;
          }
          cc.g_NumberOfDraws += quadCount;
        }
      }
    };
  }), {} ],
  125: [ (function(require, module, exports) {
    var ccgl = cc.gl;
    cc.Scale9Sprite.WebGLRenderCmd = function(renderable) {
      this._rootCtor(renderable);
      this._node.loaded() ? this._needDraw = true : this._needDraw = false;
      this.vertexType = cc.renderer.VertexType.QUAD;
      this._dirty = false;
      this._shaderProgram = cc.shaderCache.programForKey(cc.macro.SHADER_SPRITE_POSITION_TEXTURECOLOR);
    };
    var Scale9Sprite = cc.Scale9Sprite;
    var proto = Scale9Sprite.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
    proto.constructor = Scale9Sprite.WebGLRenderCmd;
    proto._uploadSliced = function(vertices, uvs, color, z, f32buffer, ui32buffer, offset) {
      var off;
      for (var r = 0; r < 3; ++r) for (var c = 0; c < 3; ++c) {
        off = 8 * r + 2 * c;
        f32buffer[offset] = vertices[off];
        f32buffer[offset + 1] = vertices[off + 1];
        f32buffer[offset + 2] = z;
        ui32buffer[offset + 3] = color;
        f32buffer[offset + 4] = uvs[off];
        f32buffer[offset + 5] = uvs[off + 1];
        offset += 6;
        f32buffer[offset] = vertices[off + 2];
        f32buffer[offset + 1] = vertices[off + 3];
        f32buffer[offset + 2] = z;
        ui32buffer[offset + 3] = color;
        f32buffer[offset + 4] = uvs[off + 2];
        f32buffer[offset + 5] = uvs[off + 3];
        offset += 6;
        f32buffer[offset] = vertices[off + 8];
        f32buffer[offset + 1] = vertices[off + 9];
        f32buffer[offset + 2] = z;
        ui32buffer[offset + 3] = color;
        f32buffer[offset + 4] = uvs[off + 8];
        f32buffer[offset + 5] = uvs[off + 9];
        offset += 6;
        f32buffer[offset] = vertices[off + 10];
        f32buffer[offset + 1] = vertices[off + 11];
        f32buffer[offset + 2] = z;
        ui32buffer[offset + 3] = color;
        f32buffer[offset + 4] = uvs[off + 10];
        f32buffer[offset + 5] = uvs[off + 11];
        offset += 6;
      }
      return 36;
    };
    proto.updateTransform = function(parentCmd) {
      this.originUpdateTransform(parentCmd);
      this._node._rebuildQuads();
    };
    proto._doCulling = function() {
      var node = this._node;
      var rect = cc.visibleRect;
      this._cameraFlag > 0 && (rect = cc.Camera.main.visibleRect);
      var vl = rect.left.x;
      var vr = rect.right.x;
      var vt = rect.top.y;
      var vb = rect.bottom.y;
      var vert = node._vertices, corner = node._corner, c0 = corner[0], c1 = corner[1], c2 = corner[2], c3 = corner[3], x0 = vert[c0], x1 = vert[c1], x2 = vert[c2], x3 = vert[c3], y0 = vert[c0 + 1], y1 = vert[c1 + 1], y2 = vert[c2 + 1], y3 = vert[c3 + 1];
      this._needDraw = !((x0 - vl & x1 - vl & x2 - vl & x3 - vl) >> 31 || (vr - x0 & vr - x1 & vr - x2 & vr - x3) >> 31 || (y0 - vb & y1 - vb & y2 - vb & y3 - vb) >> 31 || (vt - y0 & vt - y1 & vt - y2 & vt - y3) >> 31);
    };
    proto.uploadData = function(f32buffer, ui32buffer, vertexDataOffset) {
      var node = this._node;
      if (0 === this._displayedOpacity) return 0;
      node._quadsDirty && node._rebuildQuads();
      if (node._distortionOffset && this._shaderProgram === Scale9Sprite.WebGLRenderCmd._distortionProgram) {
        this._shaderProgram.use();
        this._shaderProgram.setUniformLocationWith2f(Scale9Sprite.WebGLRenderCmd._distortionOffset, node._distortionOffset.x, node._distortionOffset.y);
        this._shaderProgram.setUniformLocationWith2f(Scale9Sprite.WebGLRenderCmd._distortionTiling, node._distortionTiling.x, node._distortionTiling.y);
        cc.renderer._breakBatch();
      }
      var opacity = this._displayedOpacity;
      var color, colorVal = this._displayedColor._val;
      if (node._opacityModifyRGB) {
        var a = opacity / 255, r = this._displayedColor.r * a, g = this._displayedColor.g * a, b = this._displayedColor.b * a;
        color = (opacity << 24 >>> 0) + (b << 16) + (g << 8) + r;
      } else color = (opacity << 24 >>> 0) + ((65280 & colorVal) << 8) + ((16711680 & colorVal) >> 8) + (colorVal >>> 24);
      var z = node._vertexZ;
      var vertices = node._vertices;
      var uvs = node._uvs;
      var types = Scale9Sprite.RenderingType;
      var offset = vertexDataOffset;
      var len = 0;
      switch (node._renderingType) {
       case types.SIMPLE:
       case types.TILED:
       case types.FILLED:
       case types.MESH:
        len = this._node._vertCount;
        for (var i = 0, srcOff = 0; i < len; i++, srcOff += 2) {
          f32buffer[offset] = vertices[srcOff];
          f32buffer[offset + 1] = vertices[srcOff + 1];
          f32buffer[offset + 2] = z;
          ui32buffer[offset + 3] = color;
          f32buffer[offset + 4] = uvs[srcOff];
          f32buffer[offset + 5] = uvs[srcOff + 1];
          offset += 6;
        }
        break;

       case types.SLICED:
        len = this._uploadSliced(vertices, uvs, color, z, f32buffer, ui32buffer, offset);
      }
      node._renderingType === types.MESH ? this.vertexType = cc.renderer.VertexType.CUSTOM : node._renderingType === types.FILLED && node._fillType === Scale9Sprite.FillType.RADIAL ? this.vertexType = cc.renderer.VertexType.TRIANGLE : this.vertexType = cc.renderer.VertexType.QUAD;
      return len;
    };
    proto.uploadIndexData = function(indexData, indexSize, batchingSize) {
      var polygonInfo = this._node._meshPolygonInfo;
      if (!polygonInfo) return 0;
      var indices = polygonInfo.triangles.indices;
      var len = indices.length;
      for (var i = 0; i < len; i++) indexData[indexSize + i] = batchingSize + indices[i];
      return len;
    };
    proto.setState = function(state) {
      state === Scale9Sprite.state.NORMAL ? this._shaderProgram = cc.shaderCache.programForKey(cc.macro.SHADER_SPRITE_POSITION_TEXTURECOLOR) : state === Scale9Sprite.state.GRAY ? this._shaderProgram = cc.Scale9Sprite.WebGLRenderCmd._getGrayShaderProgram() : state === Scale9Sprite.state.DISTORTION && (this._shaderProgram = cc.Scale9Sprite.WebGLRenderCmd._getDistortionProgram());
    };
    Scale9Sprite.WebGLRenderCmd._grayShaderProgram = null;
    Scale9Sprite.WebGLRenderCmd._getGrayShaderProgram = function() {
      var grayShader = Scale9Sprite.WebGLRenderCmd._grayShaderProgram;
      if (grayShader) return grayShader;
      grayShader = new cc.GLProgram();
      grayShader.initWithVertexShaderByteArray(cc.PresetShaders.SPRITE_POSITION_TEXTURE_COLOR_VERT, cc.Scale9Sprite.WebGLRenderCmd._grayShaderFragment);
      grayShader.addAttribute(cc.macro.ATTRIBUTE_NAME_POSITION, cc.macro.VERTEX_ATTRIB_POSITION);
      grayShader.addAttribute(cc.macro.ATTRIBUTE_NAME_COLOR, cc.macro.VERTEX_ATTRIB_COLOR);
      grayShader.addAttribute(cc.macro.ATTRIBUTE_NAME_TEX_COORD, cc.macro.VERTEX_ATTRIB_TEX_COORDS);
      grayShader.link();
      grayShader.updateUniforms();
      Scale9Sprite.WebGLRenderCmd._grayShaderProgram = grayShader;
      return grayShader;
    };
    Scale9Sprite.WebGLRenderCmd._grayShaderFragment = "precision lowp float;\nvarying vec4 v_fragmentColor;\nvarying vec2 v_texCoord;\nvoid main()\n{\nvec4 c = v_fragmentColor * texture2D(CC_Texture0, v_texCoord);\nfloat gray = 0.2126*c.r + 0.7152*c.g + 0.0722*c.b;\ngl_FragColor = vec4(gray, gray, gray, c.a);\n}";
    Scale9Sprite.WebGLRenderCmd._distortionProgram = null;
    Scale9Sprite.WebGLRenderCmd._getDistortionProgram = function() {
      var shader = Scale9Sprite.WebGLRenderCmd._distortionProgram;
      if (shader) return shader;
      shader = new cc.GLProgram();
      shader.initWithVertexShaderByteArray(cc.PresetShaders.SPRITE_POSITION_TEXTURE_COLOR_VERT, distortionSpriteShader.fShader);
      shader.addAttribute(cc.macro.ATTRIBUTE_NAME_POSITION, cc.macro.VERTEX_ATTRIB_POSITION);
      shader.addAttribute(cc.macro.ATTRIBUTE_NAME_COLOR, cc.macro.VERTEX_ATTRIB_COLOR);
      shader.addAttribute(cc.macro.ATTRIBUTE_NAME_TEX_COORD, cc.macro.VERTEX_ATTRIB_TEX_COORDS);
      shader.link();
      shader.updateUniforms();
      Scale9Sprite.WebGLRenderCmd._distortionProgram = shader;
      Scale9Sprite.WebGLRenderCmd._distortionOffset = shader.getUniformLocationForName("u_offset");
      Scale9Sprite.WebGLRenderCmd._distortionTiling = shader.getUniformLocationForName("u_offset_tiling");
      return shader;
    };
    var distortionSpriteShader = {
      shaderKey: "cc.Sprite.Shader.Distortion",
      fShader: "precision lowp float;\nvarying vec4 v_fragmentColor;\nvarying vec2 v_texCoord;\nuniform vec2 u_offset;\nuniform vec2 u_offset_tiling;\nconst float PI = 3.14159265359;\nvoid main()\n{\nfloat halfPI = 0.5 * PI;\nfloat maxFactor = sin(halfPI);\nvec2 uv = v_texCoord;\nvec2 xy = 2.0 * uv.xy - 1.0;\nfloat d = length(xy);\nif (d < (2.0-maxFactor)) {\nd = length(xy * maxFactor);\nfloat z = sqrt(1.0 - d * d);\nfloat r = atan(d, z) / PI;\nfloat phi = atan(xy.y, xy.x);\nuv.x = r * cos(phi) + 0.5;\nuv.y = r * sin(phi) + 0.5;\n} else {\ndiscard;\n}\nuv = uv * u_offset_tiling + u_offset;\nuv = fract(uv);\ngl_FragColor = v_fragmentColor * texture2D(CC_Texture0, uv);\n}"
    };
  }), {} ],
  126: [ (function(require, module, exports) {
    cc.SpriteBatchNode = _ccsg.Node.extend({
      _blendFunc: null,
      _texture: null,
      _className: "SpriteBatchNode",
      ctor: function(texture) {
        _ccsg.Node.prototype.ctor.call(this);
        this._blendFunc = new cc.BlendFunc(cc.macro.BLEND_SRC, cc.macro.BLEND_DST);
        texture && this.initWithTexture(texture);
      },
      initWithFile: function(fileImage) {
        var texture2D = cc.textureCache.getTextureForKey(fileImage) || cc.textureCache.addImage(fileImage);
        return this.initWithTexture(texture2D);
      },
      removeChildAtIndex: function(index, doCleanup) {
        this.removeChild(this._children[index], doCleanup);
      },
      setBlendFunc: function(src, dst) {
        this._blendFunc = void 0 === dst ? src : {
          src: src,
          dst: dst
        };
      },
      getBlendFunc: function() {
        return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst);
      },
      updateQuadFromSprite: function(sprite, index) {
        cc.assertID(sprite, 2623);
        if (!(sprite instanceof _ccsg.Sprite)) {
          cc.log(2616);
          return;
        }
        sprite.dirty = true;
        sprite._renderCmd.transform(this._renderCmd, true);
      },
      appendChild: function(sprite) {
        this.sortAllChildren();
        var lastLocalZOrder = this._children[this._children.length - 1]._localZOrder;
        this.addChild(sprite, lastLocalZOrder + 1);
      },
      initWithTexture: function(tex) {
        this.setTexture(tex);
        return true;
      },
      getTexture: function() {
        return this._texture;
      },
      setTexture: function(texture) {
        this._texture = texture;
        if (texture.loaded) {
          var children = this._children, i, len = children.length;
          for (i = 0; i < len; ++i) children[i].setTexture(texture);
        } else texture.addEventListener("load", (function() {
          var children = this._children, i, len = children.length;
          for (i = 0; i < len; ++i) children[i].setTexture(texture);
        }), this);
      },
      setShaderProgram: function(newShaderProgram) {
        this._renderCmd.setShaderProgram(newShaderProgram);
        var children = this._children, i, len = children.length;
        for (i = 0; i < len; ++i) children[i].setShaderProgram(newShaderProgram);
      },
      addChild: function(child, zOrder, tag) {
        cc.assertID(void 0 !== child, 2614);
        if (!this._isValidChild(child)) return;
        zOrder = void 0 === zOrder ? child.zIndex : zOrder;
        tag = void 0 === tag ? child.tag : tag;
        _ccsg.Node.prototype.addChild.call(this, child, zOrder, tag);
        this._renderCmd._shaderProgram && (child.shaderProgram = this._renderCmd._shaderProgram);
      },
      _isValidChild: function(child) {
        if (!(child instanceof _ccsg.Sprite)) {
          cc.logID(2618);
          return false;
        }
        if (child.texture !== this._texture) {
          cc.logID(2619);
          return false;
        }
        return true;
      }
    });
    var _p = cc.SpriteBatchNode.prototype;
    cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
    cc.defineGetterSetter(_p, "shaderProgram", _p.getShaderProgram, _p.setShaderProgram);
  }), {} ],
  127: [ (function(require, module, exports) {
    var EventTarget = require("../event/event-target");
    var SpriteFrame = cc.Class({
      name: "cc.SpriteFrame",
      extends: require("../assets/CCAsset"),
      mixins: [ EventTarget ],
      properties: {
        _textureSetter: {
          set: function(texture) {
            if (texture) {
              false;
              this._texture !== texture && this._refreshTexture(texture);
              this._textureFilename = texture.url;
            }
          }
        }
      },
      ctor: function() {
        var filename = arguments[0];
        var rect = arguments[1];
        var rotated = arguments[2];
        var offset = arguments[3];
        var originalSize = arguments[4];
        this._rect = null;
        this._offset = null;
        this._originalSize = null;
        this._rotated = false;
        this.insetTop = 0;
        this.insetBottom = 0;
        this.insetLeft = 0;
        this.insetRight = 0;
        this._texture = null;
        this._textureFilename = "";
        false;
        void 0 !== filename && this.initWithTexture(filename, rect, rotated, offset, originalSize);
      },
      textureLoaded: function() {
        return this._texture && this._texture.loaded;
      },
      addLoadedEventListener: function(callback, target) {
        this.once("load", callback, target);
      },
      isRotated: function() {
        return this._rotated;
      },
      setRotated: function(bRotated) {
        this._rotated = bRotated;
      },
      getRect: function() {
        return cc.rect(this._rect);
      },
      setRect: function(rect) {
        this._rect = rect;
      },
      getOriginalSize: function() {
        return cc.size(this._originalSize);
      },
      setOriginalSize: function(size) {
        if (this._originalSize) {
          this._originalSize.width = size.width;
          this._originalSize.height = size.height;
        } else this._originalSize = cc.size(size);
      },
      getTexture: function() {
        return this._texture;
      },
      _textureLoadedCallback: function() {
        var self = this;
        var texture = this._texture;
        if (!texture) return;
        var w = texture.width, h = texture.height;
        if (self._rotated && cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
          self._texture = _ccsg.Sprite.CanvasRenderCmd._createRotatedTexture(texture, self.getRect());
          self._rotated = false;
          w = self._texture.width;
          h = self._texture.height;
          self.setRect(cc.rect(0, 0, w, h));
        }
        self._rect ? self._checkRect(self._texture) : self.setRect(cc.rect(0, 0, w, h));
        self._originalSize || self.setOriginalSize(cc.size(w, h));
        self._offset || self.setOffset(cc.v2(0, 0));
        self.emit("load");
      },
      _refreshTexture: function(texture) {
        this._texture = texture;
        texture.loaded ? this._textureLoadedCallback() : texture.once("load", this._textureLoadedCallback, this);
      },
      getOffset: function() {
        return cc.v2(this._offset);
      },
      setOffset: function(offsets) {
        this._offset = cc.v2(offsets);
      },
      clone: function() {
        return new SpriteFrame(this._texture || this._textureFilename, this._rect, this._rotated, this._offset, this._originalSize);
      },
      setTexture: function(textureOrTextureFile, rect, rotated, offset, originalSize) {
        rect ? this.setRect(rect) : this._rect = null;
        offset ? this.setOffset(offset) : this._offset = null;
        originalSize ? this.setOriginalSize(originalSize) : this._originalSize = null;
        this._rotated = rotated || false;
        var texture = textureOrTextureFile;
        "string" === typeof texture && texture && (texture = cc.textureCache.addImage(texture));
        texture instanceof cc.Texture2D && this._texture !== texture && this._refreshTexture(texture);
        return true;
      },
      ensureLoadTexture: function() {
        if (this._texture) {
          if (!this._texture.loaded) {
            this._refreshTexture(this._texture);
            this._texture.load();
          }
        } else if (this._textureFilename) {
          var texture = cc.textureCache.addImage(this._textureFilename);
          this._refreshTexture(texture);
        }
      },
      clearTexture: function() {
        this._texture = null;
      },
      _checkRect: function(texture) {
        var rect = this._rect;
        var maxX = rect.x, maxY = rect.y;
        if (this._rotated) {
          maxX += rect.height;
          maxY += rect.width;
        } else {
          maxX += rect.width;
          maxY += rect.height;
        }
        maxX > texture.width && cc.errorID(3300, texture.url + "/" + this.name, maxX, texture.width);
        maxY > texture.height && cc.errorID(3400, texture.url + "/" + this.name, maxY, texture.height);
      },
      _serialize: false,
      _deserialize: function(data, handle) {
        var rect = data.rect;
        rect && this.setRect(new cc.Rect(rect[0], rect[1], rect[2], rect[3]));
        data.offset && this.setOffset(new cc.Vec2(data.offset[0], data.offset[1]));
        data.originalSize && this.setOriginalSize(new cc.Size(data.originalSize[0], data.originalSize[1]));
        this._rotated = 1 === data.rotated;
        this._name = data.name;
        var capInsets = data.capInsets;
        if (capInsets) {
          this.insetLeft = capInsets[0];
          this.insetTop = capInsets[1];
          this.insetRight = capInsets[2];
          this.insetBottom = capInsets[3];
        }
        false;
        var textureUuid = data.texture;
        textureUuid && handle.result.push(this, "_textureSetter", textureUuid);
      }
    });
    var proto = SpriteFrame.prototype;
    proto.copyWithZone = proto.clone;
    proto.copy = proto.clone;
    proto.initWithTexture = proto.setTexture;
    true;
    cc.SpriteFrame = SpriteFrame;
    module.exports = SpriteFrame;
  }), {
    "../assets/CCAsset": 18,
    "../event/event-target": 60
  } ],
  128: [ (function(require, module, exports) {
    var EventTarget = require("../event/event-target");
    var sys = require("../platform/CCSys");
    var JS = require("../platform/js");
    var misc = require("../utils/misc");
    var game = require("../CCGame");
    require("../platform/CCClass");
    var GL_ALPHA = 6406;
    var GL_RGB = 6407;
    var GL_RGBA = 6408;
    var GL_LUMINANCE = 6409;
    var GL_LUMINANCE_ALPHA = 6410;
    var GL_UNSIGNED_BYTE = 5121;
    var GL_UNSIGNED_SHORT = 5123;
    var GL_UNSIGNED_INT = 5125;
    var GL_FLOAT = 5126;
    var GL_UNSIGNED_SHORT_5_6_5 = 33635;
    var GL_UNSIGNED_SHORT_4_4_4_4 = 32819;
    var GL_UNSIGNED_SHORT_5_5_5_1 = 32820;
    var GL_NEAREST = 9728;
    var GL_LINEAR = 9729;
    var GL_REPEAT = 10497;
    var GL_CLAMP_TO_EDGE = 33071;
    var GL_MIRRORED_REPEAT = 33648;
    var _textureFmtGL = [ {
      format: GL_RGB,
      internalFormat: GL_RGB,
      pixelType: GL_UNSIGNED_SHORT_5_6_5
    }, {
      format: GL_RGBA,
      internalFormat: GL_RGBA,
      pixelType: GL_UNSIGNED_SHORT_5_5_5_1
    }, {
      format: GL_RGBA,
      internalFormat: GL_RGBA,
      pixelType: GL_UNSIGNED_SHORT_4_4_4_4
    }, {
      format: GL_RGB,
      internalFormat: GL_RGB,
      pixelType: GL_UNSIGNED_BYTE
    }, {
      format: GL_RGBA,
      internalFormat: GL_RGBA,
      pixelType: GL_UNSIGNED_BYTE
    }, {
      format: GL_ALPHA,
      internalFormat: GL_ALPHA,
      pixelType: GL_UNSIGNED_BYTE
    }, {
      format: GL_LUMINANCE,
      internalFormat: GL_LUMINANCE,
      pixelType: GL_UNSIGNED_BYTE
    }, {
      format: GL_LUMINANCE_ALPHA,
      internalFormat: GL_LUMINANCE_ALPHA,
      pixelType: GL_UNSIGNED_BYTE
    } ];
    var PixelFormat = cc.Enum({
      RGB565: 0,
      RGB5A1: 1,
      RGBA4444: 2,
      RGB888: 3,
      RGBA8888: 4,
      A8: 5,
      I8: 6,
      AI8: 7
    });
    var WrapMode = cc.Enum({
      REPEAT: GL_REPEAT,
      CLAMP_TO_EDGE: GL_CLAMP_TO_EDGE,
      MIRRORED_REPEAT: GL_MIRRORED_REPEAT
    });
    var Filter = cc.Enum({
      LINEAR: GL_LINEAR,
      NEAREST: GL_NEAREST
    });
    var Texture2D = cc.Class({
      name: "cc.Texture2D",
      extends: require("../assets/CCAsset"),
      mixins: [ EventTarget ],
      ctor: function(gl) {
        this.url = "";
        this.loaded = false;
        this.width = 0;
        this.height = 0;
        this._image = null;
        if (cc._renderType === game.RENDER_TYPE_CANVAS) {
          this._pattern = "";
          this._grayElementObj = null;
          this._backupElement = null;
          this._isGray = false;
        } else if (cc._renderType === game.RENDER_TYPE_WEBGL) {
          this._gl = gl || cc._renderContext;
          this._glID = null;
        }
      },
      properties: {
        _nativeAsset: {
          get: function() {
            return this._image;
          },
          set: function(image) {
            this.initWithElement(image);
            this.handleLoadedTexture();
          },
          override: true
        },
        _hasMipmap: false,
        _format: PixelFormat.RGBA8888,
        _compressed: false,
        _premultiplyAlpha: false,
        _minFilter: Filter.LINEAR,
        _magFilter: Filter.LINEAR,
        _wrapS: WrapMode.CLAMP_TO_EDGE,
        _wrapT: WrapMode.CLAMP_TO_EDGE
      },
      statics: {
        WrapMode: WrapMode,
        PixelFormat: PixelFormat,
        Filter: Filter,
        extnames: [ ".png", ".jpg", ".jpeg", ".bmp", ".webp" ]
      },
      update: function(options) {},
      toString: function() {
        return this.url || "";
      },
      getPixelWidth: function() {
        return this.width;
      },
      getPixelHeight: function() {
        return this.height;
      },
      getContentSize: function() {
        return cc.size(this.width, this.height);
      },
      getContentSizeInPixels: function() {
        return this.getContentSize();
      },
      initWithElement: function(element) {
        if (!element) return;
        this._image = element;
        this.width = element.width;
        this.height = element.height;
        this.loaded = true;
      },
      initWithData: function(data, pixelFormat, pixelsWidth, pixelsHeight, contentSize) {
        return false;
      },
      initWithImage: function(uiImage) {
        return false;
      },
      getHtmlElementObj: function() {
        return this._image;
      },
      load: function(callback) {
        if (this.loaded) {
          callback && callback();
          return;
        }
        if (!this.url) {
          callback && callback();
          return;
        }
        var self = this;
        cc.loader.load({
          url: this.url,
          _owner: this
        }, (function(err, image) {
          if (image) {
            if (true, image instanceof cc.Texture2D) return cc.error("internal error: loader handle pipe must be skipped");
            self.loaded || (self._nativeAsset = image);
          }
          callback && callback(err);
        }));
      },
      isLoaded: function() {
        true;
        cc.warn("Texture2D.isLoaded is deprecated, use `loaded` property instead please.");
        return this.loaded;
      },
      handleLoadedTexture: function() {
        if (!this._image || !this._image.width || !this._image.height) return;
        var locElement = this._image;
        this.width = locElement.width;
        this.height = locElement.height;
        this.loaded = true;
        this.emit("load");
      },
      description: function() {
        return "<cc.Texture2D | Name = " + this.url + " | Dimensions = " + this.width + " x " + this.height + ">";
      },
      _releaseTexture: function() {
        if (this._gl && null !== this._glID) {
          this._gl.deleteTexture(this._glID);
          this._glID = null;
        }
      },
      destroy: function() {
        this._releaseTexture();
        cc.textureCache.removeTextureForKey(this.url);
        this._super();
      },
      getPixelFormat: function() {
        return this._format;
      },
      hasPremultipliedAlpha: function() {
        return this._premultiplyAlpha || false;
      },
      hasMipmaps: function() {
        return this._hasMipmap || false;
      },
      setTexParameters: function(texParams, magFilter, wrapS, wrapT) {
        void 0 !== magFilter && (texParams = {
          minFilter: texParams,
          magFilter: magFilter,
          wrapS: wrapS,
          wrapT: wrapT
        });
        if (texParams.wrapS === WrapMode.REPEAT && texParams.wrapT === WrapMode.REPEAT) {
          this._pattern = "repeat";
          return;
        }
        if (texParams.wrapS === WrapMode.REPEAT) {
          this._pattern = "repeat-x";
          return;
        }
        if (texParams.wrapT === WrapMode.REPEAT) {
          this._pattern = "repeat-y";
          return;
        }
        this._pattern = "";
      },
      setAntiAliasTexParameters: function() {},
      setAliasTexParameters: function() {},
      _serialize: (false, false) && function() {
        var extId = "";
        if (this._native) {
          var ext = cc.path.extname(this._native);
          if (ext) {
            extId = Texture2D.extnames.indexOf(ext);
            extId < 0 && (extId = ext);
          }
        }
        return "" + extId;
      },
      _deserialize: function(data, handle) {
        var fields = data.split(",");
        var extIdStr = fields[0];
        if (extIdStr) {
          var CHAR_CODE_0 = 48;
          var extId = extIdStr.charCodeAt(0) - CHAR_CODE_0;
          var ext = Texture2D.extnames[extId];
          this._setRawAsset(ext || extIdStr);
          var loadingItem = handle.customEnv;
          var uuid = loadingItem && loadingItem.uuid;
          if (uuid) {
            this._uuid = uuid;
            var url = this.nativeUrl;
            this.url = url;
            cc.textureCache.cacheImage(url, this);
          }
        }
      }
    });
    var _p = Texture2D.prototype;
    JS.get(_p, "pixelFormat", _p.getPixelFormat);
    JS.get(_p, "pixelWidth", _p.getPixelWidth);
    JS.get(_p, "pixelHeight", _p.getPixelHeight);
    true, game.once(game.EVENT_RENDERER_INITED, (function() {
      if (cc._renderType === game.RENDER_TYPE_CANVAS) (function() {
        function renderToCache(image, cache) {
          var w = image.width;
          var h = image.height;
          cache[0].width = w;
          cache[0].height = h;
          cache[1].width = w;
          cache[1].height = h;
          cache[2].width = w;
          cache[2].height = h;
          cache[3].width = w;
          cache[3].height = h;
          var cacheCtx = cache[3].getContext("2d");
          cacheCtx.drawImage(image, 0, 0);
          var pixels = cacheCtx.getImageData(0, 0, w, h).data;
          var ctx;
          for (var rgbI = 0; rgbI < 4; rgbI++) {
            ctx = cache[rgbI].getContext("2d");
            var to = ctx.getImageData(0, 0, w, h);
            var data = to.data;
            for (var i = 0; i < pixels.length; i += 4) {
              data[i] = 0 === rgbI ? pixels[i] : 0;
              data[i + 1] = 1 === rgbI ? pixels[i + 1] : 0;
              data[i + 2] = 2 === rgbI ? pixels[i + 2] : 0;
              data[i + 3] = pixels[i + 3];
            }
            ctx.putImageData(to, 0, 0);
          }
          image.onload = null;
        }
        function generateGrayTexture(texture, rect, renderCanvas) {
          if (null === texture) return null;
          renderCanvas = renderCanvas || document.createElement("canvas");
          rect = rect || cc.rect(0, 0, texture.width, texture.height);
          renderCanvas.width = rect.width;
          renderCanvas.height = rect.height;
          var context = renderCanvas.getContext("2d");
          context.drawImage(texture, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
          var imgData = context.getImageData(0, 0, rect.width, rect.height);
          var data = imgData.data;
          for (var i = 0, len = data.length; i < len; i += 4) data[i] = data[i + 1] = data[i + 2] = .34 * data[i] + .5 * data[i + 1] + .16 * data[i + 2];
          context.putImageData(imgData, 0, 0);
          return renderCanvas;
        }
        _p._generateTextureCacheForColor = function() {
          if (this.channelCache) return this.channelCache;
          var textureCache = [ document.createElement("canvas"), document.createElement("canvas"), document.createElement("canvas"), document.createElement("canvas") ];
          renderToCache(this._image, textureCache);
          return this.channelCache = textureCache;
        };
        _p._switchToGray = function(toGray) {
          if (!this.loaded || this._isGray === toGray) return;
          this._isGray = toGray;
          if (this._isGray) {
            this._backupElement = this._image;
            this._grayElementObj || (this._grayElementObj = generateGrayTexture(this._image));
            this._image = this._grayElementObj;
          } else null !== this._backupElement && (this._image = this._backupElement);
        };
        _p._generateGrayTexture = function() {
          if (!this.loaded) return null;
          var grayElement = generateGrayTexture(this._image);
          var newTexture = new Texture2D();
          newTexture.initWithElement(grayElement);
          newTexture.handleLoadedTexture();
          return newTexture;
        };
        _p._generateColorTexture = sys._supportCanvasNewBlendModes ? function(r, g, b, rect, canvas) {
          var onlyCanvas = false;
          canvas ? onlyCanvas = true : canvas = document.createElement("canvas");
          var textureImage = this._image;
          rect || (rect = cc.rect(0, 0, textureImage.width, textureImage.height));
          canvas.width = rect.width;
          canvas.height = rect.height;
          if (rect.width && rect.height) {
            var context = canvas.getContext("2d");
            context.globalCompositeOperation = "source-over";
            context.fillStyle = "rgb(" + (0 | r) + "," + (0 | g) + "," + (0 | b) + ")";
            context.fillRect(0, 0, rect.width, rect.height);
            context.globalCompositeOperation = "multiply";
            context.drawImage(textureImage, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
            context.globalCompositeOperation = "destination-atop";
            context.drawImage(textureImage, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
          }
          if (onlyCanvas) return canvas;
          var newTexture = new Texture2D();
          newTexture.initWithElement(canvas);
          newTexture.handleLoadedTexture();
          return newTexture;
        } : function(r, g, b, rect, canvas) {
          var onlyCanvas = false;
          canvas ? onlyCanvas = true : canvas = document.createElement("canvas");
          var textureImage = this._image;
          rect || (rect = cc.rect(0, 0, textureImage.width, textureImage.height));
          canvas.width = rect.width;
          canvas.height = rect.height;
          if (rect.width && rect.height) {
            var context = canvas.getContext("2d");
            context.drawImage(textureImage, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
            var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            r /= 255;
            g /= 255;
            b /= 255;
            for (var i = 0; i < data.length; i += 4) {
              data[i] = data[i] * r;
              data[i + 1] = data[i + 1] * g;
              data[i + 2] = data[i + 2] * b;
            }
            context.putImageData(imageData, 0, 0);
          }
          if (onlyCanvas) return canvas;
          var newTexture = new Texture2D();
          newTexture.initWithElement(canvas);
          newTexture.handleLoadedTexture();
          return newTexture;
        };
      })(); else if (cc._renderType === game.RENDER_TYPE_WEBGL) {
        var _sharedOpts;
        (function() {
          function _glTextureFmt(pixelFormat) {
            var glFmt = _textureFmtGL[pixelFormat];
            cc.assertID(glFmt, 3113);
            return glFmt;
          }
          function _isPow2(v) {
            return !(v & v - 1) && !!v;
          }
          _sharedOpts = {
            width: void 0,
            height: void 0,
            minFilter: void 0,
            magFilter: void 0,
            wrapS: void 0,
            wrapT: void 0,
            format: void 0,
            mipmap: void 0,
            image: void 0,
            premultiplyAlpha: void 0
          };
          function _getSharedOptions() {
            for (var key in _sharedOpts) _sharedOpts[key] = void 0;
            return _sharedOpts;
          }
          _p.update = function(options) {
            var genMipmap = this._hasMipmap;
            var gl = this._gl;
            var updateImage = false;
            if (options) {
              void 0 !== options.width && (this.width = options.width);
              void 0 !== options.height && (this.height = options.height);
              void 0 !== options.minFilter && (this._minFilter = options.minFilter);
              void 0 !== options.magFilter && (this._magFilter = options.magFilter);
              void 0 !== options.wrapS && (this._wrapS = options.wrapS);
              void 0 !== options.wrapT && (this._wrapT = options.wrapT);
              if (void 0 !== options.format) {
                this._format = options.format;
                updateImage = true;
              }
              if (void 0 !== options.premultiplyAlpha) {
                this._premultiplyAlpha = options.premultiplyAlpha;
                updateImage = true;
              }
              if (void 0 !== options.image) {
                this._image = options.image;
                updateImage = true;
              }
              void 0 !== options.mipmap && (genMipmap = this._hasMipmap = options.mipmap);
            }
            if (this._image) {
              if (updateImage) {
                this._releaseTexture();
                this._glID = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this._glID);
                this._setImage(this._image, this.width, this.height, _glTextureFmt(this._format), this._premultiplyAlpha);
              } else {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this._glID);
              }
              this._setTexInfo();
              if (genMipmap) {
                cc.assertID(_isPow2(this.width) && _isPow2(this.height), 3117);
                gl.hint(gl.GENERATE_MIPMAP_HINT, gl.NICEST);
                gl.generateMipmap(gl.TEXTURE_2D);
              }
              gl.bindTexture(gl.TEXTURE_2D, null);
            }
          };
          _p._setImage = function(img, width, height, glFmt, premultiplyAlpha) {
            var gl = this._gl;
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
            sys.platform === sys.QQ_PLAY || img instanceof HTMLCanvasElement && !(img instanceof Uint8Array) || img instanceof HTMLImageElement || img instanceof HTMLVideoElement ? gl.texImage2D(gl.TEXTURE_2D, 0, glFmt.internalFormat, glFmt.format, glFmt.pixelType, img) : gl.texImage2D(gl.TEXTURE_2D, 0, glFmt.internalFormat, width, height, 0, glFmt.format, glFmt.pixelType, img);
          };
          _p._setTexInfo = function() {
            var gl = this._gl;
            var pot = _isPow2(this.width) && _isPow2(this.height);
            if (!pot && (this._wrapS !== WrapMode.CLAMP_TO_EDGE || this._wrapT !== WrapMode.CLAMP_TO_EDGE)) {
              cc.warnID(3116);
              this._wrapS = WrapMode.CLAMP_TO_EDGE;
              this._wrapT = WrapMode.CLAMP_TO_EDGE;
            }
            this._minFilter === Filter.LINEAR ? gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._hasMipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR) : gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._hasMipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._magFilter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT);
          };
          _p.initWithData = function(data, pixelFormat, pixelsWidth, pixelsHeight, contentSize) {
            contentSize && cc.warnID(3118);
            var opts = _getSharedOptions();
            opts.image = data;
            opts.format = pixelFormat;
            opts.width = pixelsWidth;
            opts.height = pixelsHeight;
            this.update(opts);
            this.width = pixelsWidth;
            this.height = pixelsHeight;
            this.loaded = true;
            this.emit("load");
            return true;
          };
          _p.initWithElement = function(element) {
            if (!element || 0 === element.width || 0 === element.height) return;
            this._image = element;
            return true;
          };
          _p.handleLoadedTexture = function() {
            if (!this._image || !this._image.width || !this._image.height) return;
            var opts = _getSharedOptions();
            opts.image = this._image;
            opts.format = PixelFormat.RGBA8888;
            opts.width = this._image.width;
            opts.height = this._image.height;
            var filter = cc.view._antiAliasEnabled ? Filter.LINEAR : Filter.NEAREST;
            opts.minFilter = opts.magFilter = filter;
            this.update(opts);
            this.loaded = true;
            this.emit("load");
          };
          _p.setTexParameters = function(texParams, magFilter, wrapS, wrapT) {
            void 0 !== magFilter && (texParams = {
              minFilter: texParams,
              magFilter: magFilter,
              wrapS: wrapS,
              wrapT: wrapT
            });
            this.update(texParams);
          };
          _p.setAntiAliasTexParameters = function() {
            var opts = _getSharedOptions();
            opts.minFilter = Filter.LINEAR;
            opts.magFilter = Filter.LINEAR;
            this.update(opts);
          };
          _p.setAliasTexParameters = function() {
            var opts = _getSharedOptions();
            opts.minFilter = Filter.NEAREST;
            opts.magFilter = Filter.NEAREST;
            this.update(opts);
          };
        })();
      }
    }));
    true;
    cc.Texture2D = Texture2D;
    module.exports = Texture2D;
  }), {
    "../CCGame": 14,
    "../assets/CCAsset": 18,
    "../event/event-target": 60,
    "../platform/CCClass": 89,
    "../platform/CCSys": 97,
    "../platform/js": 109,
    "../utils/misc": 137
  } ],
  129: [ (function(require, module, exports) {
    var Texture2D = require("./CCTexture2D");
    var textureCache = {
      _textures: {},
      _textureColorsCache: {},
      _textureKeySeq: 0 | 1e3 * Math.random(),
      handleLoadedTexture: null,
      description: function() {
        return "<TextureCache | Number of textures = " + this._textures.length + ">";
      },
      getTextureForKey: function(textureKeyName) {
        return this._textures[textureKeyName];
      },
      getKeyByTexture: function(texture) {
        for (var key in this._textures) if (this._textures[key] === texture) return key;
        return null;
      },
      _generalTextureKey: function(id) {
        return "_textureKey_" + id;
      },
      getTextureColors: function(texture) {
        var image = texture._image;
        var key = this.getKeyByTexture(image);
        key || (key = image instanceof HTMLImageElement ? image.src : this._generalTextureKey(texture.__instanceId));
        this._textureColorsCache[key] || (this._textureColorsCache[key] = texture._generateTextureCacheForColor());
        return this._textureColorsCache[key];
      },
      getAllTextures: function() {
        var texs = [];
        for (var key in this._textures) {
          var item = this._textures[key];
          texs.push(item);
        }
        return texs;
      },
      removeAllTextures: function() {
        var locTextures = this._textures;
        for (var selKey in locTextures) locTextures[selKey] && locTextures[selKey]._releaseTexture();
        this._textures = {};
      },
      removeTexture: function(texture) {
        if (!texture) return;
        var locTextures = this._textures;
        for (var selKey in locTextures) if (locTextures[selKey] === texture) {
          locTextures[selKey]._releaseTexture();
          delete locTextures[selKey];
        }
      },
      removeTextureForKey: function(textureKeyName) {
        (true, textureKeyName instanceof cc.Texture2D) && cc.warn("textureCache.removeTextureForKey(key) - The type of the key should be string, not Texture2D. You should call texture.destroy() if you already have the texture object.");
        if ("string" !== typeof textureKeyName) return;
        var texture = this._textures[textureKeyName];
        if (texture) {
          texture._releaseTexture();
          delete this._textures[textureKeyName];
        }
      },
      addImage: function(url, cb, target) {
        (true, url instanceof cc.Texture2D) && cc.warn("textureCache.addImage(url) - The type of the url should be string, not Texture2D. You don't need to call addImage if you already have the texture object.");
        cc.assertID(url, 3103);
        var locTexs = this._textures;
        var tex = locTexs[url];
        if (tex) tex.loaded ? cb && cb.call(target, tex) : tex.once("load", (function() {
          cb && cb.call(target, tex);
        }), target); else {
          tex = locTexs[url] = new Texture2D();
          tex.url = url;
          cc.loader.load(url, (function(err, texture) {
            if (err) return cb && cb.call(target, err || new Error("Unknown error"));
            textureCache.handleLoadedTexture(url);
            cb && cb.call(target, tex);
          }));
        }
        return tex;
      },
      addImageAsync: null,
      cacheImage: function(path, texture) {
        cc.assertID(path, 3009);
        if (texture instanceof Texture2D) {
          this._textures[path] = texture;
          return;
        }
        var texture2d = new Texture2D();
        texture2d.initWithElement(texture);
        texture2d.handleLoadedTexture();
        this._textures[path] = texture2d;
      },
      dumpCachedTextureInfo: function() {
        var count = 0;
        var totalBytes = 0, locTextures = this._textures;
        for (var key in locTextures) {
          var selTexture = locTextures[key];
          count++;
          selTexture.getHtmlElementObj() instanceof HTMLImageElement ? cc.logID(3005, key, selTexture.getHtmlElementObj().src, selTexture.getPixelWidth(), selTexture.getPixelHeight()) : cc.logID(3006, key, selTexture.getPixelWidth(), selTexture.getPixelHeight());
          totalBytes += selTexture.getPixelWidth() * selTexture.getPixelHeight() * 4;
        }
        var locTextureColorsCache = this._textureColorsCache;
        for (key in locTextureColorsCache) {
          var selCanvasColorsArr = locTextureColorsCache[key];
          for (var selCanvasKey in selCanvasColorsArr) {
            var selCanvas = selCanvasColorsArr[selCanvasKey];
            count++;
            cc.logID(3006, key, selCanvas.width, selCanvas.height);
            totalBytes += selCanvas.width * selCanvas.height * 4;
          }
        }
        cc.logID(3007, count, totalBytes / 1024, (totalBytes / 1048576).toFixed(2));
      },
      _clear: function() {
        this._textures = {};
        this._textureColorsCache = {};
        this._textureKeySeq = 0 | 1e3 * Math.random();
      },
      handleLoadedTexture: function(url) {
        var locTexs = this._textures;
        var tex = locTexs[url];
        if (!tex) {
          cc.assertID(url, 3009);
          tex = locTexs[url] = new Texture2D();
          tex.url = url;
        }
        tex.handleLoadedTexture();
      }
    };
    textureCache.addImageAsync = textureCache.addImage;
    cc.textureCache = module.exports = textureCache;
  }), {
    "./CCTexture2D": 128
  } ],
  130: [ (function(require, module, exports) {
    require("./CCTexture2D");
    require("./CCTextureCache");
  }), {
    "./CCTexture2D": 128,
    "./CCTextureCache": 129
  } ],
  131: [ (function(require, module, exports) {
    require("../platform/CCSys");
    var EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/;
    var DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/;
    var NORMALIZE_RE = /[^\.\/]+\/\.\.\//;
    cc.path = {
      join: function() {
        var l = arguments.length;
        var result = "";
        for (var i = 0; i < l; i++) result = (result + ("" === result ? "" : "/") + arguments[i]).replace(/(\/|\\\\)$/, "");
        return result;
      },
      extname: function(pathStr) {
        var temp = EXTNAME_RE.exec(pathStr);
        return temp ? temp[1] : "";
      },
      mainFileName: function(fileName) {
        if (fileName) {
          var idx = fileName.lastIndexOf(".");
          if (-1 !== idx) return fileName.substring(0, idx);
        }
        return fileName;
      },
      basename: function(pathStr, extname) {
        var index = pathStr.indexOf("?");
        index > 0 && (pathStr = pathStr.substring(0, index));
        var reg = /(\/|\\\\)([^(\/|\\\\)]+)$/g;
        var result = reg.exec(pathStr.replace(/(\/|\\\\)$/, ""));
        if (!result) return null;
        var baseName = result[2];
        if (extname && pathStr.substring(pathStr.length - extname.length).toLowerCase() === extname.toLowerCase()) return baseName.substring(0, baseName.length - extname.length);
        return baseName;
      },
      dirname: function(pathStr) {
        var temp = DIRNAME_RE.exec(pathStr);
        return temp ? temp[2] : "";
      },
      changeExtname: function(pathStr, extname) {
        extname = extname || "";
        var index = pathStr.indexOf("?");
        var tempStr = "";
        if (index > 0) {
          tempStr = pathStr.substring(index);
          pathStr = pathStr.substring(0, index);
        }
        index = pathStr.lastIndexOf(".");
        if (index < 0) return pathStr + extname + tempStr;
        return pathStr.substring(0, index) + extname + tempStr;
      },
      changeBasename: function(pathStr, basename, isSameExt) {
        if (0 === basename.indexOf(".")) return this.changeExtname(pathStr, basename);
        var index = pathStr.indexOf("?");
        var tempStr = "";
        var ext = isSameExt ? this.extname(pathStr) : "";
        if (index > 0) {
          tempStr = pathStr.substring(index);
          pathStr = pathStr.substring(0, index);
        }
        index = pathStr.lastIndexOf("/");
        index = index <= 0 ? 0 : index + 1;
        return pathStr.substring(0, index) + basename + ext + tempStr;
      },
      _normalize: function(url) {
        var oldUrl = url = String(url);
        do {
          oldUrl = url;
          url = url.replace(NORMALIZE_RE, "");
        } while (oldUrl.length !== url.length);
        return url;
      },
      sep: cc.sys.os === cc.sys.OS_WINDOWS ? "\\" : "/",
      stripSep: function(path) {
        return path.replace(/[\/\\]$/, "");
      }
    };
    module.exports = cc.path;
  }), {
    "../platform/CCSys": 97
  } ],
  132: [ (function(require, module, exports) {
    var PStats = require("../../../external/pstats/pstats");
    var macro = require("../platform/CCMacro");
    var _fps = document.createElement("div");
    _fps.id = "fps";
    var stats = null;
    var _showFPS = false;
    function beforeUpdate() {
      stats("frame").start();
      stats("logic").start();
    }
    function afterVisit() {
      cc.director.isPaused() ? stats("frame").start() : stats("logic").end();
      stats("render").start();
    }
    function afterDraw() {
      stats("render").end();
      stats("draws").value = cc.g_NumberOfDraws;
      stats("frame").end();
      stats("fps").frame();
      stats().tick();
    }
    cc.profiler = module.exports = {
      isShowingStats: function() {
        return _showFPS;
      },
      hideStats: function() {
        if (_showFPS) {
          _fps.parentElement === document.body && document.body.removeChild(_fps);
          cc.director.off(cc.Director.EVENT_BEFORE_UPDATE, beforeUpdate);
          cc.director.off(cc.Director.EVENT_AFTER_VISIT, afterVisit);
          cc.director.off(cc.Director.EVENT_AFTER_DRAW, afterDraw);
          _showFPS = false;
        }
      },
      showStats: function() {
        if (!_showFPS) {
          stats || (stats = PStats.new(_fps, {
            showGraph: false,
            values: {
              frame: {
                desc: "Frame time (ms)",
                min: 0,
                max: 50,
                average: 500
              },
              fps: {
                desc: "Framerate (FPS)",
                below: 30,
                average: 500
              },
              draws: {
                desc: "Draw call"
              },
              logic: {
                desc: "Game Logic (ms)",
                min: 0,
                max: 50,
                average: 500,
                color: "#080"
              },
              render: {
                desc: "Renderer (ms)",
                min: 0,
                max: 50,
                average: 500,
                color: "#f90"
              },
              mode: {
                desc: cc._renderType === cc.game.RENDER_TYPE_WEBGL ? "WebGL" : "Canvas",
                min: 1
              }
            },
            css: ".pstats {left: " + macro.DIRECTOR_STATS_POSITION.x + "px; bottom: " + macro.DIRECTOR_STATS_POSITION.y + "px;}"
          }));
          null === _fps.parentElement && document.body.appendChild(_fps);
          cc.director.on(cc.Director.EVENT_BEFORE_UPDATE, beforeUpdate);
          cc.director.on(cc.Director.EVENT_AFTER_VISIT, afterVisit);
          cc.director.on(cc.Director.EVENT_AFTER_DRAW, afterDraw);
          _showFPS = true;
        }
      }
    };
  }), {
    "../../../external/pstats/pstats": 177,
    "../platform/CCMacro": 94
  } ],
  133: [ (function(require, module, exports) {
    var PrefabHelper = require("./prefab-helper");
    var Flags = require("../platform/CCObject").Flags;
    var Misc = require("./misc");
    var IdGenerater = require("../platform/id-generater");
    var eventManager = require("../event-manager");
    var JS = cc.js;
    var Destroying = Flags.Destroying;
    var DontDestroy = Flags.DontDestroy;
    var Deactivating = Flags.Deactivating;
    var CHILD_ADDED = "child-added";
    var CHILD_REMOVED = "child-removed";
    var idGenerater = new IdGenerater("Node");
    function getConstructor(typeOrClassName) {
      if (!typeOrClassName) {
        cc.errorID(3804);
        return null;
      }
      if ("string" === typeof typeOrClassName) return JS.getClassByName(typeOrClassName);
      return typeOrClassName;
    }
    function findComponent(node, constructor) {
      if (constructor._sealed) for (var i = 0; i < node._components.length; ++i) {
        var comp = node._components[i];
        if (comp.constructor === constructor) return comp;
      } else for (var _i = 0; _i < node._components.length; ++_i) {
        var _comp = node._components[_i];
        if (_comp instanceof constructor) return _comp;
      }
      return null;
    }
    function findComponents(node, constructor, components) {
      if (constructor._sealed) for (var i = 0; i < node._components.length; ++i) {
        var comp = node._components[i];
        comp.constructor === constructor && components.push(comp);
      } else for (var _i2 = 0; _i2 < node._components.length; ++_i2) {
        var _comp2 = node._components[_i2];
        _comp2 instanceof constructor && components.push(_comp2);
      }
    }
    function findChildComponent(children, constructor) {
      for (var i = 0; i < children.length; ++i) {
        var node = children[i];
        var comp = findComponent(node, constructor);
        if (comp) return comp;
        if (node._children.length > 0) {
          comp = findChildComponent(node._children, constructor);
          if (comp) return comp;
        }
      }
      return null;
    }
    function findChildComponents(children, constructor, components) {
      for (var i = 0; i < children.length; ++i) {
        var node = children[i];
        findComponents(node, constructor, components);
        node._children.length > 0 && findChildComponents(node._children, constructor, components);
      }
    }
    var BaseNode = cc.Class({
      name: "cc._BaseNode",
      extends: cc.Object,
      mixins: [ cc.EventTarget ],
      properties: {
        _parent: null,
        _children: [],
        _tag: cc.macro.NODE_TAG_INVALID,
        _active: true,
        _components: [],
        _prefab: null,
        _persistNode: {
          get: function() {
            return (this._objFlags & DontDestroy) > 0;
          },
          set: function(value) {
            value ? this._objFlags |= DontDestroy : this._objFlags &= ~DontDestroy;
          }
        },
        name: {
          get: function() {
            return this._name;
          },
          set: function(value) {
            false;
            this._name = value;
          }
        },
        _id: {
          default: "",
          editorOnly: true
        },
        uuid: {
          get: function() {
            var id = this._id;
            id || (id = this._id = idGenerater.getNewId());
            return id;
          }
        },
        children: {
          get: function() {
            return this._children;
          }
        },
        childrenCount: {
          get: function() {
            return this._children.length;
          }
        },
        active: {
          get: function() {
            return this._active;
          },
          set: function(value) {
            value = !!value;
            if (this._active !== value) {
              this._active = value;
              var parent = this._parent;
              if (parent) {
                var couldActiveInScene = parent._activeInHierarchy;
                couldActiveInScene && cc.director._nodeActivator.activateNode(this, value);
              }
            }
          }
        },
        activeInHierarchy: {
          get: function() {
            return this._activeInHierarchy;
          }
        }
      },
      ctor: function(name) {
        this._name = "undefined" !== typeof name ? name : "New Node";
        this._activeInHierarchy = false;
        this.__instanceId = this._id || cc.ClassManager.getNewInstanceId();
        this.__eventTargets = [];
      },
      getTag: function() {
        return this._tag;
      },
      setTag: function(tag) {
        this._tag = tag;
      },
      getParent: function() {
        return this._parent;
      },
      setParent: function(value) {
        if (this._parent === value) return;
        false;
        var oldParent = this._parent;
        (true, oldParent) && oldParent._objFlags & Deactivating && cc.errorID(3821);
        this._parent = value || null;
        this._onSetParent(value);
        if (value) {
          (true, value._objFlags & Deactivating) && cc.errorID(3821);
          true;
          eventManager._setDirtyForNode(this);
          value._children.push(this);
          value.emit(CHILD_ADDED, this);
        }
        if (oldParent) {
          if (!(oldParent._objFlags & Destroying)) {
            var removeAt = oldParent._children.indexOf(this);
            false;
            oldParent._children.splice(removeAt, 1);
            oldParent.emit(CHILD_REMOVED, this);
            this._onHierarchyChanged(oldParent);
          }
        } else value && this._onHierarchyChanged(null);
      },
      init: function() {
        return true;
      },
      attr: function(attrs) {
        JS.mixin(this, attrs);
      },
      getChildByTag: function(aTag) {
        var children = this._children;
        if (null !== children) for (var i = 0; i < children.length; i++) {
          var node = children[i];
          if (node && node._tag === aTag) return node;
        }
        return null;
      },
      getChildByUuid: function(uuid) {
        if (!uuid) {
          cc.log("Invalid uuid");
          return null;
        }
        var locChildren = this._children;
        for (var i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._id === uuid) return locChildren[i];
        return null;
      },
      getChildByName: function(name) {
        if (!name) {
          cc.log("Invalid name");
          return null;
        }
        var locChildren = this._children;
        for (var i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._name === name) return locChildren[i];
        return null;
      },
      addChild: function(child) {
        false;
        cc.assertID(child, 1606);
        cc.assertID(null === child._parent, 1605);
        child.setParent(this);
      },
      insertChild: function(child, siblingIndex) {
        child.parent = this;
        child.setSiblingIndex(siblingIndex);
      },
      getSiblingIndex: function() {
        return this._parent ? this._parent._children.indexOf(this) : 0;
      },
      setSiblingIndex: function(index) {
        if (!this._parent) return;
        if (this._parent._objFlags & Deactivating) {
          cc.errorID(3821);
          return;
        }
        var siblings = this._parent._children;
        index = -1 !== index ? index : siblings.length - 1;
        var oldIndex = siblings.indexOf(this);
        if (index !== oldIndex) {
          siblings.splice(oldIndex, 1);
          index < siblings.length ? siblings.splice(index, 0, this) : siblings.push(this);
          this._onSiblingIndexChanged && this._onSiblingIndexChanged(index);
        }
      },
      cleanup: function() {},
      removeFromParent: function(cleanup) {
        if (this._parent) {
          void 0 === cleanup && (cleanup = true);
          this._parent.removeChild(this, cleanup);
        }
      },
      removeChild: function(child, cleanup) {
        if (this._children.indexOf(child) > -1) {
          (cleanup || void 0 === cleanup) && child.cleanup();
          child.parent = null;
        }
      },
      removeChildByTag: function(tag, cleanup) {
        tag === cc.macro.NODE_TAG_INVALID && cc.logID(1609);
        var child = this.getChildByTag(tag);
        child ? this.removeChild(child, cleanup) : cc.logID(1610, tag);
      },
      removeAllChildren: function(cleanup) {
        var children = this._children;
        void 0 === cleanup && (cleanup = true);
        for (var i = children.length - 1; i >= 0; i--) {
          var node = children[i];
          if (node) {
            cleanup && node.cleanup();
            node.parent = null;
          }
        }
        this._children.length = 0;
      },
      isChildOf: function(parent) {
        var child = this;
        do {
          if (child === parent) return true;
          child = child._parent;
        } while (child);
        return false;
      },
      getComponent: function(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName);
        if (constructor) return findComponent(this, constructor);
        return null;
      },
      getComponents: function(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName), components = [];
        constructor && findComponents(this, constructor, components);
        return components;
      },
      getComponentInChildren: function(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName);
        if (constructor) return findChildComponent(this._children, constructor);
        return null;
      },
      getComponentsInChildren: function(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName), components = [];
        if (constructor) {
          findComponents(this, constructor, components);
          findChildComponents(this._children, constructor, components);
        }
        return components;
      },
      _checkMultipleComp: false,
      addComponent: function(typeOrClassName) {
        false;
        var constructor;
        if ("string" === typeof typeOrClassName) {
          constructor = JS.getClassByName(typeOrClassName);
          if (!constructor) {
            cc.errorID(3807, typeOrClassName);
            cc._RFpeek() && cc.errorID(3808, typeOrClassName);
            return null;
          }
        } else {
          if (!typeOrClassName) {
            cc.errorID(3804);
            return null;
          }
          constructor = typeOrClassName;
        }
        if ("function" !== typeof constructor) {
          cc.errorID(3809);
          return null;
        }
        if (!cc.isChildClassOf(constructor, cc.Component)) {
          cc.errorID(3810);
          return null;
        }
        false;
        var ReqComp = constructor._requireComponent;
        if (ReqComp && !this.getComponent(ReqComp)) {
          var depended = this.addComponent(ReqComp);
          if (!depended) return null;
        }
        var component = new constructor();
        component.node = this;
        this._components.push(component);
        this._activeInHierarchy && cc.director._nodeActivator.activateComp(component);
        return component;
      },
      _addComponentAt: false,
      removeComponent: function(component) {
        if (!component) {
          cc.errorID(3813);
          return;
        }
        component instanceof cc.Component || (component = this.getComponent(component));
        component && component.destroy();
      },
      _getDependComponent: false,
      _removeComponent: function(component) {
        if (!component) {
          cc.errorID(3814);
          return;
        }
        if (!(this._objFlags & Destroying)) {
          var i = this._components.indexOf(component);
          -1 !== i ? this._components.splice(i, 1) : component.node !== this && cc.errorID(3815);
        }
      },
      _disableChildComps: function() {
        var i, len = this._components.length;
        for (i = 0; i < len; ++i) {
          var component = this._components[i];
          component._enabled && cc.director._compScheduler.disableComp(component);
        }
        for (i = 0, len = this._children.length; i < len; ++i) {
          var node = this._children[i];
          node._active && node._disableChildComps();
        }
      },
      destroy: function() {
        cc.Object.prototype.destroy.call(this) && this._activeInHierarchy && this._disableChildComps();
      },
      destroyAllChildren: function() {
        var children = this._children;
        for (var i = 0; i < children.length; ++i) children[i].destroy();
      },
      _onSetParent: function(value) {},
      _onPostActivated: function() {},
      _onBatchRestored: function() {
        var children = this._children;
        for (var i = 0, len = children.length; i < len; i++) children[i]._onBatchRestored();
      },
      _onHierarchyChanged: function(oldParent) {
        var newParent = this._parent;
        if (this._persistNode && !(newParent instanceof cc.Scene)) {
          cc.game.removePersistRootNode(this);
          false;
        }
        var shouldActiveNow = this._active && !!(newParent && newParent._activeInHierarchy);
        this._activeInHierarchy !== shouldActiveNow && cc.director._nodeActivator.activateNode(this, shouldActiveNow);
        var scene;
        var inCurrentSceneBefore;
        var inCurrentSceneNow;
        var newPrefabRoot;
        var myPrefabInfo;
        var PrefabUtils;
        false, false;
      },
      _onBatchCreated: function() {
        var prefabInfo = this._prefab;
        if (prefabInfo && prefabInfo.sync && prefabInfo.root === this) {
          false;
          PrefabHelper.syncWithPrefab(this);
        }
        var children = this._children;
        for (var i = 0, len = children.length; i < len; i++) children[i]._onBatchCreated();
      },
      _instantiate: function(cloned) {
        cloned || (cloned = cc.instantiate._clone(this, this));
        var thisPrefabInfo = this._prefab;
        var PrefabUtils;
        false;
        var syncing = thisPrefabInfo && this === thisPrefabInfo.root && thisPrefabInfo.sync;
        syncing || false;
        cloned._parent = null;
        cloned._onBatchRestored();
        return cloned;
      },
      _registerIfAttached: (false, false) && function(register) {
        if (register) {
          cc.engine.attachedObjsForEditor[this.uuid] = this;
          cc.engine.emit("node-attach-to-scene", {
            target: this
          });
        } else {
          cc.engine.emit("node-detach-from-scene", {
            target: this
          });
          delete cc.engine.attachedObjsForEditor[this._id];
        }
        var children = this._children;
        for (var i = 0, len = children.length; i < len; ++i) {
          var child = children[i];
          child._registerIfAttached(register);
        }
      },
      _onPreDestroy: function() {
        var i, len;
        this._objFlags |= Destroying;
        var parent = this._parent;
        var destroyByParent = parent && parent._objFlags & Destroying;
        !destroyByParent && (false, false) && this._registerIfAttached(false);
        var children = this._children;
        for (i = 0, len = children.length; i < len; ++i) children[i]._destroyImmediate();
        for (i = 0, len = this._components.length; i < len; ++i) {
          var component = this._components[i];
          component._destroyImmediate();
        }
        var eventTargets = this.__eventTargets;
        for (i = 0, len = eventTargets.length; i < len; ++i) {
          var target = eventTargets[i];
          target && target.targetOff(this);
        }
        eventTargets.length = 0;
        this._persistNode && cc.game.removePersistRootNode(this);
        if (!destroyByParent && parent) {
          var childIndex = parent._children.indexOf(this);
          parent._children.splice(childIndex, 1);
          parent.emit("child-removed", this);
        }
        return destroyByParent;
      },
      onRestore: false
    });
    BaseNode.prototype._onPreDestroyBase = BaseNode.prototype._onPreDestroy;
    false;
    BaseNode.prototype._onHierarchyChangedBase = BaseNode.prototype._onHierarchyChanged;
    false;
    var SameNameGetSets = [ "name", "children", "childrenCount" ];
    Misc.propertyDefine(BaseNode, SameNameGetSets, {});
    false;
    cc._BaseNode = module.exports = BaseNode;
  }), {
    "../event-manager": 58,
    "../platform/CCObject": 95,
    "../platform/id-generater": 105,
    "./misc": 137,
    "./prefab-helper": 139
  } ],
  134: [ (function(require, module, exports) {
    var Base64Values = require("./misc").BASE64_VALUES;
    var HexChars = "0123456789abcdef".split("");
    var _t = [ "", "", "", "" ];
    var UuidTemplate = _t.concat(_t, "-", _t, "-", _t, "-", _t, "-", _t, _t, _t);
    var Indices = UuidTemplate.map((function(x, i) {
      return "-" === x ? NaN : i;
    })).filter(isFinite);
    module.exports = function(base64) {
      if (22 !== base64.length) return base64;
      UuidTemplate[0] = base64[0];
      UuidTemplate[1] = base64[1];
      for (var i = 2, j = 2; i < 22; i += 2) {
        var lhs = Base64Values[base64.charCodeAt(i)];
        var rhs = Base64Values[base64.charCodeAt(i + 1)];
        UuidTemplate[Indices[j++]] = HexChars[lhs >> 2];
        UuidTemplate[Indices[j++]] = HexChars[(3 & lhs) << 2 | rhs >> 4];
        UuidTemplate[Indices[j++]] = HexChars[15 & rhs];
      }
      return UuidTemplate.join("");
    };
    false;
  }), {
    "./misc": 137
  } ],
  135: [ (function(require, module, exports) {
    cc.find = module.exports = function(path, referenceNode) {
      if (null == path) {
        cc.errorID(5600);
        return null;
      }
      if (referenceNode) false; else {
        var scene = cc.director.getScene();
        if (!scene) {
          false;
          return null;
        }
        false;
        referenceNode = scene;
      }
      var match = referenceNode;
      var startIndex = "/" !== path[0] ? 0 : 1;
      var nameList = path.split("/");
      for (var n = startIndex; n < nameList.length; n++) {
        var name = nameList[n];
        var children = match._children;
        match = null;
        for (var t = 0, len = children.length; t < len; ++t) {
          var subChild = children[t];
          if (subChild.name === name) {
            match = subChild;
            break;
          }
        }
        if (!match) return null;
      }
      return match;
    };
  }), {} ],
  136: [ (function(require, module, exports) {
    require("./CCPath");
    (true, true) && false;
    require("./find");
    require("./mutable-forward-iterator");
  }), {
    "./CCPath": 131,
    "./CCProfiler": 132,
    "./find": 135,
    "./mutable-forward-iterator": 138
  } ],
  137: [ (function(require, module, exports) {
    var JS = require("../platform/js");
    var sys = require("../platform/CCSys");
    var misc = exports;
    misc.propertyDefine = function(ctor, sameNameGetSets, diffNameGetSets) {
      function define(np, propName, getter, setter) {
        var pd = Object.getOwnPropertyDescriptor(np, propName);
        if (pd) {
          pd.get && (np[getter] = pd.get);
          pd.set && setter && (np[setter] = pd.set);
        } else {
          var getterFunc = np[getter];
          var clsName;
          false;
          cc.js.getset(np, propName, getterFunc, np[setter]);
        }
      }
      var propName, np = ctor.prototype;
      for (var i = 0; i < sameNameGetSets.length; i++) {
        propName = sameNameGetSets[i];
        var suffix = propName[0].toUpperCase() + propName.slice(1);
        define(np, propName, "get" + suffix, "set" + suffix);
      }
      for (propName in diffNameGetSets) {
        var getset = diffNameGetSets[propName];
        define(np, propName, getset[0], getset[1]);
      }
    };
    misc.NextPOT = function(x) {
      x -= 1;
      x |= x >> 1;
      x |= x >> 2;
      x |= x >> 4;
      x |= x >> 8;
      x |= x >> 16;
      return x + 1;
    };
    false;
    misc.imagePool = new JS.Pool(function(img) {
      if (img instanceof HTMLImageElement) {
        img.src = this._smallImg;
        return true;
      }
      return false;
    }, 10);
    misc.imagePool.get = function() {
      return this._get() || new Image();
    };
    misc.imagePool._smallImg = "data:image/gif;base64,R0lGODlhAQABAAAAACwAAAAAAQABAAA=";
    sys.os !== sys.OS_WINDOWS && sys.os !== sys.OS_LINUX || sys.browserType === sys.BROWSER_TYPE_CHROME || misc.imagePool.resize(0);
    misc.BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/;
    var BASE64_KEYS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var BASE64_VALUES = new Array(123);
    for (var i = 0; i < 123; ++i) BASE64_VALUES[i] = 64;
    for (var _i = 0; _i < 64; ++_i) BASE64_VALUES[BASE64_KEYS.charCodeAt(_i)] = _i;
    misc.BASE64_VALUES = BASE64_VALUES;
    misc.pushToMap = function(map, key, value, pushFront) {
      var exists = map[key];
      if (exists) if (Array.isArray(exists)) if (pushFront) {
        exists.push(exists[0]);
        exists[0] = value;
      } else exists.push(value); else map[key] = pushFront ? [ value, exists ] : [ exists, value ]; else map[key] = value;
    };
  }), {
    "../platform/CCSys": 97,
    "../platform/js": 109
  } ],
  138: [ (function(require, module, exports) {
    function MutableForwardIterator(array) {
      this.i = 0;
      this.array = array;
    }
    var proto = MutableForwardIterator.prototype;
    proto.remove = function(value) {
      var index = this.array.indexOf(value);
      index >= 0 && this.removeAt(index);
    };
    proto.removeAt = function(i) {
      this.array.splice(i, 1);
      i <= this.i && --this.i;
    };
    proto.fastRemove = function(value) {
      var index = this.array.indexOf(value);
      index >= 0 && this.fastRemoveAt(index);
    };
    proto.fastRemoveAt = function(i) {
      var array = this.array;
      array[i] = array[array.length - 1];
      --array.length;
      i <= this.i && --this.i;
    };
    proto.push = function(item) {
      this.array.push(item);
    };
    module.exports = MutableForwardIterator;
  }), {} ],
  139: [ (function(require, module, exports) {
    cc._PrefabInfo = cc.Class({
      name: "cc.PrefabInfo",
      properties: {
        root: null,
        asset: null,
        fileId: "",
        sync: false,
        _synced: {
          default: false,
          serializable: false
        }
      }
    });
    module.exports = {
      syncWithPrefab: function(node) {
        var _prefab = node._prefab;
        _prefab._synced = true;
        if (!_prefab.asset) {
          var NodeUtils;
          var PrefabUtils;
          false;
          cc.errorID(3701, node.name);
          node._prefab = null;
          return;
        }
        var _objFlags = node._objFlags;
        var _parent = node._parent;
        var _id = node._id;
        var _name = node._name;
        var _active = node._active;
        var x = node._position.x;
        var y = node._position.y;
        var _rotationX = node._rotationX;
        var _rotationY = node._rotationY;
        var _localZOrder = node._localZOrder;
        var _globalZOrder = node._globalZOrder;
        cc.game._isCloning = true;
        false;
        var prefabRoot = _prefab.asset.data;
        prefabRoot._prefab._synced = true;
        prefabRoot._iN$t = node;
        cc.instantiate._clone(prefabRoot, prefabRoot);
        cc.game._isCloning = false;
        node._objFlags = _objFlags;
        node._parent = _parent;
        node._id = _id;
        node._prefab = _prefab;
        node._name = _name;
        node._active = _active;
        node._position.x = x;
        node._position.y = y;
        node._rotationX = _rotationX;
        node._rotationY = _rotationY;
        node._localZOrder = _localZOrder;
        node._globalZOrder = _globalZOrder;
      }
    };
  }), {} ],
  140: [ (function(require, module, exports) {
    var SceneGraphUtils = {
      removeSgNode: function() {
        var sgNode = this._sgNode;
        if (sgNode) {
          var parent = sgNode._parent;
          if (parent) parent.removeChild(sgNode); else {
            false;
            sgNode.performRecursive(_ccsg.Node.performType.cleanup);
          }
          sgNode._entity && (sgNode._entity = null);
        }
      }
    };
    false;
    module.exports = SceneGraphUtils;
  }), {} ],
  141: [ (function(require, module, exports) {
    cc.AffineTransform = function(a, b, c, d, tx, ty) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.d = d;
      this.tx = tx;
      this.ty = ty;
    };
    cc.affineTransformMake = function(a, b, c, d, tx, ty) {
      return {
        a: a,
        b: b,
        c: c,
        d: d,
        tx: tx,
        ty: ty
      };
    };
    cc.affineTransformClone = function(t) {
      return {
        a: t.a,
        b: t.b,
        c: t.c,
        d: t.d,
        tx: t.tx,
        ty: t.ty
      };
    };
    cc.pointApplyAffineTransform = function(point, transOrY, t) {
      var x, y;
      if (void 0 === t) {
        t = transOrY;
        x = point.x;
        y = point.y;
      } else {
        x = point;
        y = transOrY;
      }
      return {
        x: t.a * x + t.c * y + t.tx,
        y: t.b * x + t.d * y + t.ty
      };
    };
    cc._pointApplyAffineTransformIn = function(point, transOrY, transOrOut, out) {
      var x, y, t;
      if (void 0 === out) {
        t = transOrY;
        x = point.x;
        y = point.y;
        out = transOrOut;
      } else {
        x = point;
        y = transOrY;
        t = transOrOut;
      }
      out.x = t.a * x + t.c * y + t.tx;
      out.y = t.b * x + t.d * y + t.ty;
    };
    cc._pointApplyAffineTransform = function(x, y, t) {
      return cc.pointApplyAffineTransform(x, y, t);
    };
    cc.sizeApplyAffineTransform = function(size, t) {
      return {
        width: t.a * size.width + t.c * size.height,
        height: t.b * size.width + t.d * size.height
      };
    };
    cc.affineTransformMakeIdentity = function() {
      return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
      };
    };
    cc.affineTransformIdentity = function() {
      return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
      };
    };
    cc.rectApplyAffineTransform = function(rect, t) {
      var ol = rect.x;
      var ob = rect.y;
      var or = ol + rect.width;
      var ot = ob + rect.height;
      var lbx = t.a * ol + t.c * ob + t.tx;
      var lby = t.b * ol + t.d * ob + t.ty;
      var rbx = t.a * or + t.c * ob + t.tx;
      var rby = t.b * or + t.d * ob + t.ty;
      var ltx = t.a * ol + t.c * ot + t.tx;
      var lty = t.b * ol + t.d * ot + t.ty;
      var rtx = t.a * or + t.c * ot + t.tx;
      var rty = t.b * or + t.d * ot + t.ty;
      var minX = Math.min(lbx, rbx, ltx, rtx);
      var maxX = Math.max(lbx, rbx, ltx, rtx);
      var minY = Math.min(lby, rby, lty, rty);
      var maxY = Math.max(lby, rby, lty, rty);
      return cc.rect(minX, minY, maxX - minX, maxY - minY);
    };
    cc._rectApplyAffineTransformIn = function(rect, t) {
      var ol = rect.x;
      var ob = rect.y;
      var or = ol + rect.width;
      var ot = ob + rect.height;
      var lbx = t.a * ol + t.c * ob + t.tx;
      var lby = t.b * ol + t.d * ob + t.ty;
      var rbx = t.a * or + t.c * ob + t.tx;
      var rby = t.b * or + t.d * ob + t.ty;
      var ltx = t.a * ol + t.c * ot + t.tx;
      var lty = t.b * ol + t.d * ot + t.ty;
      var rtx = t.a * or + t.c * ot + t.tx;
      var rty = t.b * or + t.d * ot + t.ty;
      var minX = Math.min(lbx, rbx, ltx, rtx);
      var maxX = Math.max(lbx, rbx, ltx, rtx);
      var minY = Math.min(lby, rby, lty, rty);
      var maxY = Math.max(lby, rby, lty, rty);
      rect.x = minX;
      rect.y = minY;
      rect.width = maxX - minX;
      rect.height = maxY - minY;
      return rect;
    };
    cc.obbApplyAffineTransform = function(rect, anAffineTransform, out_bl, out_tl, out_tr, out_br) {
      var x = rect.x;
      var y = rect.y;
      var width = rect.width;
      var height = rect.height;
      var tx = anAffineTransform.a * x + anAffineTransform.c * y + anAffineTransform.tx;
      var ty = anAffineTransform.b * x + anAffineTransform.d * y + anAffineTransform.ty;
      var xa = anAffineTransform.a * width;
      var xb = anAffineTransform.b * width;
      var yc = anAffineTransform.c * height;
      var yd = anAffineTransform.d * height;
      out_tl.x = tx;
      out_tl.y = ty;
      out_tr.x = xa + tx;
      out_tr.y = xb + ty;
      out_bl.x = yc + tx;
      out_bl.y = yd + ty;
      out_br.x = xa + yc + tx;
      out_br.y = xb + yd + ty;
    };
    cc.affineTransformTranslate = function(t, tx, ty) {
      return {
        a: t.a,
        b: t.b,
        c: t.c,
        d: t.d,
        tx: t.tx + t.a * tx + t.c * ty,
        ty: t.ty + t.b * tx + t.d * ty
      };
    };
    cc.affineTransformScale = function(t, sx, sy) {
      return {
        a: t.a * sx,
        b: t.b * sx,
        c: t.c * sy,
        d: t.d * sy,
        tx: t.tx,
        ty: t.ty
      };
    };
    cc.affineTransformRotate = function(aTransform, anAngle) {
      var fSin = Math.sin(anAngle);
      var fCos = Math.cos(anAngle);
      return {
        a: aTransform.a * fCos + aTransform.c * fSin,
        b: aTransform.b * fCos + aTransform.d * fSin,
        c: aTransform.c * fCos - aTransform.a * fSin,
        d: aTransform.d * fCos - aTransform.b * fSin,
        tx: aTransform.tx,
        ty: aTransform.ty
      };
    };
    cc.affineTransformConcat = function(t1, t2) {
      return {
        a: t1.a * t2.a + t1.b * t2.c,
        b: t1.a * t2.b + t1.b * t2.d,
        c: t1.c * t2.a + t1.d * t2.c,
        d: t1.c * t2.b + t1.d * t2.d,
        tx: t1.tx * t2.a + t1.ty * t2.c + t2.tx,
        ty: t1.tx * t2.b + t1.ty * t2.d + t2.ty
      };
    };
    cc.affineTransformConcatIn = function(t1, t2) {
      var a = t1.a, b = t1.b, c = t1.c, d = t1.d, tx = t1.tx, ty = t1.ty;
      t1.a = a * t2.a + b * t2.c;
      t1.b = a * t2.b + b * t2.d;
      t1.c = c * t2.a + d * t2.c;
      t1.d = c * t2.b + d * t2.d;
      t1.tx = tx * t2.a + ty * t2.c + t2.tx;
      t1.ty = tx * t2.b + ty * t2.d + t2.ty;
      return t1;
    };
    cc.affineTransformEqualToTransform = function(t1, t2) {
      return t1.a === t2.a && t1.b === t2.b && t1.c === t2.c && t1.d === t2.d && t1.tx === t2.tx && t1.ty === t2.ty;
    };
    cc.affineTransformInvert = function(t) {
      var determinant = 1 / (t.a * t.d - t.b * t.c);
      return {
        a: determinant * t.d,
        b: -determinant * t.b,
        c: -determinant * t.c,
        d: determinant * t.a,
        tx: determinant * (t.c * t.ty - t.d * t.tx),
        ty: determinant * (t.b * t.tx - t.a * t.ty)
      };
    };
    cc.affineTransformInvertIn = function(t) {
      var a = t.a, b = t.b, c = t.c, d = t.d;
      var determinant = 1 / (a * d - b * c);
      var tx = t.tx, ty = t.ty;
      t.a = determinant * d;
      t.b = -determinant * b;
      t.c = -determinant * c;
      t.d = determinant * a;
      t.tx = determinant * (c * ty - d * tx);
      t.ty = determinant * (b * tx - a * ty);
      return t;
    };
    cc.affineTransformInvertOut = function(t, out) {
      var a = t.a, b = t.b, c = t.c, d = t.d, tx = t.tx, ty = t.ty;
      var determinant = 1 / (a * d - b * c);
      out.a = determinant * d;
      out.b = -determinant * b;
      out.c = -determinant * c;
      out.d = determinant * a;
      out.tx = determinant * (c * ty - d * tx);
      out.ty = determinant * (b * tx - a * ty);
    };
  }), {} ],
  142: [ (function(require, module, exports) {
    var ValueType = require("./CCValueType");
    var JS = require("../platform/js");
    var Color = (function() {
      function Color(r, g, b, a) {
        if ("object" === typeof r) {
          g = r.g;
          b = r.b;
          a = r.a;
          r = r.r;
        }
        r = r || 0;
        g = g || 0;
        b = b || 0;
        a = "number" === typeof a ? a : 255;
        this._val = (~~r << 24 >>> 0) + (~~g << 16) + (~~b << 8) + ~~a;
      }
      JS.extend(Color, ValueType);
      require("../platform/CCClass").fastDefine("cc.Color", Color, {
        r: 0,
        g: 0,
        b: 0,
        a: 255
      });
      var DefaultColors = {
        WHITE: [ 255, 255, 255, 255 ],
        BLACK: [ 0, 0, 0, 255 ],
        TRANSPARENT: [ 0, 0, 0, 0 ],
        GRAY: [ 127.5, 127.5, 127.5 ],
        RED: [ 255, 0, 0 ],
        GREEN: [ 0, 255, 0 ],
        BLUE: [ 0, 0, 255 ],
        YELLOW: [ 255, 235, 4 ],
        ORANGE: [ 255, 127, 0 ],
        CYAN: [ 0, 255, 255 ],
        MAGENTA: [ 255, 0, 255 ]
      };
      for (var colorName in DefaultColors) JS.get(Color, colorName, (function(rgba) {
        return function() {
          return new Color(rgba[0], rgba[1], rgba[2], rgba[3]);
        };
      })(DefaultColors[colorName]));
      var proto = Color.prototype;
      proto.clone = function() {
        var ret = new Color();
        ret._val = this._val;
        return ret;
      };
      proto.equals = function(other) {
        return other && this._val === other._val;
      };
      proto.lerp = function(to, ratio, out) {
        out = out || new Color();
        var r = this.r;
        var g = this.g;
        var b = this.b;
        var a = this.a;
        out.r = r + (to.r - r) * ratio;
        out.g = g + (to.g - g) * ratio;
        out.b = b + (to.b - b) * ratio;
        out.a = a + (to.a - a) * ratio;
        return out;
      };
      proto.toString = function() {
        return "rgba(" + this.r.toFixed() + ", " + this.g.toFixed() + ", " + this.b.toFixed() + ", " + this.a.toFixed() + ")";
      };
      proto.getR = function() {
        return (4278190080 & this._val) >>> 24;
      };
      proto.setR = function(red) {
        this._val = (16777215 & this._val | ~~red << 24 >>> 0) >>> 0;
        return this;
      };
      proto.getG = function() {
        return (16711680 & this._val) >> 16;
      };
      proto.setG = function(green) {
        this._val = (4278255615 & this._val | ~~green << 16) >>> 0;
        return this;
      };
      proto.getB = function() {
        return (65280 & this._val) >> 8;
      };
      proto.setB = function(blue) {
        this._val = (4294902015 & this._val | ~~blue << 8) >>> 0;
        return this;
      };
      proto.getA = function() {
        return 255 & this._val;
      };
      proto.setA = function(alpha) {
        this._val = (4294967040 & this._val | ~~alpha) >>> 0;
        return this;
      };
      JS.getset(proto, "r", proto.getR, proto.setR, true);
      JS.getset(proto, "g", proto.getG, proto.setG, true);
      JS.getset(proto, "b", proto.getB, proto.setB, true);
      JS.getset(proto, "a", proto.getA, proto.setA, true);
      proto.toCSS = function(opt) {
        return "rgba" === opt ? "rgba(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + "," + (this.a / 255).toFixed(2) + ")" : "rgb" === opt ? "rgb(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + ")" : "#" + this.toHEX(opt);
      };
      proto.clamp = function() {
        return;
      };
      proto.fromHEX = function(hexString) {
        hexString.length < 8 && (hexString += "FF");
        var hex = parseInt(hexString.indexOf("#") > -1 ? hexString.substring(1) : hexString, 16);
        this._val = (0 & this._val | hex) >>> 0;
        return this;
      };
      proto.toHEX = function(fmt) {
        var hex = [ (0 | this.r).toString(16), (0 | this.g).toString(16), (0 | this.b).toString(16) ];
        var i = -1;
        if ("#rgb" === fmt) for (i = 0; i < hex.length; ++i) hex[i].length > 1 && (hex[i] = hex[i][0]); else if ("#rrggbb" === fmt) for (i = 0; i < hex.length; ++i) 1 === hex[i].length && (hex[i] = "0" + hex[i]);
        return hex.join("");
      };
      proto.toRGBValue = function() {
        return 16777215 & this._val;
      };
      proto.fromHSV = function(h, s, v) {
        var rgb = Color.hsv2rgb(h, s, v);
        this._val = (rgb.r << 24 >>> 0) + (rgb.g << 16) + (rgb.b << 8) + this.a;
        return this;
      };
      proto.toHSV = function() {
        return Color.rgb2hsv(this.r, this.g, this.b);
      };
      proto.fromColor = function(color) {
        if (color._val) this._val = color._val; else {
          this.r = color.r;
          this.g = color.g;
          this.b = color.b;
          this.a = color.a;
        }
      };
      return Color;
    })();
    Color.rgb2hsv = function(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      var hsv = {
        h: 0,
        s: 0,
        v: 0
      };
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var delta = 0;
      hsv.v = max;
      hsv.s = max ? (max - min) / max : 0;
      if (hsv.s) {
        delta = max - min;
        hsv.h = r === max ? (g - b) / delta : g === max ? 2 + (b - r) / delta : 4 + (r - g) / delta;
        hsv.h /= 6;
        hsv.h < 0 && (hsv.h += 1);
      } else hsv.h = 0;
      return hsv;
    };
    Color.hsv2rgb = function(h, s, v) {
      var rgb = {
        r: 0,
        g: 0,
        b: 0
      };
      if (0 === s) rgb.r = rgb.g = rgb.b = v; else if (0 === v) rgb.r = rgb.g = rgb.b = 0; else {
        1 === h && (h = 0);
        h *= 6;
        s = s;
        v = v;
        var i = Math.floor(h);
        var f = h - i;
        var p = v * (1 - s);
        var q = v * (1 - s * f);
        var t = v * (1 - s * (1 - f));
        switch (i) {
         case 0:
          rgb.r = v;
          rgb.g = t;
          rgb.b = p;
          break;

         case 1:
          rgb.r = q;
          rgb.g = v;
          rgb.b = p;
          break;

         case 2:
          rgb.r = p;
          rgb.g = v;
          rgb.b = t;
          break;

         case 3:
          rgb.r = p;
          rgb.g = q;
          rgb.b = v;
          break;

         case 4:
          rgb.r = t;
          rgb.g = p;
          rgb.b = v;
          break;

         case 5:
          rgb.r = v;
          rgb.g = p;
          rgb.b = q;
        }
      }
      rgb.r *= 255;
      rgb.g *= 255;
      rgb.b *= 255;
      return rgb;
    };
    cc.Color = Color;
    cc.color = function color(r, g, b, a) {
      if ("string" === typeof r) {
        var result = new cc.Color();
        return result.fromHEX(r);
      }
      if ("object" === typeof r) return new cc.Color(r.r, r.g, r.b, r.a);
      return new cc.Color(r, g, b, a);
    };
    cc.colorEqual = function(color1, color2) {
      return void 0 !== color1._val && void 0 !== color2._val ? color1._val === color2._val : color1.r === color2.r && color1.g === color2.g && color1.b === color2.b;
    };
    cc.hexToColor = function(hex) {
      hex = hex.replace(/^#?/, "0x");
      var c = parseInt(hex);
      var r = c >> 16;
      var g = (65280 & c) >> 8;
      var b = 255 & c;
      return cc.color(r, g, b);
    };
    cc.colorToHex = function(color) {
      var hR = color.r.toString(16), hG = color.g.toString(16), hB = color.b.toString(16);
      return "#" + (color.r < 16 ? "0" + hR : hR) + (color.g < 16 ? "0" + hG : hG) + (color.b < 16 ? "0" + hB : hB);
    };
    module.exports = cc.Color;
  }), {
    "../platform/CCClass": 89,
    "../platform/js": 109,
    "./CCValueType": 148
  } ],
  143: [ (function(require, module, exports) {
    var POINT_EPSILON = parseFloat("1.192092896e-07F");
    cc.pNeg = function(point) {
      return cc.p(-point.x, -point.y);
    };
    cc.pAdd = function(v1, v2) {
      return cc.p(v1.x + v2.x, v1.y + v2.y);
    };
    cc.pSub = function(v1, v2) {
      return cc.p(v1.x - v2.x, v1.y - v2.y);
    };
    cc.pMult = function(point, floatVar) {
      return cc.p(point.x * floatVar, point.y * floatVar);
    };
    cc.pMidpoint = function(v1, v2) {
      return cc.pMult(cc.pAdd(v1, v2), .5);
    };
    cc.pDot = function(v1, v2) {
      return v1.x * v2.x + v1.y * v2.y;
    };
    cc.pCross = function(v1, v2) {
      return v1.x * v2.y - v1.y * v2.x;
    };
    cc.pPerp = function(point) {
      return cc.p(-point.y, point.x);
    };
    cc.pRPerp = function(point) {
      return cc.p(point.y, -point.x);
    };
    cc.pProject = function(v1, v2) {
      return cc.pMult(v2, cc.pDot(v1, v2) / cc.pDot(v2, v2));
    };
    cc.pLengthSQ = function(v) {
      return cc.pDot(v, v);
    };
    cc.pDistanceSQ = function(point1, point2) {
      return cc.pLengthSQ(cc.pSub(point1, point2));
    };
    cc.pLength = function(v) {
      return Math.sqrt(cc.pLengthSQ(v));
    };
    cc.pDistance = function(v1, v2) {
      return cc.pLength(cc.pSub(v1, v2));
    };
    cc.pNormalize = function(v) {
      var n = cc.pLength(v);
      return 0 === n ? cc.p(v) : cc.pMult(v, 1 / n);
    };
    cc.pForAngle = function(a) {
      return cc.p(Math.cos(a), Math.sin(a));
    };
    cc.pToAngle = function(v) {
      return Math.atan2(v.y, v.x);
    };
    cc.clampf = function(value, min_inclusive, max_inclusive) {
      if (min_inclusive > max_inclusive) {
        var temp = min_inclusive;
        min_inclusive = max_inclusive;
        max_inclusive = temp;
      }
      return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
    };
    cc.clamp01 = function(value) {
      return value < 0 ? 0 : value < 1 ? value : 1;
    };
    cc.pClamp = function(p, min_inclusive, max_inclusive) {
      return cc.p(cc.clampf(p.x, min_inclusive.x, max_inclusive.x), cc.clampf(p.y, min_inclusive.y, max_inclusive.y));
    };
    cc.pFromSize = function(s) {
      return cc.p(s.width, s.height);
    };
    cc.pCompOp = function(p, opFunc) {
      return cc.p(opFunc(p.x), opFunc(p.y));
    };
    cc.pLerp = function(a, b, alpha) {
      return cc.pAdd(cc.pMult(a, 1 - alpha), cc.pMult(b, alpha));
    };
    cc.pFuzzyEqual = function(a, b, variance) {
      if (a.x - variance <= b.x && b.x <= a.x + variance && a.y - variance <= b.y && b.y <= a.y + variance) return true;
      return false;
    };
    cc.pCompMult = function(a, b) {
      return cc.p(a.x * b.x, a.y * b.y);
    };
    cc.pAngleSigned = function(a, b) {
      var a2 = cc.pNormalize(a);
      var b2 = cc.pNormalize(b);
      var angle = Math.atan2(a2.x * b2.y - a2.y * b2.x, cc.pDot(a2, b2));
      if (Math.abs(angle) < POINT_EPSILON) return 0;
      return angle;
    };
    cc.pAngle = function(a, b) {
      var angle = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
      if (Math.abs(angle) < POINT_EPSILON) return 0;
      return angle;
    };
    cc.pRotateByAngle = function(v, pivot, angle) {
      var r = cc.pSub(v, pivot);
      var cosa = Math.cos(angle), sina = Math.sin(angle);
      var t = r.x;
      r.x = t * cosa - r.y * sina + pivot.x;
      r.y = t * sina + r.y * cosa + pivot.y;
      return r;
    };
    cc.pLineIntersect = function(A, B, C, D, retP) {
      if (A.x === B.x && A.y === B.y || C.x === D.x && C.y === D.y) return false;
      var BAx = B.x - A.x;
      var BAy = B.y - A.y;
      var DCx = D.x - C.x;
      var DCy = D.y - C.y;
      var ACx = A.x - C.x;
      var ACy = A.y - C.y;
      var denom = DCy * BAx - DCx * BAy;
      retP.x = DCx * ACy - DCy * ACx;
      retP.y = BAx * ACy - BAy * ACx;
      if (0 === denom) {
        if (0 === retP.x || 0 === retP.y) return true;
        return false;
      }
      retP.x = retP.x / denom;
      retP.y = retP.y / denom;
      return true;
    };
    cc.pSegmentIntersect = function(A, B, C, D) {
      var retP = cc.p(0, 0);
      if (cc.pLineIntersect(A, B, C, D, retP) && retP.x >= 0 && retP.x <= 1 && retP.y >= 0 && retP.y <= 1) return true;
      return false;
    };
    cc.pIntersectPoint = function(A, B, C, D) {
      var retP = cc.p(0, 0);
      if (cc.pLineIntersect(A, B, C, D, retP)) {
        var P = cc.p(0, 0);
        P.x = A.x + retP.x * (B.x - A.x);
        P.y = A.y + retP.x * (B.y - A.y);
        return P;
      }
      return cc.p(0, 0);
    };
    cc.pSameAs = function(A, B) {
      if (null != A && null != B) return A.x === B.x && A.y === B.y;
      return false;
    };
    cc.pZeroIn = function(v) {
      v.x = 0;
      v.y = 0;
    };
    cc.pIn = function(v1, v2) {
      v1.x = v2.x;
      v1.y = v2.y;
    };
    cc.pMultIn = function(point, floatVar) {
      point.x *= floatVar;
      point.y *= floatVar;
    };
    cc.pSubIn = function(v1, v2) {
      v1.x -= v2.x;
      v1.y -= v2.y;
    };
    cc.pAddIn = function(v1, v2) {
      v1.x += v2.x;
      v1.y += v2.y;
    };
    cc.pNormalizeIn = function(v) {
      cc.pMultIn(v, 1 / Math.sqrt(v.x * v.x + v.y * v.y));
    };
  }), {} ],
  144: [ (function(require, module, exports) {
    var ValueType = require("./CCValueType");
    var JS = require("../platform/js");
    function Rect(x, y, w, h) {
      if (x && "object" === typeof x) {
        y = x.y;
        w = x.width;
        h = x.height;
        x = x.x;
      }
      this.x = x || 0;
      this.y = y || 0;
      this.width = w || 0;
      this.height = h || 0;
    }
    JS.extend(Rect, ValueType);
    require("../platform/CCClass").fastDefine("cc.Rect", Rect, {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
    Rect.fromMinMax = function(v1, v2) {
      var min_x = Math.min(v1.x, v2.x);
      var min_y = Math.min(v1.y, v2.y);
      var max_x = Math.max(v1.x, v2.x);
      var max_y = Math.max(v1.y, v2.y);
      return new Rect(min_x, min_y, max_x - min_x, max_y - min_y);
    };
    Rect.contain = function _Contain(a, b) {
      if (a.x < b.x && a.x + a.width > b.x + b.width && a.y < b.y && a.y + a.height > b.y + b.height) return 1;
      if (b.x < a.x && b.x + b.width > a.x + a.width && b.y < a.y && b.y + b.height > a.y + a.height) return -1;
      return 0;
    };
    var proto = Rect.prototype;
    proto.clone = function() {
      return new Rect(this.x, this.y, this.width, this.height);
    };
    proto.equals = function(other) {
      return other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
    };
    proto.lerp = function(to, ratio, out) {
      out = out || new Rect();
      var x = this.x;
      var y = this.y;
      var width = this.width;
      var height = this.height;
      out.x = x + (to.x - x) * ratio;
      out.y = y + (to.y - y) * ratio;
      out.width = width + (to.width - width) * ratio;
      out.height = height + (to.height - height) * ratio;
      return out;
    };
    proto.toString = function() {
      return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")";
    };
    JS.getset(proto, "xMin", (function() {
      return this.x;
    }), (function(value) {
      this.width += this.x - value;
      this.x = value;
    }));
    JS.getset(proto, "yMin", (function() {
      return this.y;
    }), (function(value) {
      this.height += this.y - value;
      this.y = value;
    }));
    JS.getset(proto, "xMax", (function() {
      return this.x + this.width;
    }), (function(value) {
      this.width = value - this.x;
    }));
    JS.getset(proto, "yMax", (function() {
      return this.y + this.height;
    }), (function(value) {
      this.height = value - this.y;
    }));
    JS.getset(proto, "center", (function() {
      return new cc.Vec2(this.x + .5 * this.width, this.y + .5 * this.height);
    }), (function(value) {
      this.x = value.x - .5 * this.width;
      this.y = value.y - .5 * this.height;
    }));
    JS.getset(proto, "origin", (function() {
      return new cc.Vec2(this.x, this.y);
    }), (function(value) {
      this.x = value.x;
      this.y = value.y;
    }));
    JS.getset(proto, "size", (function() {
      return new cc.Size(this.width, this.height);
    }), (function(value) {
      this.width = value.width;
      this.height = value.height;
    }));
    proto.intersects = function(rect) {
      return cc.rectIntersectsRect(this, rect);
    };
    proto.contains = function(point) {
      return this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y;
    };
    proto.containsRect = function(rect) {
      return this.x <= rect.x && this.x + this.width >= rect.x + rect.width && this.y <= rect.y && this.y + this.height >= rect.y + rect.height;
    };
    cc.Rect = Rect;
    cc.rect = function rect(x, y, w, h) {
      return new Rect(x, y, w, h);
    };
    cc.rectEqualToRect = function(rect1, rect2) {
      return rect1 && rect2 && rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;
    };
    cc._rectEqualToZero = function(rect) {
      return rect && 0 === rect.x && 0 === rect.y && 0 === rect.width && 0 === rect.height;
    };
    cc.rectContainsRect = function(rect1, rect2) {
      if (!rect1 || !rect2) return false;
      return !(rect1.x >= rect2.x || rect1.y >= rect2.y || rect1.x + rect1.width <= rect2.x + rect2.width || rect1.y + rect1.height <= rect2.y + rect2.height);
    };
    cc.rectGetMaxX = function(rect) {
      return rect.x + rect.width;
    };
    cc.rectGetMidX = function(rect) {
      return rect.x + rect.width / 2;
    };
    cc.rectGetMinX = function(rect) {
      return rect.x;
    };
    cc.rectGetMaxY = function(rect) {
      return rect.y + rect.height;
    };
    cc.rectGetMidY = function(rect) {
      return rect.y + rect.height / 2;
    };
    cc.rectGetMinY = function(rect) {
      return rect.y;
    };
    cc.rectContainsPoint = function(rect, point) {
      return point.x >= cc.rectGetMinX(rect) && point.x <= cc.rectGetMaxX(rect) && point.y >= cc.rectGetMinY(rect) && point.y <= cc.rectGetMaxY(rect);
    };
    cc.rectIntersectsRect = function(ra, rb) {
      var maxax = ra.x + ra.width, maxay = ra.y + ra.height, maxbx = rb.x + rb.width, maxby = rb.y + rb.height;
      return !(maxax < rb.x || maxbx < ra.x || maxay < rb.y || maxby < ra.y);
    };
    cc.rectOverlapsRect = function(rectA, rectB) {
      return !(rectA.x + rectA.width < rectB.x || rectB.x + rectB.width < rectA.x || rectA.y + rectA.height < rectB.y || rectB.y + rectB.height < rectA.y);
    };
    cc.rectUnion = function(rectA, rectB) {
      var rect = cc.rect(0, 0, 0, 0);
      rect.x = Math.min(rectA.x, rectB.x);
      rect.y = Math.min(rectA.y, rectB.y);
      rect.width = Math.max(rectA.x + rectA.width, rectB.x + rectB.width) - rect.x;
      rect.height = Math.max(rectA.y + rectA.height, rectB.y + rectB.height) - rect.y;
      return rect;
    };
    cc.rectIntersection = function(rectA, rectB) {
      var intersection = cc.rect(Math.max(cc.rectGetMinX(rectA), cc.rectGetMinX(rectB)), Math.max(cc.rectGetMinY(rectA), cc.rectGetMinY(rectB)), 0, 0);
      intersection.width = Math.min(cc.rectGetMaxX(rectA), cc.rectGetMaxX(rectB)) - cc.rectGetMinX(intersection);
      intersection.height = Math.min(cc.rectGetMaxY(rectA), cc.rectGetMaxY(rectB)) - cc.rectGetMinY(intersection);
      return intersection;
    };
    module.exports = cc.Rect;
  }), {
    "../platform/CCClass": 89,
    "../platform/js": 109,
    "./CCValueType": 148
  } ],
  145: [ (function(require, module, exports) {
    var ValueType = require("./CCValueType");
    var JS = require("../platform/js");
    function Size(width, height) {
      if (width && "object" === typeof width) {
        height = width.height;
        width = width.width;
      }
      this.width = width || 0;
      this.height = height || 0;
    }
    JS.extend(Size, ValueType);
    require("../platform/CCClass").fastDefine("cc.Size", Size, {
      width: 0,
      height: 0
    });
    JS.get(Size, "ZERO", (function() {
      return new Size(0, 0);
    }));
    var proto = Size.prototype;
    proto.clone = function() {
      return new Size(this.width, this.height);
    };
    proto.equals = function(other) {
      return other && this.width === other.width && this.height === other.height;
    };
    proto.lerp = function(to, ratio, out) {
      out = out || new Size();
      var width = this.width;
      var height = this.height;
      out.width = width + (to.width - width) * ratio;
      out.height = height + (to.height - height) * ratio;
      return out;
    };
    proto.toString = function() {
      return "(" + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")";
    };
    cc.size = function(w, h) {
      return new Size(w, h);
    };
    cc.sizeEqualToSize = function(size1, size2) {
      return size1 && size2 && size1.width === size2.width && size1.height === size2.height;
    };
    cc.Size = module.exports = Size;
  }), {
    "../platform/CCClass": 89,
    "../platform/js": 109,
    "./CCValueType": 148
  } ],
  146: [ (function(require, module, exports) {
    cc.Acceleration = function(x, y, z, timestamp) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      this.timestamp = timestamp || 0;
    };
    cc.BlendFunc = function(src1, dst1) {
      this.src = src1;
      this.dst = dst1;
    };
    var BlendFactor = cc.Enum({
      ONE: 1,
      ZERO: 0,
      SRC_ALPHA: 770,
      SRC_COLOR: 768,
      DST_ALPHA: 772,
      DST_COLOR: 774,
      ONE_MINUS_SRC_ALPHA: 771,
      ONE_MINUS_SRC_COLOR: 769,
      ONE_MINUS_DST_ALPHA: 773,
      ONE_MINUS_DST_COLOR: 775
    });
    cc.BlendFunc._disable = function() {
      return new cc.BlendFunc(BlendFactor.ONE, BlendFactor.ZERO);
    };
    cc.BlendFunc._alphaPremultiplied = function() {
      return new cc.BlendFunc(BlendFactor.ONE, BlendFactor.ONE_MINUS_SRC_ALPHA);
    };
    cc.BlendFunc._alphaNonPremultiplied = function() {
      return new cc.BlendFunc(BlendFactor.SRC_ALPHA, BlendFactor.ONE_MINUS_SRC_ALPHA);
    };
    cc.BlendFunc._additive = function() {
      return new cc.BlendFunc(BlendFactor.SRC_ALPHA, BlendFactor.ONE);
    };
    cc.BlendFunc.BlendFactor = BlendFactor;
    cc.BlendFunc.DISABLE;
    cc.js.get(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable);
    cc.BlendFunc.ALPHA_PREMULTIPLIED;
    cc.js.get(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied);
    cc.BlendFunc.ALPHA_NON_PREMULTIPLIED;
    cc.js.get(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied);
    cc.BlendFunc.ADDITIVE;
    cc.js.get(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive);
    cc.blendFuncDisable = cc.BlendFunc._disable;
    cc.TextAlignment = cc.Enum({
      LEFT: 0,
      CENTER: 1,
      RIGHT: 2
    });
    cc.VerticalTextAlignment = cc.Enum({
      TOP: 0,
      CENTER: 1,
      BOTTOM: 2
    });
  }), {} ],
  147: [ (function(require, module, exports) {
    cc.WebGLColor = function(r, g, b, a, arrayBuffer, offset) {
      this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.WebGLColor.BYTES_PER_ELEMENT);
      this._offset = offset || 0;
      var locArrayBuffer = this._arrayBuffer, locOffset = this._offset;
      this._view = new Uint8Array(locArrayBuffer, locOffset, 4);
      this._view[0] = r || 0;
      this._view[1] = g || 0;
      this._view[2] = b || 0;
      if ("number" === typeof a) this._view[3] = a; else {
        this._view[3] = 255;
        this.a_undefined = true;
      }
    };
    cc.WebGLColor.BYTES_PER_ELEMENT = 4;
    var _p = cc.WebGLColor.prototype;
    _p._getR = function() {
      return this._view[0];
    };
    _p._setR = function(value) {
      this._view[0] = value < 0 ? 0 : value;
    };
    _p._getG = function() {
      return this._view[1];
    };
    _p._setG = function(value) {
      this._view[1] = value < 0 ? 0 : value;
    };
    _p._getB = function() {
      return this._view[2];
    };
    _p._setB = function(value) {
      this._view[2] = value < 0 ? 0 : value;
    };
    _p._getA = function() {
      return this._view[3];
    };
    _p._setA = function(value) {
      this._view[3] = value < 0 ? 0 : value;
    };
    _p.r;
    cc.js.getset(_p, "r", _p._getR, _p._setR);
    _p.g;
    cc.js.getset(_p, "g", _p._getG, _p._setG);
    _p.b;
    cc.js.getset(_p, "b", _p._getB, _p._setB);
    _p.a;
    cc.js.getset(_p, "a", _p._getA, _p._setA);
    cc.Vertex2F = function(x, y, arrayBuffer, offset) {
      this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT);
      this._offset = offset || 0;
      this._view = new Float32Array(this._arrayBuffer, this._offset, 2);
      this._view[0] = x || 0;
      this._view[1] = y || 0;
    };
    cc.Vertex2F.BYTES_PER_ELEMENT = 8;
    var _p = cc.Vertex2F.prototype;
    _p._getX = function() {
      return this._view[0];
    };
    _p._setX = function(xValue) {
      this._view[0] = xValue;
    };
    _p._getY = function() {
      return this._view[1];
    };
    _p._setY = function(yValue) {
      this._view[1] = yValue;
    };
    cc.js.getset(_p, "x", _p._getX, _p._setX);
    cc.js.getset(_p, "y", _p._getY, _p._setY);
    cc.Vertex3F = function(x, y, z, arrayBuffer, offset) {
      this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT);
      this._offset = offset || 0;
      var locArrayBuffer = this._arrayBuffer, locOffset = this._offset;
      this._view = new Float32Array(locArrayBuffer, locOffset, 3);
      this._view[0] = x || 0;
      this._view[1] = y || 0;
      this._view[2] = z || 0;
    };
    cc.Vertex3F.BYTES_PER_ELEMENT = 12;
    _p = cc.Vertex3F.prototype;
    _p._getX = function() {
      return this._view[0];
    };
    _p._setX = function(xValue) {
      this._view[0] = xValue;
    };
    _p._getY = function() {
      return this._view[1];
    };
    _p._setY = function(yValue) {
      this._view[1] = yValue;
    };
    _p._getZ = function() {
      return this._view[2];
    };
    _p._setZ = function(zValue) {
      this._view[2] = zValue;
    };
    cc.js.getset(_p, "x", _p._getX, _p._setX);
    cc.js.getset(_p, "y", _p._getY, _p._setY);
    cc.js.getset(_p, "z", _p._getZ, _p._setZ);
    cc.Tex2F = function(u, v, arrayBuffer, offset) {
      this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT);
      this._offset = offset || 0;
      this._view = new Float32Array(this._arrayBuffer, this._offset, 2);
      this._view[0] = u || 0;
      this._view[1] = v || 0;
    };
    cc.Tex2F.BYTES_PER_ELEMENT = 8;
    _p = cc.Tex2F.prototype;
    _p._getU = function() {
      return this._view[0];
    };
    _p._setU = function(xValue) {
      this._view[0] = xValue;
    };
    _p._getV = function() {
      return this._view[1];
    };
    _p._setV = function(yValue) {
      this._view[1] = yValue;
    };
    cc.js.getset(_p, "u", _p._getU, _p._setU);
    cc.js.getset(_p, "v", _p._getV, _p._setV);
    cc.Quad2 = function(tl, tr, bl, br, arrayBuffer, offset) {
      this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT);
      this._offset = offset || 0;
      var locArrayBuffer = this._arrayBuffer, locOffset = this._offset, locElementLen = cc.Vertex2F.BYTES_PER_ELEMENT;
      this._tl = tl ? new cc.Vertex2F(tl.x, tl.y, locArrayBuffer, locOffset) : new cc.Vertex2F(0, 0, locArrayBuffer, locOffset);
      locOffset += locElementLen;
      this._tr = tr ? new cc.Vertex2F(tr.x, tr.y, locArrayBuffer, locOffset) : new cc.Vertex2F(0, 0, locArrayBuffer, locOffset);
      locOffset += locElementLen;
      this._bl = bl ? new cc.Vertex2F(bl.x, bl.y, locArrayBuffer, locOffset) : new cc.Vertex2F(0, 0, locArrayBuffer, locOffset);
      locOffset += locElementLen;
      this._br = br ? new cc.Vertex2F(br.x, br.y, locArrayBuffer, locOffset) : new cc.Vertex2F(0, 0, locArrayBuffer, locOffset);
    };
    cc.Quad2.BYTES_PER_ELEMENT = 32;
    _p = cc.Quad2.prototype;
    _p._getTL = function() {
      return this._tl;
    };
    _p._setTL = function(tlValue) {
      this._tl._view[0] = tlValue.x;
      this._tl._view[1] = tlValue.y;
    };
    _p._getTR = function() {
      return this._tr;
    };
    _p._setTR = function(trValue) {
      this._tr._view[0] = trValue.x;
      this._tr._view[1] = trValue.y;
    };
    _p._getBL = function() {
      return this._bl;
    };
    _p._setBL = function(blValue) {
      this._bl._view[0] = blValue.x;
      this._bl._view[1] = blValue.y;
    };
    _p._getBR = function() {
      return this._br;
    };
    _p._setBR = function(brValue) {
      this._br._view[0] = brValue.x;
      this._br._view[1] = brValue.y;
    };
    cc.js.getset(_p, "tl", _p._getTL, _p._setTL);
    cc.js.getset(_p, "tr", _p._getTR, _p._setTR);
    cc.js.getset(_p, "bl", _p._getBL, _p._setBL);
    cc.js.getset(_p, "br", _p._getBR, _p._setBR);
    cc.Quad3 = function(bl1, br1, tl1, tr1, arrayBuffer, offset) {
      this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Quad3.BYTES_PER_ELEMENT);
      this._offset = offset || 0;
      var locArrayBuffer = this._arrayBuffer, locOffset = this._offset, locElementLen = cc.Vertex3F.BYTES_PER_ELEMENT;
      this.bl = bl ? new cc.Vertex3F(bl.x, bl.y, bl.z, locArrayBuffer, locOffset) : new cc.Vertex3F(0, 0, 0, locArrayBuffer, locOffset);
      locOffset += locElementLen;
      this.br = br ? new cc.Vertex3F(br.x, br.y, br.z, locArrayBuffer, locOffset) : new cc.Vertex3F(0, 0, 0, locArrayBuffer, locOffset);
      locOffset += locElementLen;
      this.tl = tl ? new cc.Vertex3F(tl.x, tl.y, tl.z, locArrayBuffer, locOffset) : new cc.Vertex3F(0, 0, 0, locArrayBuffer, locOffset);
      locOffset += locElementLen;
      this.tr = tr ? new cc.Vertex3F(tr.x, tr.y, tr.z, locArrayBuffer, locOffset) : new cc.Vertex3F(0, 0, 0, locArrayBuffer, locOffset);
    };
    cc.Quad3.BYTES_PER_ELEMENT = 48;
    cc.V3F_C4B_T2F = function(vertices, colors, texCoords, arrayBuffer, offset) {
      this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
      this._offset = offset || 0;
      var locArrayBuffer = this._arrayBuffer, locOffset = this._offset;
      this._vertices = vertices ? new cc.Vertex3F(vertices.x, vertices.y, vertices.z, locArrayBuffer, locOffset) : new cc.Vertex3F(0, 0, 0, locArrayBuffer, locOffset);
      locOffset += cc.Vertex3F.BYTES_PER_ELEMENT;
      this._colors = colors ? new cc.WebGLColor(colors.r, colors.g, colors.b, colors.a, locArrayBuffer, locOffset) : new cc.WebGLColor(0, 0, 0, 0, locArrayBuffer, locOffset);
      locOffset += cc.WebGLColor.BYTES_PER_ELEMENT;
      this._texCoords = texCoords ? new cc.Tex2F(texCoords.u, texCoords.v, locArrayBuffer, locOffset) : new cc.Tex2F(0, 0, locArrayBuffer, locOffset);
    };
    cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24;
    _p = cc.V3F_C4B_T2F.prototype;
    _p._getVertices = function() {
      return this._vertices;
    };
    _p._setVertices = function(verticesValue) {
      var locVertices = this._vertices;
      locVertices._view[0] = verticesValue.x;
      locVertices._view[1] = verticesValue.y;
      locVertices._view[2] = verticesValue.z;
    };
    _p._getColor = function() {
      return this._colors;
    };
    _p._setColor = function(colorValue) {
      var locColors = this._colors;
      locColors._view[0] = colorValue.r;
      locColors._view[1] = colorValue.g;
      locColors._view[2] = colorValue.b;
      locColors._view[3] = colorValue.a;
    };
    _p._getTexCoords = function() {
      return this._texCoords;
    };
    _p._setTexCoords = function(texValue) {
      this._texCoords._view[0] = texValue.u;
      this._texCoords._view[1] = texValue.v;
    };
    cc.js.getset(_p, "vertices", _p._getVertices, _p._setVertices);
    cc.js.getset(_p, "colors", _p._getColor, _p._setColor);
    cc.js.getset(_p, "texCoords", _p._getTexCoords, _p._setTexCoords);
    cc.V3F_C4B_T2F_Quad = function(tl, bl, tr, br, arrayBuffer, offset) {
      this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
      this._offset = offset || 0;
      var locArrayBuffer = this._arrayBuffer, locOffset = this._offset, locElementLen = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
      this._tl = tl ? new cc.V3F_C4B_T2F(tl.vertices, tl.colors, tl.texCoords, locArrayBuffer, locOffset) : new cc.V3F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
      locOffset += locElementLen;
      this._bl = bl ? new cc.V3F_C4B_T2F(bl.vertices, bl.colors, bl.texCoords, locArrayBuffer, locOffset) : new cc.V3F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
      locOffset += locElementLen;
      this._tr = tr ? new cc.V3F_C4B_T2F(tr.vertices, tr.colors, tr.texCoords, locArrayBuffer, locOffset) : new cc.V3F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
      locOffset += locElementLen;
      this._br = br ? new cc.V3F_C4B_T2F(br.vertices, br.colors, br.texCoords, locArrayBuffer, locOffset) : new cc.V3F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
    };
    cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96;
    _p = cc.V3F_C4B_T2F_Quad.prototype;
    _p._getTL = function() {
      return this._tl;
    };
    _p._setTL = function(tlValue) {
      var locTl = this._tl;
      locTl.vertices = tlValue.vertices;
      locTl.colors = tlValue.colors;
      locTl.texCoords = tlValue.texCoords;
    };
    _p._getBL = function() {
      return this._bl;
    };
    _p._setBL = function(blValue) {
      var locBl = this._bl;
      locBl.vertices = blValue.vertices;
      locBl.colors = blValue.colors;
      locBl.texCoords = blValue.texCoords;
    };
    _p._getTR = function() {
      return this._tr;
    };
    _p._setTR = function(trValue) {
      var locTr = this._tr;
      locTr.vertices = trValue.vertices;
      locTr.colors = trValue.colors;
      locTr.texCoords = trValue.texCoords;
    };
    _p._getBR = function() {
      return this._br;
    };
    _p._setBR = function(brValue) {
      var locBr = this._br;
      locBr.vertices = brValue.vertices;
      locBr.colors = brValue.colors;
      locBr.texCoords = brValue.texCoords;
    };
    _p._getArrayBuffer = function() {
      return this._arrayBuffer;
    };
    cc.js.getset(_p, "tl", _p._getTL, _p._setTL);
    cc.js.getset(_p, "tr", _p._getTR, _p._setTR);
    cc.js.getset(_p, "bl", _p._getBL, _p._setBL);
    cc.js.getset(_p, "br", _p._getBR, _p._setBR);
    cc.js.get(_p, "arrayBuffer", _p._getArrayBuffer);
    cc.V3F_C4B_T2F_QuadZero = function() {
      return new cc.V3F_C4B_T2F_Quad();
    };
    cc.V3F_C4B_T2F_QuadCopy = function(sourceQuad) {
      if (!sourceQuad) return cc.V3F_C4B_T2F_QuadZero();
      var srcTL = sourceQuad.tl, srcBL = sourceQuad.bl, srcTR = sourceQuad.tr, srcBR = sourceQuad.br;
      return {
        tl: {
          vertices: {
            x: srcTL.vertices.x,
            y: srcTL.vertices.y,
            z: srcTL.vertices.z
          },
          colors: {
            r: srcTL.colors.r,
            g: srcTL.colors.g,
            b: srcTL.colors.b,
            a: srcTL.colors.a
          },
          texCoords: {
            u: srcTL.texCoords.u,
            v: srcTL.texCoords.v
          }
        },
        bl: {
          vertices: {
            x: srcBL.vertices.x,
            y: srcBL.vertices.y,
            z: srcBL.vertices.z
          },
          colors: {
            r: srcBL.colors.r,
            g: srcBL.colors.g,
            b: srcBL.colors.b,
            a: srcBL.colors.a
          },
          texCoords: {
            u: srcBL.texCoords.u,
            v: srcBL.texCoords.v
          }
        },
        tr: {
          vertices: {
            x: srcTR.vertices.x,
            y: srcTR.vertices.y,
            z: srcTR.vertices.z
          },
          colors: {
            r: srcTR.colors.r,
            g: srcTR.colors.g,
            b: srcTR.colors.b,
            a: srcTR.colors.a
          },
          texCoords: {
            u: srcTR.texCoords.u,
            v: srcTR.texCoords.v
          }
        },
        br: {
          vertices: {
            x: srcBR.vertices.x,
            y: srcBR.vertices.y,
            z: srcBR.vertices.z
          },
          colors: {
            r: srcBR.colors.r,
            g: srcBR.colors.g,
            b: srcBR.colors.b,
            a: srcBR.colors.a
          },
          texCoords: {
            u: srcBR.texCoords.u,
            v: srcBR.texCoords.v
          }
        }
      };
    };
    cc.V3F_C4B_T2F_QuadsCopy = function(sourceQuads) {
      if (!sourceQuads) return [];
      var retArr = [];
      for (var i = 0; i < sourceQuads.length; i++) retArr.push(cc.V3F_C4B_T2F_QuadCopy(sourceQuads[i]));
      return retArr;
    };
    cc.V2F_C4B_T2F = function(vertices, colors, texCoords, arrayBuffer, offset) {
      this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
      this._offset = offset || 0;
      var locArrayBuffer = this._arrayBuffer, locOffset = this._offset;
      this._vertices = vertices ? new cc.Vertex2F(vertices.x, vertices.y, locArrayBuffer, locOffset) : new cc.Vertex2F(0, 0, locArrayBuffer, locOffset);
      locOffset += cc.Vertex2F.BYTES_PER_ELEMENT;
      this._colors = colors ? new cc.WebGLColor(colors.r, colors.g, colors.b, colors.a, locArrayBuffer, locOffset) : new cc.WebGLColor(0, 0, 0, 0, locArrayBuffer, locOffset);
      locOffset += cc.WebGLColor.BYTES_PER_ELEMENT;
      this._texCoords = texCoords ? new cc.Tex2F(texCoords.u, texCoords.v, locArrayBuffer, locOffset) : new cc.Tex2F(0, 0, locArrayBuffer, locOffset);
    };
    cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20;
    _p = cc.V2F_C4B_T2F.prototype;
    _p._getVertices = function() {
      return this._vertices;
    };
    _p._setVertices = function(verticesValue) {
      this._vertices._view[0] = verticesValue.x;
      this._vertices._view[1] = verticesValue.y;
    };
    _p._getColor = function() {
      return this._colors;
    };
    _p._setColor = function(colorValue) {
      var locColors = this._colors;
      locColors._view[0] = colorValue.r;
      locColors._view[1] = colorValue.g;
      locColors._view[2] = colorValue.b;
      locColors._view[3] = colorValue.a;
    };
    _p._getTexCoords = function() {
      return this._texCoords;
    };
    _p._setTexCoords = function(texValue) {
      this._texCoords._view[0] = texValue.u;
      this._texCoords._view[1] = texValue.v;
    };
    cc.js.getset(_p, "vertices", _p._getVertices, _p._setVertices);
    cc.js.getset(_p, "colors", _p._getColor, _p._setColor);
    cc.js.getset(_p, "texCoords", _p._getTexCoords, _p._setTexCoords);
    cc.V2F_C4B_T2F_Triangle = function(a, b, c, arrayBuffer, offset) {
      this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT);
      this._offset = offset || 0;
      var locArrayBuffer = this._arrayBuffer, locOffset = this._offset, locElementLen = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
      this._a = a ? new cc.V2F_C4B_T2F(a.vertices, a.colors, a.texCoords, locArrayBuffer, locOffset) : new cc.V2F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
      locOffset += locElementLen;
      this._b = b ? new cc.V2F_C4B_T2F(b.vertices, b.colors, b.texCoords, locArrayBuffer, locOffset) : new cc.V2F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
      locOffset += locElementLen;
      this._c = c ? new cc.V2F_C4B_T2F(c.vertices, c.colors, c.texCoords, locArrayBuffer, locOffset) : new cc.V2F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
    };
    cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60;
    _p = cc.V2F_C4B_T2F_Triangle.prototype;
    _p._getA = function() {
      return this._a;
    };
    _p._setA = function(aValue) {
      var locA = this._a;
      locA.vertices = aValue.vertices;
      locA.colors = aValue.colors;
      locA.texCoords = aValue.texCoords;
    };
    _p._getB = function() {
      return this._b;
    };
    _p._setB = function(bValue) {
      var locB = this._b;
      locB.vertices = bValue.vertices;
      locB.colors = bValue.colors;
      locB.texCoords = bValue.texCoords;
    };
    _p._getC = function() {
      return this._c;
    };
    _p._setC = function(cValue) {
      var locC = this._c;
      locC.vertices = cValue.vertices;
      locC.colors = cValue.colors;
      locC.texCoords = cValue.texCoords;
    };
    cc.js.getset(_p, "a", _p._getA, _p._setA);
    cc.js.getset(_p, "b", _p._getB, _p._setB);
    cc.js.getset(_p, "c", _p._getC, _p._setC);
  }), {} ],
  148: [ (function(require, module, exports) {
    var JS = require("../platform/js");
    function ValueType() {}
    JS.setClassName("cc.ValueType", ValueType);
    var proto = ValueType.prototype;
    false;
    proto.toString = function() {
      return "" + {};
    };
    cc.ValueType = module.exports = ValueType;
  }), {
    "../platform/js": 109
  } ],
  149: [ (function(require, module, exports) {
    var ValueType = require("./CCValueType");
    var JS = require("../platform/js");
    var CCClass = require("../platform/CCClass");
    function Vec2(x, y) {
      if (x && "object" === typeof x) {
        y = x.y;
        x = x.x;
      }
      this.x = x || 0;
      this.y = y || 0;
    }
    JS.extend(Vec2, ValueType);
    CCClass.fastDefine("cc.Vec2", Vec2, {
      x: 0,
      y: 0
    });
    var proto = Vec2.prototype;
    proto.clone = function() {
      return new Vec2(this.x, this.y);
    };
    proto.set = function(newValue) {
      this.x = newValue.x;
      this.y = newValue.y;
      return this;
    };
    proto.equals = function(other) {
      return other && this.x === other.x && this.y === other.y;
    };
    proto.toString = function() {
      return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ")";
    };
    proto.lerp = function(to, ratio, out) {
      out = out || new Vec2();
      var x = this.x;
      var y = this.y;
      out.x = x + (to.x - x) * ratio;
      out.y = y + (to.y - y) * ratio;
      return out;
    };
    proto.addSelf = function(vector) {
      this.x += vector.x;
      this.y += vector.y;
      return this;
    };
    proto.add = function(vector, out) {
      out = out || new Vec2();
      out.x = this.x + vector.x;
      out.y = this.y + vector.y;
      return out;
    };
    proto.subSelf = function(vector) {
      this.x -= vector.x;
      this.y -= vector.y;
      return this;
    };
    proto.sub = function(vector, out) {
      out = out || new Vec2();
      out.x = this.x - vector.x;
      out.y = this.y - vector.y;
      return out;
    };
    proto.mulSelf = function(num) {
      this.x *= num;
      this.y *= num;
      return this;
    };
    proto.mul = function(num, out) {
      out = out || new Vec2();
      out.x = this.x * num;
      out.y = this.y * num;
      return out;
    };
    proto.scaleSelf = function(vector) {
      this.x *= vector.x;
      this.y *= vector.y;
      return this;
    };
    proto.scale = function(vector, out) {
      out = out || new Vec2();
      out.x = this.x * vector.x;
      out.y = this.y * vector.y;
      return out;
    };
    proto.divSelf = function(num) {
      this.x /= num;
      this.y /= num;
      return this;
    };
    proto.div = function(num, out) {
      out = out || new Vec2();
      out.x = this.x / num;
      out.y = this.y / num;
      return out;
    };
    proto.negSelf = function() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    };
    proto.neg = function(out) {
      out = out || new Vec2();
      out.x = -this.x;
      out.y = -this.y;
      return out;
    };
    proto.dot = function(vector) {
      return this.x * vector.x + this.y * vector.y;
    };
    proto.cross = function(vector) {
      return this.y * vector.x - this.x * vector.y;
    };
    proto.mag = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };
    proto.magSqr = function() {
      return this.x * this.x + this.y * this.y;
    };
    proto.normalizeSelf = function() {
      var magSqr = this.x * this.x + this.y * this.y;
      if (1 === magSqr) return this;
      if (0 === magSqr) {
        console.warn("Can't normalize zero vector");
        return this;
      }
      var invsqrt = 1 / Math.sqrt(magSqr);
      this.x *= invsqrt;
      this.y *= invsqrt;
      return this;
    };
    proto.normalize = function(out) {
      out = out || new Vec2();
      out.x = this.x;
      out.y = this.y;
      out.normalizeSelf();
      return out;
    };
    proto.angle = function(vector) {
      var magSqr1 = this.magSqr();
      var magSqr2 = vector.magSqr();
      if (0 === magSqr1 || 0 === magSqr2) {
        console.warn("Can't get angle between zero vector");
        return 0;
      }
      var dot = this.dot(vector);
      var theta = dot / Math.sqrt(magSqr1 * magSqr2);
      theta = cc.clampf(theta, -1, 1);
      return Math.acos(theta);
    };
    proto.signAngle = function(vector) {
      return Math.atan2(this.y, this.x) - Math.atan2(vector.y, vector.x);
    };
    proto.rotate = function(radians, out) {
      out = out || new Vec2();
      out.x = this.x;
      out.y = this.y;
      return out.rotateSelf(radians);
    };
    proto.rotateSelf = function(radians) {
      var sin = Math.sin(radians);
      var cos = Math.cos(radians);
      var x = this.x;
      this.x = cos * x - sin * this.y;
      this.y = sin * x + cos * this.y;
      return this;
    };
    JS.get(Vec2, "ONE", (function() {
      return new Vec2(1, 1);
    }));
    JS.get(Vec2, "ZERO", (function() {
      return new Vec2(0, 0);
    }));
    JS.get(Vec2, "UP", (function() {
      return new Vec2(0, 1);
    }));
    JS.get(Vec2, "RIGHT", (function() {
      return new Vec2(1, 0);
    }));
    cc.Vec2 = Vec2;
    cc.v2 = function v2(x, y) {
      return new Vec2(x, y);
    };
    cc.p = cc.v2;
    cc.pointEqualToPoint = function(point1, point2) {
      return point1 && point2 && point1.x === point2.x && point1.y === point2.y;
    };
    module.exports = cc.Vec2;
  }), {
    "../platform/CCClass": 89,
    "../platform/js": 109,
    "./CCValueType": 148
  } ],
  150: [ (function(require, module, exports) {
    require("./CCValueType");
    require("./CCVec2");
    require("./CCPointExtension");
    require("./CCSize");
    require("./CCRect");
    require("./CCColor");
    require("./CCTypes");
    require("./CCAffineTransform");
    require("./CCTypesWebGL");
  }), {
    "./CCAffineTransform": 141,
    "./CCColor": 142,
    "./CCPointExtension": 143,
    "./CCRect": 144,
    "./CCSize": 145,
    "./CCTypes": 146,
    "./CCTypesWebGL": 147,
    "./CCValueType": 148,
    "./CCVec2": 149
  } ],
  151: [ (function(require, module, exports) {
    var js = cc.js;
    var deprecateEnum;
    var markAsRemoved;
    var provideClearError;
    var shouldNotUseNodeProp;
    var ERR;
    false;
  }), {} ],
  152: [ (function(require, module, exports) {
    require("./core/CCGame");
    require("./actions");
    require("./core/base-nodes/CCSGNode");
    require("./core/base-nodes/CCSGNodeBaseRenderCmd");
    require("./core/base-nodes/CCSGNodeCanvasRenderCmd");
    require("./core/base-nodes/CCSGNodeWebGLRenderCmd");
    require("./core/scenes/CCSGScene");
    require("./core/CCConfiguration");
    require("./core/sprites/CCSGSprite");
    require("./core/sprites/CCSGSpriteCanvasRenderCmd");
    require("./core/sprites/CCSGSpriteWebGLRenderCmd");
    require("./core/sprites/CCScale9Sprite");
    require("./core/sprites/CCScale9SpriteCanvasRenderCmd");
    require("./core/sprites/CCScale9SpriteWebGLRenderCmd");
    require("./core/sprites/CCSpriteBatchNode");
    require("./render-texture/CCRenderTexture");
    require("./render-texture/CCRenderTextureCanvasRenderCmd");
    require("./render-texture/CCRenderTextureWebGLRenderCmd");
  }), {
    "./actions": 179,
    "./core/CCConfiguration": 7,
    "./core/CCGame": 14,
    "./core/base-nodes/CCSGNode": 32,
    "./core/base-nodes/CCSGNodeBaseRenderCmd": 33,
    "./core/base-nodes/CCSGNodeCanvasRenderCmd": 34,
    "./core/base-nodes/CCSGNodeWebGLRenderCmd": 35,
    "./core/scenes/CCSGScene": 119,
    "./core/sprites/CCSGSprite": 120,
    "./core/sprites/CCSGSpriteCanvasRenderCmd": 121,
    "./core/sprites/CCSGSpriteWebGLRenderCmd": 122,
    "./core/sprites/CCScale9Sprite": 123,
    "./core/sprites/CCScale9SpriteCanvasRenderCmd": 124,
    "./core/sprites/CCScale9SpriteWebGLRenderCmd": 125,
    "./core/sprites/CCSpriteBatchNode": 126,
    "./render-texture/CCRenderTexture": 179,
    "./render-texture/CCRenderTextureCanvasRenderCmd": 179,
    "./render-texture/CCRenderTextureWebGLRenderCmd": 179
  } ],
  153: [ (function(require, module, exports) {
    cc.math.AABB = function(min, max) {
      this.min = min || new cc.math.Vec3();
      this.max = max || new cc.math.Vec3();
    };
    cc.math.AABB.prototype.containsPoint = function(point) {
      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
    };
    cc.math.AABB.containsPoint = function(pPoint, pBox) {
      return pPoint.x >= pBox.min.x && pPoint.x <= pBox.max.x && pPoint.y >= pBox.min.y && pPoint.y <= pBox.max.y && pPoint.z >= pBox.min.z && pPoint.z <= pBox.max.z;
    };
    cc.math.AABB.prototype.assignFrom = function(aabb) {
      this.min.assignFrom(aabb.min);
      this.max.assignFrom(aabb.max);
    };
    cc.math.AABB.assign = function(pOut, pIn) {
      pOut.min.assignFrom(pIn.min);
      pOut.max.assignFrom(pIn.max);
      return pOut;
    };
  }), {} ],
  154: [ (function(require, module, exports) {
    cc.math.Matrix4Stack = function(top, stack) {
      this.top = top;
      this.stack = stack || [];
      this.lastUpdated = 0;
    };
    var proto = cc.math.Matrix4Stack.prototype;
    proto.initialize = function() {
      this.stack.length = 0;
      this.top = null;
    };
    proto.push = function(item) {
      item = item || this.top;
      this.stack.push(this.top);
      this.top = new cc.math.Matrix4(item);
      this.update();
    };
    proto.pop = function() {
      this.top = this.stack.pop();
      this.update();
    };
    proto.update = function() {
      this.lastUpdated++;
    };
    proto.release = function() {
      this.stack = null;
      this.top = null;
      this._matrixPool = null;
    };
    proto._getFromPool = function(item) {
      var pool = this._matrixPool;
      if (0 === pool.length) return new cc.math.Matrix4(item);
      var ret = pool.pop();
      ret.assignFrom(item);
      return ret;
    };
    proto._putInPool = function(matrix) {
      this._matrixPool.push(matrix);
    };
  }), {} ],
  155: [ (function(require, module, exports) {
    var math = cc.math;
    math.KM_GL_MODELVIEW = 5888;
    math.KM_GL_PROJECTION = 5889;
    math.KM_GL_TEXTURE = 5890;
    math.modelview_matrix_stack = new math.Matrix4Stack();
    math.projection_matrix_stack = new math.Matrix4Stack();
    math.texture_matrix_stack = new math.Matrix4Stack();
    cc.current_stack = null;
    var initialized = false;
    var lazyInitialize = function() {
      if (!initialized) {
        var identity = new math.Matrix4();
        math.modelview_matrix_stack.initialize();
        math.projection_matrix_stack.initialize();
        math.texture_matrix_stack.initialize();
        cc.current_stack = math.modelview_matrix_stack;
        initialized = true;
        identity.identity();
        math.modelview_matrix_stack.push(identity);
        math.projection_matrix_stack.push(identity);
        math.texture_matrix_stack.push(identity);
      }
    };
    lazyInitialize();
    math.glFreeAll = function() {
      math.modelview_matrix_stack.release();
      math.modelview_matrix_stack = null;
      math.projection_matrix_stack.release();
      math.projection_matrix_stack = null;
      math.texture_matrix_stack.release();
      math.texture_matrix_stack = null;
      initialized = false;
      cc.current_stack = null;
    };
    math.glPushMatrix = function() {
      cc.current_stack.push(cc.current_stack.top);
      cc.current_stack.update();
    };
    math.glPushMatrixWitMat4 = function(saveMat) {
      cc.current_stack.stack.push(cc.current_stack.top);
      saveMat.assignFrom(cc.current_stack.top);
      cc.current_stack.top = saveMat;
      cc.current_stack.update();
    };
    math.glPopMatrix = function() {
      cc.current_stack.top = cc.current_stack.stack.pop();
      cc.current_stack.update();
    };
    math.glMatrixMode = function(mode) {
      switch (mode) {
       case math.KM_GL_MODELVIEW:
        cc.current_stack = math.modelview_matrix_stack;
        break;

       case math.KM_GL_PROJECTION:
        cc.current_stack = math.projection_matrix_stack;
        break;

       case math.KM_GL_TEXTURE:
        cc.current_stack = math.texture_matrix_stack;
        break;

       default:
        throw new Error(cc._getError(7908));
      }
    };
    math.glLoadIdentity = function() {
      cc.current_stack.top.identity();
      cc.current_stack.update();
    };
    math.glLoadMatrix = function(pIn) {
      cc.current_stack.top.assignFrom(pIn);
      cc.current_stack.update();
    };
    math.glMultMatrix = function(pIn) {
      cc.current_stack.top.multiply(pIn);
      cc.current_stack.update();
    };
    var tempMatrix = new math.Matrix4();
    math.glTranslatef = function(x, y, z) {
      var translation = math.Matrix4.createByTranslation(x, y, z, tempMatrix);
      cc.current_stack.top.multiply(translation);
      cc.current_stack.update();
    };
    var tempVector3 = new math.Vec3();
    math.glRotatef = function(angle, x, y, z) {
      tempVector3.fill(x, y, z);
      var rotation = math.Matrix4.createByAxisAndAngle(tempVector3, cc.degreesToRadians(angle), tempMatrix);
      cc.current_stack.top.multiply(rotation);
      cc.current_stack.update();
    };
    math.glScalef = function(x, y, z) {
      var scaling = math.Matrix4.createByScale(x, y, z, tempMatrix);
      cc.current_stack.top.multiply(scaling);
      cc.current_stack.update();
    };
    math.glGetMatrix = function(mode, pOut) {
      switch (mode) {
       case math.KM_GL_MODELVIEW:
        pOut.assignFrom(math.modelview_matrix_stack.top);
        break;

       case math.KM_GL_PROJECTION:
        pOut.assignFrom(math.projection_matrix_stack.top);
        break;

       case math.KM_GL_TEXTURE:
        pOut.assignFrom(math.texture_matrix_stack.top);
        break;

       default:
        throw new Error(cc._getError(7908));
      }
    };
  }), {} ],
  156: [ (function(require, module, exports) {
    require("./utility");
    require("./vec2");
    require("./vec3");
    require("./vec4");
    require("./ray2");
    require("./mat3");
    require("./mat4");
    require("./plane");
    require("./quaternion");
    require("./aabb");
    require("./gl/mat4stack");
    require("./gl/matrix");
  }), {
    "./aabb": 153,
    "./gl/mat4stack": 154,
    "./gl/matrix": 155,
    "./mat3": 157,
    "./mat4": 158,
    "./plane": 159,
    "./quaternion": 160,
    "./ray2": 161,
    "./utility": 162,
    "./vec2": 163,
    "./vec3": 164,
    "./vec4": 165
  } ],
  157: [ (function(require, module, exports) {
    true;
    window.Uint16Array = window.Uint16Array || window.Array;
    window.Float32Array = window.Float32Array || window.Array;
    cc.math.Matrix3 = function(mat3) {
      mat3 && mat3.mat ? this.mat = new Float32Array(mat3.mat) : this.mat = new Float32Array(9);
    };
    var proto = cc.math.Matrix3.prototype;
    proto.fill = function(mat3) {
      var mat = this.mat, matIn = mat3.mat;
      mat[0] = matIn[0];
      mat[1] = matIn[1];
      mat[2] = matIn[2];
      mat[3] = matIn[3];
      mat[4] = matIn[4];
      mat[5] = matIn[5];
      mat[6] = matIn[6];
      mat[7] = matIn[7];
      mat[8] = matIn[8];
      return this;
    };
    proto.adjugate = function() {
      var mat = this.mat;
      var m0 = mat[0], m1 = mat[1], m2 = mat[2], m3 = mat[3], m4 = mat[4], m5 = mat[5], m6 = mat[6], m7 = mat[7], m8 = mat[8];
      mat[0] = m4 * m8 - m5 * m7;
      mat[1] = m2 * m7 - m1 * m8;
      mat[2] = m1 * m5 - m2 * m4;
      mat[3] = m5 * m6 - m3 * m8;
      mat[4] = m0 * m8 - m2 * m6;
      mat[5] = m2 * m3 - m0 * m5;
      mat[6] = m3 * m7 - m4 * m6;
      mat[8] = m0 * m4 - m1 * m3;
      return this;
    };
    proto.identity = function() {
      var mat = this.mat;
      mat[1] = mat[2] = mat[3] = mat[5] = mat[6] = mat[7] = 0;
      mat[0] = mat[4] = mat[8] = 1;
      return this;
    };
    var tmpMatrix = new cc.math.Matrix3();
    proto.inverse = function(determinate) {
      if (0 === determinate) return this;
      tmpMatrix.assignFrom(this);
      var detInv = 1 / determinate;
      this.adjugate();
      this.multiplyScalar(detInv);
      return this;
    };
    proto.isIdentity = function() {
      var mat = this.mat;
      return 1 === mat[0] && 0 === mat[1] && 0 === mat[2] && 0 === mat[3] && 1 === mat[4] && 0 === mat[5] && 0 === mat[6] && 0 === mat[7] && 1 === mat[8];
    };
    proto.transpose = function() {
      var mat = this.mat;
      var m1 = mat[1], m2 = mat[2], m3 = mat[3], m5 = mat[5], m6 = mat[6], m7 = mat[7];
      mat[1] = m3;
      mat[2] = m6;
      mat[3] = m1;
      mat[5] = m7;
      mat[6] = m2;
      mat[7] = m5;
      return this;
    };
    proto.determinant = function() {
      var mat = this.mat;
      var output = mat[0] * mat[4] * mat[8] + mat[1] * mat[5] * mat[6] + mat[2] * mat[3] * mat[7];
      output -= mat[2] * mat[4] * mat[6] + mat[0] * mat[5] * mat[7] + mat[1] * mat[3] * mat[8];
      return output;
    };
    proto.multiply = function(mat3) {
      var m1 = this.mat, m2 = mat3.mat;
      var a0 = m1[0], a1 = m1[1], a2 = m1[2], a3 = m1[3], a4 = m1[4], a5 = m1[5], a6 = m1[6], a7 = m1[7], a8 = m1[8];
      var b0 = m2[0], b1 = m2[1], b2 = m2[2], b3 = m2[3], b4 = m2[4], b5 = m2[5], b6 = m2[6], b7 = m2[7], b8 = m2[8];
      m1[0] = a0 * b0 + a3 * b1 + a6 * b2;
      m1[1] = a1 * b0 + a4 * b1 + a7 * b2;
      m1[2] = a2 * b0 + a5 * b1 + a8 * b2;
      m1[3] = a2 * b0 + a5 * b1 + a8 * b2;
      m1[4] = a1 * b3 + a4 * b4 + a7 * b5;
      m1[5] = a2 * b3 + a5 * b4 + a8 * b5;
      m1[6] = a0 * b6 + a3 * b7 + a6 * b8;
      m1[7] = a1 * b6 + a4 * b7 + a7 * b8;
      m1[8] = a2 * b6 + a5 * b7 + a8 * b8;
      return this;
    };
    proto.multiplyScalar = function(factor) {
      var mat = this.mat;
      mat[0] *= factor;
      mat[1] *= factor;
      mat[2] *= factor;
      mat[3] *= factor;
      mat[4] *= factor;
      mat[5] *= factor;
      mat[6] *= factor;
      mat[7] *= factor;
      mat[8] *= factor;
      return this;
    };
    cc.math.Matrix3.rotationAxisAngle = function(axis, radians) {
      var rcos = Math.cos(radians), rsin = Math.sin(radians);
      var retMat = new cc.math.Matrix3();
      var mat = retMat.mat;
      mat[0] = rcos + axis.x * axis.x * (1 - rcos);
      mat[1] = axis.z * rsin + axis.y * axis.x * (1 - rcos);
      mat[2] = -axis.y * rsin + axis.z * axis.x * (1 - rcos);
      mat[3] = -axis.z * rsin + axis.x * axis.y * (1 - rcos);
      mat[4] = rcos + axis.y * axis.y * (1 - rcos);
      mat[5] = axis.x * rsin + axis.z * axis.y * (1 - rcos);
      mat[6] = axis.y * rsin + axis.x * axis.z * (1 - rcos);
      mat[7] = -axis.x * rsin + axis.y * axis.z * (1 - rcos);
      mat[8] = rcos + axis.z * axis.z * (1 - rcos);
      return retMat;
    };
    proto.assignFrom = function(matIn) {
      if (this === matIn) {
        cc.logID(7900);
        return this;
      }
      var mat = this.mat, m2 = matIn.mat;
      mat[0] = m2[0];
      mat[1] = m2[1];
      mat[2] = m2[2];
      mat[3] = m2[3];
      mat[4] = m2[4];
      mat[5] = m2[5];
      mat[6] = m2[6];
      mat[7] = m2[7];
      mat[8] = m2[8];
      return this;
    };
    proto.equals = function(mat3) {
      if (this === mat3) return true;
      var EPSILON = cc.math.EPSILON, m1 = this.mat, m2 = mat3.mat;
      for (var i = 0; i < 9; ++i) if (!(m1[i] + EPSILON > m2[i] && m1[i] - EPSILON < m2[i])) return false;
      return true;
    };
    cc.math.Matrix3.createByRotationX = function(radians) {
      var retMat = new cc.math.Matrix3(), mat = retMat.mat;
      mat[0] = 1;
      mat[1] = 0;
      mat[2] = 0;
      mat[3] = 0;
      mat[4] = Math.cos(radians);
      mat[5] = Math.sin(radians);
      mat[6] = 0;
      mat[7] = -Math.sin(radians);
      mat[8] = Math.cos(radians);
      return retMat;
    };
    cc.math.Matrix3.createByRotationY = function(radians) {
      var retMat = new cc.math.Matrix3(), mat = retMat.mat;
      mat[0] = Math.cos(radians);
      mat[1] = 0;
      mat[2] = -Math.sin(radians);
      mat[3] = 0;
      mat[4] = 1;
      mat[5] = 0;
      mat[6] = Math.sin(radians);
      mat[7] = 0;
      mat[8] = Math.cos(radians);
      return retMat;
    };
    cc.math.Matrix3.createByRotationZ = function(radians) {
      var retMat = new cc.math.Matrix3(), mat = retMat.mat;
      mat[0] = Math.cos(radians);
      mat[1] = -Math.sin(radians);
      mat[2] = 0;
      mat[3] = Math.sin(radians);
      mat[4] = Math.cos(radians);
      mat[5] = 0;
      mat[6] = 0;
      mat[7] = 0;
      mat[8] = 1;
      return retMat;
    };
    cc.math.Matrix3.createByRotation = function(radians) {
      var retMat = new cc.math.Matrix3(), mat = retMat.mat;
      mat[0] = Math.cos(radians);
      mat[1] = Math.sin(radians);
      mat[2] = 0;
      mat[3] = -Math.sin(radians);
      mat[4] = Math.cos(radians);
      mat[5] = 0;
      mat[6] = 0;
      mat[7] = 0;
      mat[8] = 1;
      return retMat;
    };
    cc.math.Matrix3.createByScale = function(x, y) {
      var ret = new cc.math.Matrix3();
      ret.identity();
      ret.mat[0] = x;
      ret.mat[4] = y;
      return ret;
    };
    cc.math.Matrix3.createByTranslation = function(x, y) {
      var ret = new cc.math.Matrix3();
      ret.identity();
      ret.mat[6] = x;
      ret.mat[7] = y;
      return ret;
    };
    cc.math.Matrix3.createByQuaternion = function(quaternion) {
      if (!quaternion) return null;
      var ret = new cc.math.Matrix3(), mat = ret.mat;
      mat[0] = 1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);
      mat[1] = 2 * (quaternion.x * quaternion.y - quaternion.w * quaternion.z);
      mat[2] = 2 * (quaternion.x * quaternion.z + quaternion.w * quaternion.y);
      mat[3] = 2 * (quaternion.x * quaternion.y + quaternion.w * quaternion.z);
      mat[4] = 1 - 2 * (quaternion.x * quaternion.x + quaternion.z * quaternion.z);
      mat[5] = 2 * (quaternion.y * quaternion.z - quaternion.w * quaternion.x);
      mat[6] = 2 * (quaternion.x * quaternion.z - quaternion.w * quaternion.y);
      mat[7] = 2 * (quaternion.y * quaternion.z + quaternion.w * quaternion.x);
      mat[8] = 1 - 2 * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);
      return ret;
    };
    proto.rotationToAxisAngle = function() {
      return cc.math.Quaternion.rotationMatrix(this).toAxisAndAngle();
    };
  }), {} ],
  158: [ (function(require, module, exports) {
    cc.math.Matrix4 = function(mat4) {
      mat4 && mat4.mat ? this.mat = new Float32Array(mat4.mat) : this.mat = new Float32Array(16);
    };
    var proto = cc.math.Matrix4.prototype;
    proto.fill = function(scalarArr) {
      var mat = this.mat;
      for (var i = 0; i < 16; i++) mat[i] = scalarArr[i];
      return this;
    };
    cc.math.mat4Identity = function(pOut) {
      var mat = pOut.mat;
      mat[1] = mat[2] = mat[3] = mat[4] = mat[6] = mat[7] = mat[8] = mat[9] = mat[11] = mat[12] = mat[13] = mat[14] = 0;
      mat[0] = mat[5] = mat[10] = mat[15] = 1;
      return pOut;
    };
    proto.identity = function() {
      var mat = this.mat;
      mat[1] = mat[2] = mat[3] = mat[4] = mat[6] = mat[7] = mat[8] = mat[9] = mat[11] = mat[12] = mat[13] = mat[14] = 0;
      mat[0] = mat[5] = mat[10] = mat[15] = 1;
      return this;
    };
    proto.get = function(row, col) {
      return this.mat[row + 4 * col];
    };
    proto.set = function(row, col, value) {
      this.mat[row + 4 * col] = value;
    };
    proto.swap = function(r1, c1, r2, c2) {
      var mat = this.mat, tmp = mat[r1 + 4 * c1];
      mat[r1 + 4 * c1] = mat[r2 + 4 * c2];
      mat[r2 + 4 * c2] = tmp;
    };
    cc.math.Matrix4._gaussj = function(a, b) {
      var i, icol = 0, irow = 0, j, k, l, ll, n = 4, m = 4, selElement;
      var big, dum, pivinv;
      var indxc = [ 0, 0, 0, 0 ], indxr = [ 0, 0, 0, 0 ], ipiv = [ 0, 0, 0, 0 ];
      for (i = 0; i < n; i++) {
        big = 0;
        for (j = 0; j < n; j++) if (1 !== ipiv[j]) for (k = 0; k < n; k++) if (0 === ipiv[k]) {
          selElement = Math.abs(a.get(j, k));
          if (selElement >= big) {
            big = selElement;
            irow = j;
            icol = k;
          }
        }
        ++ipiv[icol];
        if (irow !== icol) {
          for (l = 0; l < n; l++) a.swap(irow, l, icol, l);
          for (l = 0; l < m; l++) b.swap(irow, l, icol, l);
        }
        indxr[i] = irow;
        indxc[i] = icol;
        if (0 === a.get(icol, icol)) return false;
        pivinv = 1 / a.get(icol, icol);
        a.set(icol, icol, 1);
        for (l = 0; l < n; l++) a.set(icol, l, a.get(icol, l) * pivinv);
        for (l = 0; l < m; l++) b.set(icol, l, b.get(icol, l) * pivinv);
        for (ll = 0; ll < n; ll++) if (ll !== icol) {
          dum = a.get(ll, icol);
          a.set(ll, icol, 0);
          for (l = 0; l < n; l++) a.set(ll, l, a.get(ll, l) - a.get(icol, l) * dum);
          for (l = 0; l < m; l++) b.set(ll, l, a.get(ll, l) - b.get(icol, l) * dum);
        }
      }
      for (l = n - 1; l >= 0; l--) if (indxr[l] !== indxc[l]) for (k = 0; k < n; k++) a.swap(k, indxr[l], k, indxc[l]);
      return true;
    };
    var identityMatrix = new cc.math.Matrix4().identity();
    cc.math.mat4Inverse = function(pOut, pM) {
      var inv = new cc.math.Matrix4(pM);
      var tmp = new cc.math.Matrix4(identityMatrix);
      if (false === cc.math.Matrix4._gaussj(inv, tmp)) return null;
      pOut.assignFrom(inv);
      return pOut;
    };
    proto.inverse = function() {
      var inv = new cc.math.Matrix4(this);
      var tmp = new cc.math.Matrix4(identityMatrix);
      if (false === cc.math.Matrix4._gaussj(inv, tmp)) return null;
      return inv;
    };
    proto.isIdentity = function() {
      var mat = this.mat;
      return 1 === mat[0] && 0 === mat[1] && 0 === mat[2] && 0 === mat[3] && 0 === mat[4] && 1 === mat[5] && 0 === mat[6] && 0 === mat[7] && 0 === mat[8] && 0 === mat[9] && 1 === mat[10] && 0 === mat[11] && 0 === mat[12] && 0 === mat[13] && 0 === mat[14] && 1 === mat[15];
    };
    proto.transpose = function() {
      var mat = this.mat;
      var m1 = mat[1], m2 = mat[2], m3 = mat[3], m4 = mat[4], m6 = mat[6], m7 = mat[7], m8 = mat[8], m9 = mat[9], m11 = mat[11], m12 = mat[12], m13 = mat[13], m14 = mat[14];
      mat[1] = m4;
      mat[2] = m8;
      mat[3] = m12;
      mat[4] = m1;
      mat[6] = m9;
      mat[7] = m13;
      mat[8] = m2;
      mat[9] = m6;
      mat[11] = m14;
      mat[12] = m3;
      mat[13] = m7;
      mat[14] = m11;
      return this;
    };
    cc.math.mat4Multiply = function(pOut, pM1, pM2) {
      var outArray = pOut.mat, mat1 = pM1.mat, mat2 = pM2.mat;
      var a00 = mat1[0], a01 = mat1[1], a02 = mat1[2], a03 = mat1[3];
      var a10 = mat1[4], a11 = mat1[5], a12 = mat1[6], a13 = mat1[7];
      var a20 = mat1[8], a21 = mat1[9], a22 = mat1[10], a23 = mat1[11];
      var a30 = mat1[12], a31 = mat1[13], a32 = mat1[14], a33 = mat1[15];
      var b00 = mat2[0], b01 = mat2[1], b02 = mat2[2], b03 = mat2[3];
      var b10 = mat2[4], b11 = mat2[5], b12 = mat2[6], b13 = mat2[7];
      var b20 = mat2[8], b21 = mat2[9], b22 = mat2[10], b23 = mat2[11];
      var b30 = mat2[12], b31 = mat2[13], b32 = mat2[14], b33 = mat2[15];
      outArray[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
      outArray[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
      outArray[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
      outArray[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
      outArray[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
      outArray[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
      outArray[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
      outArray[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
      outArray[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
      outArray[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
      outArray[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
      outArray[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
      outArray[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
      outArray[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
      outArray[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
      outArray[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
      return pOut;
    };
    proto.multiply = function(mat4) {
      var mat = this.mat, mat2 = mat4.mat;
      var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
      var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
      var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
      var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];
      var b00 = mat2[0], b01 = mat2[1], b02 = mat2[2], b03 = mat2[3];
      var b10 = mat2[4], b11 = mat2[5], b12 = mat2[6], b13 = mat2[7];
      var b20 = mat2[8], b21 = mat2[9], b22 = mat2[10], b23 = mat2[11];
      var b30 = mat2[12], b31 = mat2[13], b32 = mat2[14], b33 = mat2[15];
      mat[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
      mat[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
      mat[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
      mat[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
      mat[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
      mat[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
      mat[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
      mat[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
      mat[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
      mat[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
      mat[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
      mat[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
      mat[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
      mat[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
      mat[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
      mat[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
      return this;
    };
    cc.math.getMat4MultiplyValue = function(pM1, pM2) {
      var m1 = pM1.mat, m2 = pM2.mat;
      var mat = new Float32Array(16);
      mat[0] = m1[0] * m2[0] + m1[4] * m2[1] + m1[8] * m2[2] + m1[12] * m2[3];
      mat[1] = m1[1] * m2[0] + m1[5] * m2[1] + m1[9] * m2[2] + m1[13] * m2[3];
      mat[2] = m1[2] * m2[0] + m1[6] * m2[1] + m1[10] * m2[2] + m1[14] * m2[3];
      mat[3] = m1[3] * m2[0] + m1[7] * m2[1] + m1[11] * m2[2] + m1[15] * m2[3];
      mat[4] = m1[0] * m2[4] + m1[4] * m2[5] + m1[8] * m2[6] + m1[12] * m2[7];
      mat[5] = m1[1] * m2[4] + m1[5] * m2[5] + m1[9] * m2[6] + m1[13] * m2[7];
      mat[6] = m1[2] * m2[4] + m1[6] * m2[5] + m1[10] * m2[6] + m1[14] * m2[7];
      mat[7] = m1[3] * m2[4] + m1[7] * m2[5] + m1[11] * m2[6] + m1[15] * m2[7];
      mat[8] = m1[0] * m2[8] + m1[4] * m2[9] + m1[8] * m2[10] + m1[12] * m2[11];
      mat[9] = m1[1] * m2[8] + m1[5] * m2[9] + m1[9] * m2[10] + m1[13] * m2[11];
      mat[10] = m1[2] * m2[8] + m1[6] * m2[9] + m1[10] * m2[10] + m1[14] * m2[11];
      mat[11] = m1[3] * m2[8] + m1[7] * m2[9] + m1[11] * m2[10] + m1[15] * m2[11];
      mat[12] = m1[0] * m2[12] + m1[4] * m2[13] + m1[8] * m2[14] + m1[12] * m2[15];
      mat[13] = m1[1] * m2[12] + m1[5] * m2[13] + m1[9] * m2[14] + m1[13] * m2[15];
      mat[14] = m1[2] * m2[12] + m1[6] * m2[13] + m1[10] * m2[14] + m1[14] * m2[15];
      mat[15] = m1[3] * m2[12] + m1[7] * m2[13] + m1[11] * m2[14] + m1[15] * m2[15];
      return mat;
    };
    cc.math.mat4Assign = function(pOut, pIn) {
      if (pOut === pIn) {
        cc.logID(7901);
        return pOut;
      }
      var outArr = pOut.mat;
      var inArr = pIn.mat;
      outArr[0] = inArr[0];
      outArr[1] = inArr[1];
      outArr[2] = inArr[2];
      outArr[3] = inArr[3];
      outArr[4] = inArr[4];
      outArr[5] = inArr[5];
      outArr[6] = inArr[6];
      outArr[7] = inArr[7];
      outArr[8] = inArr[8];
      outArr[9] = inArr[9];
      outArr[10] = inArr[10];
      outArr[11] = inArr[11];
      outArr[12] = inArr[12];
      outArr[13] = inArr[13];
      outArr[14] = inArr[14];
      outArr[15] = inArr[15];
      return pOut;
    };
    proto.assignFrom = function(mat4) {
      if (this === mat4) {
        cc.logID(7902);
        return this;
      }
      var outArr = this.mat, inArr = mat4.mat;
      outArr[0] = inArr[0];
      outArr[1] = inArr[1];
      outArr[2] = inArr[2];
      outArr[3] = inArr[3];
      outArr[4] = inArr[4];
      outArr[5] = inArr[5];
      outArr[6] = inArr[6];
      outArr[7] = inArr[7];
      outArr[8] = inArr[8];
      outArr[9] = inArr[9];
      outArr[10] = inArr[10];
      outArr[11] = inArr[11];
      outArr[12] = inArr[12];
      outArr[13] = inArr[13];
      outArr[14] = inArr[14];
      outArr[15] = inArr[15];
      return this;
    };
    proto.equals = function(mat4) {
      if (this === mat4) {
        cc.logID(7903);
        return true;
      }
      var matA = this.mat, matB = mat4.mat, EPSILON = cc.math.EPSILON;
      for (var i = 0; i < 16; i++) if (!(matA[i] + EPSILON > matB[i] && matA[i] - EPSILON < matB[i])) return false;
      return true;
    };
    cc.math.Matrix4.createByRotationX = function(radians, matrix) {
      matrix = matrix || new cc.math.Matrix4();
      var mat = matrix.mat;
      mat[0] = 1;
      mat[3] = mat[2] = mat[1] = 0;
      mat[4] = 0;
      mat[5] = Math.cos(radians);
      mat[6] = Math.sin(radians);
      mat[7] = 0;
      mat[8] = 0;
      mat[9] = -Math.sin(radians);
      mat[10] = Math.cos(radians);
      mat[11] = 0;
      mat[14] = mat[13] = mat[12] = 0;
      mat[15] = 1;
      return matrix;
    };
    cc.math.Matrix4.createByRotationY = function(radians, matrix) {
      matrix = matrix || new cc.math.Matrix4();
      var mat = matrix.mat;
      mat[0] = Math.cos(radians);
      mat[1] = 0;
      mat[2] = -Math.sin(radians);
      mat[3] = 0;
      mat[7] = mat[6] = mat[4] = 0;
      mat[5] = 1;
      mat[8] = Math.sin(radians);
      mat[9] = 0;
      mat[10] = Math.cos(radians);
      mat[11] = 0;
      mat[14] = mat[13] = mat[12] = 0;
      mat[15] = 1;
      return matrix;
    };
    cc.math.Matrix4.createByRotationZ = function(radians, matrix) {
      matrix = matrix || new cc.math.Matrix4();
      var mat = matrix.mat;
      mat[0] = Math.cos(radians);
      mat[1] = Math.sin(radians);
      mat[3] = mat[2] = 0;
      mat[4] = -Math.sin(radians);
      mat[5] = Math.cos(radians);
      mat[7] = mat[6] = 0;
      mat[11] = mat[9] = mat[8] = 0;
      mat[10] = 1;
      mat[14] = mat[13] = mat[12] = 0;
      mat[15] = 1;
      return matrix;
    };
    cc.math.Matrix4.createByPitchYawRoll = function(pitch, yaw, roll, matrix) {
      matrix = matrix || new cc.math.Matrix4();
      var cr = Math.cos(pitch), sr = Math.sin(pitch);
      var cp = Math.cos(yaw), sp = Math.sin(yaw);
      var cy = Math.cos(roll), sy = Math.sin(roll);
      var srsp = sr * sp, crsp = cr * sp;
      var mat = matrix.mat;
      mat[0] = cp * cy;
      mat[4] = cp * sy;
      mat[8] = -sp;
      mat[1] = srsp * cy - cr * sy;
      mat[5] = srsp * sy + cr * cy;
      mat[9] = sr * cp;
      mat[2] = crsp * cy + sr * sy;
      mat[6] = crsp * sy - sr * cy;
      mat[10] = cr * cp;
      mat[3] = mat[7] = mat[11] = 0;
      mat[15] = 1;
      return matrix;
    };
    cc.math.Matrix4.createByQuaternion = function(quaternion, matrix) {
      matrix = matrix || new cc.math.Matrix4();
      var mat = matrix.mat;
      mat[0] = 1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);
      mat[1] = 2 * (quaternion.x * quaternion.y + quaternion.z * quaternion.w);
      mat[2] = 2 * (quaternion.x * quaternion.z - quaternion.y * quaternion.w);
      mat[3] = 0;
      mat[4] = 2 * (quaternion.x * quaternion.y - quaternion.z * quaternion.w);
      mat[5] = 1 - 2 * (quaternion.x * quaternion.x + quaternion.z * quaternion.z);
      mat[6] = 2 * (quaternion.z * quaternion.y + quaternion.x * quaternion.w);
      mat[7] = 0;
      mat[8] = 2 * (quaternion.x * quaternion.z + quaternion.y * quaternion.w);
      mat[9] = 2 * (quaternion.y * quaternion.z - quaternion.x * quaternion.w);
      mat[10] = 1 - 2 * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);
      mat[11] = 0;
      mat[14] = mat[13] = mat[12] = 0;
      mat[15] = 1;
      return matrix;
    };
    cc.math.Matrix4.createByRotationTranslation = function(rotation, translation, matrix) {
      matrix = matrix || new cc.math.Matrix4();
      var mat = matrix.mat, rMat = rotation.mat;
      mat[0] = rMat[0];
      mat[1] = rMat[1];
      mat[2] = rMat[2];
      mat[3] = 0;
      mat[4] = rMat[3];
      mat[5] = rMat[4];
      mat[6] = rMat[5];
      mat[7] = 0;
      mat[8] = rMat[6];
      mat[9] = rMat[7];
      mat[10] = rMat[8];
      mat[11] = 0;
      mat[12] = translation.x;
      mat[13] = translation.y;
      mat[14] = translation.z;
      mat[15] = 1;
      return matrix;
    };
    cc.math.Matrix4.createByScale = function(x, y, z, matrix) {
      matrix = matrix || new cc.math.Matrix4();
      var mat = matrix.mat;
      mat[0] = x;
      mat[5] = y;
      mat[10] = z;
      mat[15] = 1;
      mat[1] = mat[2] = mat[3] = mat[4] = mat[6] = mat[7] = mat[8] = mat[9] = mat[11] = mat[12] = mat[13] = mat[14] = 0;
      return matrix;
    };
    cc.math.mat4Translation = function(pOut, x, y, z) {
      pOut.mat[0] = pOut.mat[5] = pOut.mat[10] = pOut.mat[15] = 1;
      pOut.mat[1] = pOut.mat[2] = pOut.mat[3] = pOut.mat[4] = pOut.mat[6] = pOut.mat[7] = pOut.mat[8] = pOut.mat[9] = pOut.mat[11] = 0;
      pOut.mat[12] = x;
      pOut.mat[13] = y;
      pOut.mat[14] = z;
      return pOut;
    };
    cc.math.Matrix4.createByTranslation = function(x, y, z, matrix) {
      matrix = matrix || new cc.math.Matrix4();
      matrix.identity();
      matrix.mat[12] = x;
      matrix.mat[13] = y;
      matrix.mat[14] = z;
      return matrix;
    };
    proto.getUpVec3 = function() {
      var mat = this.mat;
      var ret = new cc.math.Vec3(mat[4], mat[5], mat[6]);
      return ret.normalize();
    };
    proto.getRightVec3 = function() {
      var mat = this.mat;
      var ret = new cc.math.Vec3(mat[0], mat[1], mat[2]);
      return ret.normalize();
    };
    proto.getForwardVec3 = function() {
      var mat = this.mat;
      var ret = new cc.math.Vec3(mat[8], mat[9], mat[10]);
      return ret.normalize();
    };
    cc.math.mat4PerspectiveProjection = function(pOut, fovY, aspect, zNear, zFar) {
      var r = cc.degreesToRadians(fovY / 2);
      var deltaZ = zFar - zNear;
      var s = Math.sin(r);
      if (0 === deltaZ || 0 === s || 0 === aspect) return null;
      var cotangent = Math.cos(r) / s;
      pOut.identity();
      pOut.mat[0] = cotangent / aspect;
      pOut.mat[5] = cotangent;
      pOut.mat[10] = -(zFar + zNear) / deltaZ;
      pOut.mat[11] = -1;
      pOut.mat[14] = -2 * zNear * zFar / deltaZ;
      pOut.mat[15] = 0;
      return pOut;
    };
    cc.math.Matrix4.createPerspectiveProjection = function(fovY, aspect, zNear, zFar) {
      var r = cc.degreesToRadians(fovY / 2), deltaZ = zFar - zNear;
      var s = Math.sin(r);
      if (0 === deltaZ || 0 === s || 0 === aspect) return null;
      var cotangent = Math.cos(r) / s;
      var matrix = new cc.math.Matrix4(), mat = matrix.mat;
      matrix.identity();
      mat[0] = cotangent / aspect;
      mat[5] = cotangent;
      mat[10] = -(zFar + zNear) / deltaZ;
      mat[11] = -1;
      mat[14] = -2 * zNear * zFar / deltaZ;
      mat[15] = 0;
      return matrix;
    };
    cc.math.mat4OrthographicProjection = function(pOut, left, right, bottom, top, nearVal, farVal) {
      pOut.identity();
      pOut.mat[0] = 2 / (right - left);
      pOut.mat[5] = 2 / (top - bottom);
      pOut.mat[10] = -2 / (farVal - nearVal);
      pOut.mat[12] = -(right + left) / (right - left);
      pOut.mat[13] = -(top + bottom) / (top - bottom);
      pOut.mat[14] = -(farVal + nearVal) / (farVal - nearVal);
      return pOut;
    };
    cc.math.Matrix4.createOrthographicProjection = function(left, right, bottom, top, nearVal, farVal) {
      var matrix = new cc.math.Matrix4(), mat = matrix.mat;
      matrix.identity();
      mat[0] = 2 / (right - left);
      mat[5] = 2 / (top - bottom);
      mat[10] = -2 / (farVal - nearVal);
      mat[12] = -(right + left) / (right - left);
      mat[13] = -(top + bottom) / (top - bottom);
      mat[14] = -(farVal + nearVal) / (farVal - nearVal);
      return matrix;
    };
    cc.math.mat4LookAt = function(pOut, pEye, pCenter, pUp) {
      var f = new cc.math.Vec3(pCenter), up = new cc.math.Vec3(pUp);
      f.subtract(pEye);
      f.normalize();
      up.normalize();
      var s = new cc.math.Vec3(f);
      s.cross(up);
      s.normalize();
      var u = new cc.math.Vec3(s);
      u.cross(f);
      s.normalize();
      pOut.identity();
      pOut.mat[0] = s.x;
      pOut.mat[4] = s.y;
      pOut.mat[8] = s.z;
      pOut.mat[1] = u.x;
      pOut.mat[5] = u.y;
      pOut.mat[9] = u.z;
      pOut.mat[2] = -f.x;
      pOut.mat[6] = -f.y;
      pOut.mat[10] = -f.z;
      var translate = cc.math.Matrix4.createByTranslation(-pEye.x, -pEye.y, -pEye.z);
      pOut.multiply(translate);
      return pOut;
    };
    var tempMatrix = new cc.math.Matrix4();
    proto.lookAt = function(eyeVec, centerVec, upVec) {
      var f = new cc.math.Vec3(centerVec), up = new cc.math.Vec3(upVec), mat = this.mat;
      f.subtract(eyeVec);
      f.normalize();
      up.normalize();
      var s = new cc.math.Vec3(f);
      s.cross(up);
      s.normalize();
      var u = new cc.math.Vec3(s);
      u.cross(f);
      s.normalize();
      this.identity();
      mat[0] = s.x;
      mat[4] = s.y;
      mat[8] = s.z;
      mat[1] = u.x;
      mat[5] = u.y;
      mat[9] = u.z;
      mat[2] = -f.x;
      mat[6] = -f.y;
      mat[10] = -f.z;
      tempMatrix = cc.math.Matrix4.createByTranslation(-eyeVec.x, -eyeVec.y, -eyeVec.z, tempMatrix);
      this.multiply(tempMatrix);
      return this;
    };
    cc.math.mat4RotationAxisAngle = function(pOut, axis, radians) {
      var rcos = Math.cos(radians), rsin = Math.sin(radians);
      var normalizedAxis = new cc.math.Vec3(axis);
      normalizedAxis.normalize();
      pOut.mat[0] = rcos + normalizedAxis.x * normalizedAxis.x * (1 - rcos);
      pOut.mat[1] = normalizedAxis.z * rsin + normalizedAxis.y * normalizedAxis.x * (1 - rcos);
      pOut.mat[2] = -normalizedAxis.y * rsin + normalizedAxis.z * normalizedAxis.x * (1 - rcos);
      pOut.mat[3] = 0;
      pOut.mat[4] = -normalizedAxis.z * rsin + normalizedAxis.x * normalizedAxis.y * (1 - rcos);
      pOut.mat[5] = rcos + normalizedAxis.y * normalizedAxis.y * (1 - rcos);
      pOut.mat[6] = normalizedAxis.x * rsin + normalizedAxis.z * normalizedAxis.y * (1 - rcos);
      pOut.mat[7] = 0;
      pOut.mat[8] = normalizedAxis.y * rsin + normalizedAxis.x * normalizedAxis.z * (1 - rcos);
      pOut.mat[9] = -normalizedAxis.x * rsin + normalizedAxis.y * normalizedAxis.z * (1 - rcos);
      pOut.mat[10] = rcos + normalizedAxis.z * normalizedAxis.z * (1 - rcos);
      pOut.mat[11] = 0;
      pOut.mat[12] = 0;
      pOut.mat[13] = 0;
      pOut.mat[14] = 0;
      pOut.mat[15] = 1;
      return pOut;
    };
    cc.math.Matrix4.createByAxisAndAngle = function(axis, radians, matrix) {
      matrix = matrix || new cc.math.Matrix4();
      var mat = this.mat, rcos = Math.cos(radians), rsin = Math.sin(radians);
      var normalizedAxis = new cc.math.Vec3(axis);
      normalizedAxis.normalize();
      mat[0] = rcos + normalizedAxis.x * normalizedAxis.x * (1 - rcos);
      mat[1] = normalizedAxis.z * rsin + normalizedAxis.y * normalizedAxis.x * (1 - rcos);
      mat[2] = -normalizedAxis.y * rsin + normalizedAxis.z * normalizedAxis.x * (1 - rcos);
      mat[3] = 0;
      mat[4] = -normalizedAxis.z * rsin + normalizedAxis.x * normalizedAxis.y * (1 - rcos);
      mat[5] = rcos + normalizedAxis.y * normalizedAxis.y * (1 - rcos);
      mat[6] = normalizedAxis.x * rsin + normalizedAxis.z * normalizedAxis.y * (1 - rcos);
      mat[7] = 0;
      mat[8] = normalizedAxis.y * rsin + normalizedAxis.x * normalizedAxis.z * (1 - rcos);
      mat[9] = -normalizedAxis.x * rsin + normalizedAxis.y * normalizedAxis.z * (1 - rcos);
      mat[10] = rcos + normalizedAxis.z * normalizedAxis.z * (1 - rcos);
      mat[11] = 0;
      mat[12] = mat[13] = mat[14] = 0;
      mat[15] = 1;
      return matrix;
    };
    proto.extractRotation = function() {
      var matrix = new cc.math.Matrix3(), mat4 = this.mat, mat3 = matrix.mat;
      mat3[0] = mat4[0];
      mat3[1] = mat4[1];
      mat3[2] = mat4[2];
      mat3[3] = mat4[4];
      mat3[4] = mat4[5];
      mat3[5] = mat4[6];
      mat3[6] = mat4[8];
      mat3[7] = mat4[9];
      mat3[8] = mat4[10];
      return matrix;
    };
    proto.extractPlane = function(planeType) {
      var plane = new cc.math.Plane(), mat = this.mat;
      switch (planeType) {
       case cc.math.Plane.RIGHT:
        plane.a = mat[3] - mat[0];
        plane.b = mat[7] - mat[4];
        plane.c = mat[11] - mat[8];
        plane.d = mat[15] - mat[12];
        break;

       case cc.math.Plane.LEFT:
        plane.a = mat[3] + mat[0];
        plane.b = mat[7] + mat[4];
        plane.c = mat[11] + mat[8];
        plane.d = mat[15] + mat[12];
        break;

       case cc.math.Plane.BOTTOM:
        plane.a = mat[3] + mat[1];
        plane.b = mat[7] + mat[5];
        plane.c = mat[11] + mat[9];
        plane.d = mat[15] + mat[13];
        break;

       case cc.math.Plane.TOP:
        plane.a = mat[3] - mat[1];
        plane.b = mat[7] - mat[5];
        plane.c = mat[11] - mat[9];
        plane.d = mat[15] - mat[13];
        break;

       case cc.math.Plane.FAR:
        plane.a = mat[3] - mat[2];
        plane.b = mat[7] - mat[6];
        plane.c = mat[11] - mat[10];
        plane.d = mat[15] - mat[14];
        break;

       case cc.math.Plane.NEAR:
        plane.a = mat[3] + mat[2];
        plane.b = mat[7] + mat[6];
        plane.c = mat[11] + mat[10];
        plane.d = mat[15] + mat[14];
        break;

       default:
        cc.logID(7904);
      }
      var t = Math.sqrt(plane.a * plane.a + plane.b * plane.b + plane.c * plane.c);
      plane.a /= t;
      plane.b /= t;
      plane.c /= t;
      plane.d /= t;
      return plane;
    };
    proto.toAxisAndAngle = function() {
      var rotation = this.extractRotation();
      var temp = cc.math.Quaternion.rotationMatrix(rotation);
      return temp.toAxisAndAngle();
    };
  }), {} ],
  159: [ (function(require, module, exports) {
    cc.math.Plane = function(a, b, c, d) {
      if (a && void 0 === b) {
        this.a = a.a;
        this.b = a.b;
        this.c = a.c;
        this.d = a.d;
      } else {
        this.a = a || 0;
        this.b = b || 0;
        this.c = c || 0;
        this.d = d || 0;
      }
    };
    var proto = cc.math.Plane.prototype;
    cc.math.Plane.LEFT = 0;
    cc.math.Plane.RIGHT = 1;
    cc.math.Plane.BOTTOM = 2;
    cc.math.Plane.TOP = 3;
    cc.math.Plane.NEAR = 4;
    cc.math.Plane.FAR = 5;
    cc.math.Plane.POINT_INFRONT_OF_PLANE = 0;
    cc.math.Plane.POINT_BEHIND_PLANE = 1;
    cc.math.Plane.POINT_ON_PLANE = 2;
    proto.dot = function(vec4) {
      return this.a * vec4.x + this.b * vec4.y + this.c * vec4.z + this.d * vec4.w;
    };
    proto.dotCoord = function(vec3) {
      return this.a * vec3.x + this.b * vec3.y + this.c * vec3.z + this.d;
    };
    proto.dotNormal = function(vec3) {
      return this.a * vec3.x + this.b * vec3.y + this.c * vec3.z;
    };
    cc.math.Plane.fromPointNormal = function(vec3, normal) {
      return new cc.math.Plane(normal.x, normal.y, normal.z, -normal.dot(vec3));
    };
    cc.math.Plane.fromPoints = function(vec1, vec2, vec3) {
      var v1 = new cc.math.Vec3(vec2), v2 = new cc.math.Vec3(vec3), plane = new cc.math.Plane();
      v1.subtract(vec1);
      v2.subtract(vec1);
      v1.cross(v2);
      v1.normalize();
      plane.a = v1.x;
      plane.b = v1.y;
      plane.c = v1.z;
      plane.d = v1.scale(-1).dot(vec1);
      return plane;
    };
    proto.normalize = function() {
      var n = new cc.math.Vec3(this.a, this.b, this.c), l = 1 / n.length();
      n.normalize();
      this.a = n.x;
      this.b = n.y;
      this.c = n.z;
      this.d = this.d * l;
      return this;
    };
    proto.classifyPoint = function(vec3) {
      var distance = this.a * vec3.x + this.b * vec3.y + this.c * vec3.z + this.d;
      if (distance > .001) return cc.math.Plane.POINT_INFRONT_OF_PLANE;
      if (distance < -.001) return cc.math.Plane.POINT_BEHIND_PLANE;
      return cc.math.Plane.POINT_ON_PLANE;
    };
  }), {} ],
  160: [ (function(require, module, exports) {
    cc.math.Quaternion = function(x, y, z, w) {
      if (x && void 0 === y) {
        this.x = x.x;
        this.y = x.y;
        this.z = x.z;
        this.w = x.w;
      } else {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.w = w || 0;
      }
    };
    var proto = cc.math.Quaternion.prototype;
    proto.conjugate = function(quaternion) {
      this.x = -quaternion.x;
      this.y = -quaternion.y;
      this.z = -quaternion.z;
      this.w = quaternion.w;
      return this;
    };
    proto.dot = function(quaternion) {
      return this.w * quaternion.w + this.x * quaternion.x + this.y * quaternion.y + this.z * quaternion.z;
    };
    proto.exponential = function() {
      return this;
    };
    proto.identity = function() {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;
      return this;
    };
    proto.inverse = function() {
      var len = this.length();
      if (Math.abs(len) > cc.math.EPSILON) {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
        return this;
      }
      this.conjugate(this).scale(1 / len);
      return this;
    };
    proto.isIdentity = function() {
      return 0 === this.x && 0 === this.y && 0 === this.z && 1 === this.w;
    };
    proto.length = function() {
      return Math.sqrt(this.lengthSq());
    };
    proto.lengthSq = function() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    };
    proto.multiply = function(quaternion) {
      var x = this.x, y = this.y, z = this.z, w = this.w;
      this.w = w * quaternion.w - x * quaternion.x - y * quaternion.y - z * quaternion.z;
      this.x = w * quaternion.x + x * quaternion.w + y * quaternion.z - z * quaternion.y;
      this.y = w * quaternion.y + y * quaternion.w + z * quaternion.x - x * quaternion.z;
      this.z = w * quaternion.z + z * quaternion.w + x * quaternion.y - y * quaternion.x;
      return this;
    };
    proto.normalize = function() {
      var length = this.length();
      if (Math.abs(length) <= cc.math.EPSILON) throw new Error(cc._getError(7909));
      this.scale(1 / length);
      return this;
    };
    proto.rotationAxis = function(axis, angle) {
      var rad = .5 * angle, scale = Math.sin(rad);
      this.w = Math.cos(rad);
      this.x = axis.x * scale;
      this.y = axis.y * scale;
      this.z = axis.z * scale;
      return this;
    };
    cc.math.Quaternion.rotationMatrix = function(mat3) {
      if (!mat3) return null;
      var x, y, z, w;
      var m4x4 = [], mat = mat3.mat, scale = 0;
      m4x4[0] = mat[0];
      m4x4[1] = mat[3];
      m4x4[2] = mat[6];
      m4x4[4] = mat[1];
      m4x4[5] = mat[4];
      m4x4[6] = mat[7];
      m4x4[8] = mat[2];
      m4x4[9] = mat[5];
      m4x4[10] = mat[8];
      m4x4[15] = 1;
      var pMatrix = m4x4[0];
      var diagonal = pMatrix[0] + pMatrix[5] + pMatrix[10] + 1;
      if (diagonal > cc.math.EPSILON) {
        scale = 2 * Math.sqrt(diagonal);
        x = (pMatrix[9] - pMatrix[6]) / scale;
        y = (pMatrix[2] - pMatrix[8]) / scale;
        z = (pMatrix[4] - pMatrix[1]) / scale;
        w = .25 * scale;
      } else if (pMatrix[0] > pMatrix[5] && pMatrix[0] > pMatrix[10]) {
        scale = 2 * Math.sqrt(1 + pMatrix[0] - pMatrix[5] - pMatrix[10]);
        x = .25 * scale;
        y = (pMatrix[4] + pMatrix[1]) / scale;
        z = (pMatrix[2] + pMatrix[8]) / scale;
        w = (pMatrix[9] - pMatrix[6]) / scale;
      } else if (pMatrix[5] > pMatrix[10]) {
        scale = 2 * Math.sqrt(1 + pMatrix[5] - pMatrix[0] - pMatrix[10]);
        x = (pMatrix[4] + pMatrix[1]) / scale;
        y = .25 * scale;
        z = (pMatrix[9] + pMatrix[6]) / scale;
        w = (pMatrix[2] - pMatrix[8]) / scale;
      } else {
        scale = 2 * Math.sqrt(1 + pMatrix[10] - pMatrix[0] - pMatrix[5]);
        x = (pMatrix[2] + pMatrix[8]) / scale;
        y = (pMatrix[9] + pMatrix[6]) / scale;
        z = .25 * scale;
        w = (pMatrix[4] - pMatrix[1]) / scale;
      }
      return new cc.math.Quaternion(x, y, z, w);
    };
    cc.math.Quaternion.rotationYawPitchRoll = function(yaw, pitch, roll) {
      var ex, ey, ez;
      var cr, cp, cy, sr, sp, sy, cpcy, spsy;
      ex = cc.degreesToRadians(pitch) / 2;
      ey = cc.degreesToRadians(yaw) / 2;
      ez = cc.degreesToRadians(roll) / 2;
      cr = Math.cos(ex);
      cp = Math.cos(ey);
      cy = Math.cos(ez);
      sr = Math.sin(ex);
      sp = Math.sin(ey);
      sy = Math.sin(ez);
      cpcy = cp * cy;
      spsy = sp * sy;
      var ret = new cc.math.Quaternion();
      ret.w = cr * cpcy + sr * spsy;
      ret.x = sr * cpcy - cr * spsy;
      ret.y = cr * sp * cy + sr * cp * sy;
      ret.z = cr * cp * sy - sr * sp * cy;
      ret.normalize();
      return ret;
    };
    proto.slerp = function(quaternion, t) {
      if (this.x === quaternion.x && this.y === quaternion.y && this.z === quaternion.z && this.w === quaternion.w) return this;
      var ct = this.dot(quaternion), theta = Math.acos(ct), st = Math.sqrt(1 - cc.math.square(ct));
      var stt = Math.sin(t * theta) / st, somt = Math.sin((1 - t) * theta) / st;
      var temp2 = new cc.math.Quaternion(quaternion);
      this.scale(somt);
      temp2.scale(stt);
      this.add(temp2);
      return this;
    };
    proto.toAxisAndAngle = function() {
      var tempAngle;
      var scale;
      var retAngle, retAxis = new cc.math.Vec3();
      tempAngle = Math.acos(this.w);
      scale = Math.sqrt(cc.math.square(this.x) + cc.math.square(this.y) + cc.math.square(this.z));
      if (scale > -cc.math.EPSILON && scale < cc.math.EPSILON || scale < 2 * Math.PI + cc.math.EPSILON && scale > 2 * Math.PI - cc.math.EPSILON) {
        retAngle = 0;
        retAxis.x = 0;
        retAxis.y = 0;
        retAxis.z = 1;
      } else {
        retAngle = 2 * tempAngle;
        retAxis.x = this.x / scale;
        retAxis.y = this.y / scale;
        retAxis.z = this.z / scale;
        retAxis.normalize();
      }
      return {
        axis: retAxis,
        angle: retAngle
      };
    };
    proto.scale = function(scale) {
      this.x *= scale;
      this.y *= scale;
      this.z *= scale;
      this.w *= scale;
      return this;
    };
    proto.assignFrom = function(quaternion) {
      this.x = quaternion.x;
      this.y = quaternion.y;
      this.z = quaternion.z;
      this.w = quaternion.w;
      return this;
    };
    proto.add = function(quaternion) {
      this.x += quaternion.x;
      this.y += quaternion.y;
      this.z += quaternion.z;
      this.w += quaternion.w;
      return this;
    };
    cc.math.Quaternion.rotationBetweenVec3 = function(vec1, vec2, fallback) {
      var v1 = new cc.math.Vec3(vec1), v2 = new cc.math.Vec3(vec2);
      v1.normalize();
      v2.normalize();
      var a = v1.dot(v2), quaternion = new cc.math.Quaternion();
      if (a >= 1) {
        quaternion.identity();
        return quaternion;
      }
      if (a < 1e-6 - 1) if (Math.abs(fallback.lengthSq()) < cc.math.EPSILON) quaternion.rotationAxis(fallback, Math.PI); else {
        var axis = new cc.math.Vec3(1, 0, 0);
        axis.cross(vec1);
        if (Math.abs(axis.lengthSq()) < cc.math.EPSILON) {
          axis.fill(0, 1, 0);
          axis.cross(vec1);
        }
        axis.normalize();
        quaternion.rotationAxis(axis, Math.PI);
      } else {
        var s = Math.sqrt(2 * (1 + a)), invs = 1 / s;
        v1.cross(v2);
        quaternion.x = v1.x * invs;
        quaternion.y = v1.y * invs;
        quaternion.z = v1.z * invs;
        quaternion.w = .5 * s;
        quaternion.normalize();
      }
      return quaternion;
    };
    proto.multiplyVec3 = function(vec) {
      var x = this.x, y = this.y, z = this.z, retVec = new cc.math.Vec3(vec);
      var uv = new cc.math.Vec3(x, y, z), uuv = new cc.math.Vec3(x, y, z);
      uv.cross(vec);
      uuv.cross(uv);
      uv.scale(2 * q.w);
      uuv.scale(2);
      retVec.add(uv);
      retVec.add(uuv);
      return retVec;
    };
  }), {} ],
  161: [ (function(require, module, exports) {
    cc.math.Ray2 = function(start, dir) {
      this.start = start || new cc.math.Vec2();
      this.dir = dir || new cc.math.Vec2();
    };
    cc.math.Ray2.prototype.fill = function(px, py, vx, vy) {
      this.start.x = px;
      this.start.y = py;
      this.dir.x = vx;
      this.dir.y = vy;
    };
    cc.math.Ray2.prototype.intersectLineSegment = function(p1, p2, intersection) {
      var x1 = this.start.x, y1 = this.start.y;
      var x2 = this.start.x + this.dir.x, y2 = this.start.y + this.dir.y;
      var x3 = p1.x, y3 = p1.y;
      var x4 = p2.x, y4 = p2.y;
      var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
      var ua, x, y;
      if (denom > -cc.math.EPSILON && denom < cc.math.EPSILON) return false;
      ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
      x = x1 + ua * (x2 - x1);
      y = y1 + ua * (y2 - y1);
      if (x < Math.min(p1.x, p2.x) - cc.math.EPSILON || x > Math.max(p1.x, p2.x) + cc.math.EPSILON || y < Math.min(p1.y, p2.y) - cc.math.EPSILON || y > Math.max(p1.y, p2.y) + cc.math.EPSILON) return false;
      if (x < Math.min(x1, x2) - cc.math.EPSILON || x > Math.max(x1, x2) + cc.math.EPSILON || y < Math.min(y1, y2) - cc.math.EPSILON || y > Math.max(y1, y2) + cc.math.EPSILON) return false;
      intersection.x = x;
      intersection.y = y;
      return true;
    };
    function calculate_line_normal(p1, p2, normalOut) {
      var tmp = new cc.math.Vec2(p2);
      tmp.subtract(p1);
      normalOut.x = -tmp.y;
      normalOut.y = tmp.x;
      normalOut.normalize();
    }
    cc.math.Ray2.prototype.intersectTriangle = function(p1, p2, p3, intersection, normal_out) {
      var intersect = new cc.math.Vec2(), final_intersect = new cc.math.Vec2();
      var normal = new cc.math.Vec2(), distance = 1e4, intersected = false;
      var this_distance;
      if (this.intersectLineSegment(p1, p2, intersect)) {
        intersected = true;
        this_distance = intersect.subtract(this.start).length();
        if (this_distance < distance) {
          final_intersect.x = intersect.x;
          final_intersect.y = intersect.y;
          distance = this_distance;
          calculate_line_normal(p1, p2, normal);
        }
      }
      if (this.intersectLineSegment(p2, p3, intersect)) {
        intersected = true;
        this_distance = intersect.subtract(this.start).length();
        if (this_distance < distance) {
          final_intersect.x = intersect.x;
          final_intersect.y = intersect.y;
          distance = this_distance;
          calculate_line_normal(p2, p3, normal);
        }
      }
      if (this.intersectLineSegment(p3, p1, intersect)) {
        intersected = true;
        this_distance = intersect.subtract(this.start).length();
        if (this_distance < distance) {
          final_intersect.x = intersect.x;
          final_intersect.y = intersect.y;
          distance = this_distance;
          calculate_line_normal(p3, p1, normal);
        }
      }
      if (intersected) {
        intersection.x = final_intersect.x;
        intersection.y = final_intersect.y;
        if (normal_out) {
          normal_out.x = normal.x;
          normal_out.y = normal.y;
        }
      }
      return intersected;
    };
  }), {} ],
  162: [ (function(require, module, exports) {
    cc.math = cc.math || {};
    cc.math.EPSILON = 1 / 64;
    cc.math.square = function(s) {
      return s * s;
    };
    cc.math.almostEqual = function(lhs, rhs) {
      return lhs + cc.math.EPSILON > rhs && lhs - cc.math.EPSILON < rhs;
    };
  }), {} ],
  163: [ (function(require, module, exports) {
    cc.math.Vec2 = function(x, y) {
      if (void 0 === y) {
        this.x = x.x;
        this.y = x.y;
      } else {
        this.x = x || 0;
        this.y = y || 0;
      }
    };
    var proto = cc.math.Vec2.prototype;
    proto.fill = function(x, y) {
      this.x = x;
      this.y = y;
    };
    proto.length = function() {
      return Math.sqrt(cc.math.square(this.x) + cc.math.square(this.y));
    };
    proto.lengthSq = function() {
      return cc.math.square(this.x) + cc.math.square(this.y);
    };
    proto.normalize = function() {
      var l = 1 / this.length();
      this.x *= l;
      this.y *= l;
      return this;
    };
    cc.math.Vec2.add = function(pOut, pV1, pV2) {
      pOut.x = pV1.x + pV2.x;
      pOut.y = pV1.y + pV2.y;
      return pOut;
    };
    proto.add = function(vec) {
      this.x += vec.x;
      this.y += vec.y;
      return this;
    };
    proto.dot = function(vec) {
      return this.x * vec.x + this.y * vec.y;
    };
    cc.math.Vec2.subtract = function(pOut, pV1, pV2) {
      pOut.x = pV1.x - pV2.x;
      pOut.y = pV1.y - pV2.y;
      return pOut;
    };
    proto.subtract = function(vec) {
      this.x -= vec.x;
      this.y -= vec.y;
      return this;
    };
    proto.transform = function(mat3) {
      var x = this.x, y = this.y;
      this.x = x * mat3.mat[0] + y * mat3.mat[3] + mat3.mat[6];
      this.y = x * mat3.mat[1] + y * mat3.mat[4] + mat3.mat[7];
      return this;
    };
    cc.math.Vec2.scale = function(pOut, pIn, s) {
      pOut.x = pIn.x * s;
      pOut.y = pIn.y * s;
      return pOut;
    };
    proto.scale = function(s) {
      this.x *= s;
      this.y *= s;
      return this;
    };
    proto.equals = function(vec) {
      return this.x < vec.x + cc.math.EPSILON && this.x > vec.x - cc.math.EPSILON && this.y < vec.y + cc.math.EPSILON && this.y > vec.y - cc.math.EPSILON;
    };
  }), {} ],
  164: [ (function(require, module, exports) {
    cc.math.Vec3 = cc.math.Vec3 = function(x, y, z) {
      if (x && void 0 === y) {
        this.x = x.x;
        this.y = x.y;
        this.z = x.z;
      } else {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
      }
    };
    cc.math.vec3 = function(x, y, z) {
      return new cc.math.Vec3(x, y, z);
    };
    var proto = cc.math.Vec3.prototype;
    proto.fill = function(x, y, z) {
      if (x && void 0 === y) {
        this.x = x.x;
        this.y = x.y;
        this.z = x.z;
      } else {
        this.x = x;
        this.y = y;
        this.z = z;
      }
      return this;
    };
    proto.length = function() {
      return Math.sqrt(cc.math.square(this.x) + cc.math.square(this.y) + cc.math.square(this.z));
    };
    proto.lengthSq = function() {
      return cc.math.square(this.x) + cc.math.square(this.y) + cc.math.square(this.z);
    };
    proto.normalize = function() {
      var l = 1 / this.length();
      this.x *= l;
      this.y *= l;
      this.z *= l;
      return this;
    };
    proto.cross = function(vec3) {
      var x = this.x, y = this.y, z = this.z;
      this.x = y * vec3.z - z * vec3.y;
      this.y = z * vec3.x - x * vec3.z;
      this.z = x * vec3.y - y * vec3.x;
      return this;
    };
    proto.dot = function(vec) {
      return this.x * vec.x + this.y * vec.y + this.z * vec.z;
    };
    proto.add = function(vec) {
      this.x += vec.x;
      this.y += vec.y;
      this.z += vec.z;
      return this;
    };
    proto.subtract = function(vec) {
      this.x -= vec.x;
      this.y -= vec.y;
      this.z -= vec.z;
      return this;
    };
    proto.transform = function(mat4) {
      var x = this.x, y = this.y, z = this.z, mat = mat4.mat;
      this.x = x * mat[0] + y * mat[4] + z * mat[8] + mat[12];
      this.y = x * mat[1] + y * mat[5] + z * mat[9] + mat[13];
      this.z = x * mat[2] + y * mat[6] + z * mat[10] + mat[14];
      return this;
    };
    proto.transformNormal = function(mat4) {
      var x = this.x, y = this.y, z = this.z, mat = mat4.mat;
      this.x = x * mat[0] + y * mat[4] + z * mat[8];
      this.y = x * mat[1] + y * mat[5] + z * mat[9];
      this.z = x * mat[2] + y * mat[6] + z * mat[10];
      return this;
    };
    proto.transformCoord = function(mat4) {
      var v = new cc.math.Vec4(this.x, this.y, this.z, 1);
      v.transform(mat4);
      this.x = v.x / v.w;
      this.y = v.y / v.w;
      this.z = v.z / v.w;
      return this;
    };
    proto.scale = function(scale) {
      this.x *= scale;
      this.y *= scale;
      this.z *= scale;
      return this;
    };
    proto.equals = function(vec) {
      var EPSILON = cc.math.EPSILON;
      return this.x < vec.x + EPSILON && this.x > vec.x - EPSILON && this.y < vec.y + EPSILON && this.y > vec.y - EPSILON && this.z < vec.z + EPSILON && this.z > vec.z - EPSILON;
    };
    proto.inverseTransform = function(mat4) {
      var mat = mat4.mat;
      var v1 = new cc.math.Vec3(this.x - mat[12], this.y - mat[13], this.z - mat[14]);
      this.x = v1.x * mat[0] + v1.y * mat[1] + v1.z * mat[2];
      this.y = v1.x * mat[4] + v1.y * mat[5] + v1.z * mat[6];
      this.z = v1.x * mat[8] + v1.y * mat[9] + v1.z * mat[10];
      return this;
    };
    proto.inverseTransformNormal = function(mat4) {
      var x = this.x, y = this.y, z = this.z, mat = mat4.mat;
      this.x = x * mat[0] + y * mat[1] + z * mat[2];
      this.y = x * mat[4] + y * mat[5] + z * mat[6];
      this.z = x * mat[8] + y * mat[9] + z * mat[10];
      return this;
    };
    proto.assignFrom = function(vec) {
      if (!vec) return this;
      this.x = vec.x;
      this.y = vec.y;
      this.z = vec.z;
      return this;
    };
    cc.math.Vec3.zero = function(vec) {
      vec.x = vec.y = vec.z = 0;
      return vec;
    };
    proto.toTypeArray = function() {
      var tyArr = new Float32Array(3);
      tyArr[0] = this.x;
      tyArr[1] = this.y;
      tyArr[2] = this.z;
      return tyArr;
    };
  }), {} ],
  165: [ (function(require, module, exports) {
    cc.math.Vec4 = function(x, y, z, w) {
      if (x && void 0 === y) {
        this.x = x.x;
        this.y = x.y;
        this.z = x.z;
        this.w = x.w;
      } else {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.w = w || 0;
      }
    };
    var proto = cc.math.Vec4.prototype;
    proto.fill = function(x, y, z, w) {
      if (x && void 0 === y) {
        this.x = x.x;
        this.y = x.y;
        this.z = x.z;
        this.w = x.w;
      } else {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
      }
    };
    proto.add = function(vec) {
      if (!vec) return this;
      this.x += vec.x;
      this.y += vec.y;
      this.z += vec.z;
      this.w += vec.w;
      return this;
    };
    proto.dot = function(vec) {
      return this.x * vec.x + this.y * vec.y + this.z * vec.z + this.w * vec.w;
    };
    proto.length = function() {
      return Math.sqrt(cc.math.square(this.x) + cc.math.square(this.y) + cc.math.square(this.z) + cc.math.square(this.w));
    };
    proto.lengthSq = function() {
      return cc.math.square(this.x) + cc.math.square(this.y) + cc.math.square(this.z) + cc.math.square(this.w);
    };
    proto.lerp = function(vec, t) {
      return this;
    };
    proto.normalize = function() {
      var l = 1 / this.length();
      this.x *= l;
      this.y *= l;
      this.z *= l;
      this.w *= l;
      return this;
    };
    proto.scale = function(scale) {
      this.normalize();
      this.x *= scale;
      this.y *= scale;
      this.z *= scale;
      this.w *= scale;
      return this;
    };
    proto.subtract = function(vec) {
      this.x -= vec.x;
      this.y -= vec.y;
      this.z -= vec.z;
      this.w -= vec.w;
    };
    proto.transform = function(mat4) {
      var x = this.x, y = this.y, z = this.z, w = this.w, mat = mat4.mat;
      this.x = x * mat[0] + y * mat[4] + z * mat[8] + w * mat[12];
      this.y = x * mat[1] + y * mat[5] + z * mat[9] + w * mat[13];
      this.z = x * mat[2] + y * mat[6] + z * mat[10] + w * mat[14];
      this.w = x * mat[3] + y * mat[7] + z * mat[11] + w * mat[15];
      return this;
    };
    cc.math.Vec4.transformArray = function(vecArray, mat4) {
      var retArray = [];
      for (var i = 0; i < vecArray.length; i++) {
        var selVec = new cc.math.Vec4(vecArray[i]);
        selVec.transform(mat4);
        retArray.push(selVec);
      }
      return retArray;
    };
    proto.equals = function(vec) {
      var EPSILON = cc.math.EPSILON;
      return this.x < vec.x + EPSILON && this.x > vec.x - EPSILON && this.y < vec.y + EPSILON && this.y > vec.y - EPSILON && this.z < vec.z + EPSILON && this.z > vec.z - EPSILON && this.w < vec.w + EPSILON && this.w > vec.w - EPSILON;
    };
    proto.assignFrom = function(vec) {
      this.x = vec.x;
      this.y = vec.y;
      this.z = vec.z;
      this.w = vec.w;
      return this;
    };
    proto.toTypeArray = function() {
      var tyArr = new Float32Array(4);
      tyArr[0] = this.x;
      tyArr[1] = this.y;
      tyArr[2] = this.z;
      tyArr[3] = this.w;
      return tyArr;
    };
  }), {} ],
  166: [ (function(require, module, exports) {
    var macro = cc.macro;
    var math = cc.math;
    cc.GLProgram = cc._Class.extend({
      _updateUniformLocation: function(location) {
        if (!location) return false;
        var updated;
        var element = this._hashForUniforms[location];
        if (element) {
          updated = false;
          var count = arguments.length - 1;
          for (var i = 0; i < count; ++i) if (arguments[i + 1] !== element[i]) {
            element[i] = arguments[i + 1];
            updated = true;
          }
        } else {
          element = [ arguments[1], arguments[2], arguments[3], arguments[4] ];
          this._hashForUniforms[location] = element;
          updated = true;
        }
        return updated;
      },
      _description: function() {
        return "<CCGLProgram = " + this.toString() + " | Program = " + this._programObj.toString() + ", VertexShader = " + this._vertShader.toString() + ", FragmentShader = " + this._fragShader.toString() + ">";
      },
      _compileShader: function(shader, type, source) {
        if (!source || !shader) return false;
        var preStr = cc.GLProgram._isHighpSupported() ? "precision highp float;\n" : "precision mediump float;\n";
        source = preStr + "uniform mat4 CC_PMatrix;\nuniform mat4 CC_MVMatrix;\nuniform mat4 CC_MVPMatrix;\nuniform vec4 CC_Time;\nuniform vec4 CC_SinTime;\nuniform vec4 CC_CosTime;\nuniform vec4 CC_Random01;\nuniform sampler2D CC_Texture0;\n//CC INCLUDES END\n" + source;
        this._glContext.shaderSource(shader, source);
        this._glContext.compileShader(shader);
        var status = this._glContext.getShaderParameter(shader, this._glContext.COMPILE_STATUS);
        if (!status) {
          cc.logID(8100, this._glContext.getShaderSource(shader));
          type === this._glContext.VERTEX_SHADER ? cc.log("cocos2d: \n" + this.vertexShaderLog()) : cc.log("cocos2d: \n" + this.fragmentShaderLog());
        }
        return !!status;
      },
      ctor: function(vShaderFileName, fShaderFileName, glContext) {
        this._uniforms = {};
        this._hashForUniforms = {};
        this._glContext = glContext || cc._renderContext;
        this._programObj = null;
        this._vertShader = null;
        this._fragShader = null;
        this._usesTime = false;
        this._projectionUpdated = -1;
        vShaderFileName && fShaderFileName && this.init(vShaderFileName, fShaderFileName);
      },
      destroyProgram: function() {
        this._vertShader = null;
        this._fragShader = null;
        this._uniforms = null;
        this._hashForUniforms = null;
        this._glContext.deleteProgram(this._programObj);
      },
      initWithVertexShaderByteArray: function(vertShaderStr, fragShaderStr) {
        var locGL = this._glContext;
        this._programObj = locGL.createProgram();
        this._projectionUpdated = -1;
        this._vertShader = null;
        this._fragShader = null;
        if (vertShaderStr) {
          this._vertShader = locGL.createShader(locGL.VERTEX_SHADER);
          this._compileShader(this._vertShader, locGL.VERTEX_SHADER, vertShaderStr) || cc.logID(8101);
        }
        if (fragShaderStr) {
          this._fragShader = locGL.createShader(locGL.FRAGMENT_SHADER);
          this._compileShader(this._fragShader, locGL.FRAGMENT_SHADER, fragShaderStr) || cc.logID(8102);
        }
        this._vertShader && locGL.attachShader(this._programObj, this._vertShader);
        this._fragShader && locGL.attachShader(this._programObj, this._fragShader);
        for (var key in this._hashForUniforms) delete this._hashForUniforms[key];
        false;
        return true;
      },
      initWithString: function(vertShaderStr, fragShaderStr) {
        return this.initWithVertexShaderByteArray(vertShaderStr, fragShaderStr);
      },
      initWithVertexShaderFilename: function(vShaderFilename, fShaderFileName) {
        var vertexSource = cc.loader.getRes(vShaderFilename);
        if (!vertexSource) throw new Error(cc._getError(8106, vShaderFilename));
        var fragmentSource = cc.loader.getRes(fShaderFileName);
        if (!fragmentSource) throw new Error(cc._getError(8106, fShaderFileName));
        return this.initWithVertexShaderByteArray(vertexSource, fragmentSource);
      },
      init: function(vShaderFilename, fShaderFileName) {
        return this.initWithVertexShaderFilename(vShaderFilename, fShaderFileName);
      },
      addAttribute: function(attributeName, index) {
        this._glContext.bindAttribLocation(this._programObj, index, attributeName);
      },
      link: function() {
        if (!this._programObj) {
          cc.logID(8103);
          return false;
        }
        this._glContext.linkProgram(this._programObj);
        this._vertShader && this._glContext.deleteShader(this._vertShader);
        this._fragShader && this._glContext.deleteShader(this._fragShader);
        this._vertShader = null;
        this._fragShader = null;
        if (cc.game.config[cc.game.CONFIG_KEY.debugMode]) {
          var status = this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS);
          if (!status) {
            cc.logID(8104, this._glContext.getProgramInfoLog(this._programObj));
            cc.gl.deleteProgram(this._programObj);
            this._programObj = null;
            return false;
          }
        }
        return true;
      },
      use: function() {
        cc.gl.useProgram(this._programObj);
      },
      updateUniforms: function() {
        this._uniforms[macro.UNIFORM_PMATRIX] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_PMATRIX_S);
        this._uniforms[macro.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_MVMATRIX_S);
        this._uniforms[macro.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_MVPMATRIX_S);
        this._uniforms[macro.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_TIME_S);
        this._uniforms[macro.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_SINTIME_S);
        this._uniforms[macro.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_COSTIME_S);
        this._usesTime = null != this._uniforms[macro.UNIFORM_TIME] || null != this._uniforms[macro.UNIFORM_SINTIME] || null != this._uniforms[macro.UNIFORM_COSTIME];
        this._uniforms[macro.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_RANDOM01_S);
        this._uniforms[macro.UNIFORM_SAMPLER] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_SAMPLER_S);
        this.use();
        this.setUniformLocationWith1i(this._uniforms[macro.UNIFORM_SAMPLER], 0);
      },
      _addUniformLocation: function(name) {
        var location = this._glContext.getUniformLocation(this._programObj, name);
        this._uniforms[name] = location;
      },
      getUniformLocationForName: function(name) {
        if (!name) throw new Error(cc._getError(8107));
        if (!this._programObj) throw new Error(cc._getError(8108));
        var location = this._uniforms[name] || this._glContext.getUniformLocation(this._programObj, name);
        return location;
      },
      getUniformMVPMatrix: function() {
        return this._uniforms[macro.UNIFORM_MVPMATRIX];
      },
      getUniformSampler: function() {
        return this._uniforms[macro.UNIFORM_SAMPLER];
      },
      setUniformLocationWith1i: function(location, i1) {
        var gl = this._glContext;
        if ("string" === typeof location) {
          var updated = this._updateUniformLocation(location, i1);
          if (updated) {
            var locObj = this.getUniformLocationForName(location);
            gl.uniform1i(locObj, i1);
          }
        } else gl.uniform1i(location, i1);
      },
      setUniformLocationWith2i: function(location, i1, i2) {
        var gl = this._glContext;
        if ("string" === typeof location) {
          var updated = this._updateUniformLocation(location, i1, i2);
          if (updated) {
            var locObj = this.getUniformLocationForName(location);
            gl.uniform2i(locObj, i1, i2);
          }
        } else gl.uniform2i(location, i1, i2);
      },
      setUniformLocationWith3i: function(location, i1, i2, i3) {
        var gl = this._glContext;
        if ("string" === typeof location) {
          var updated = this._updateUniformLocation(location, i1, i2, i3);
          if (updated) {
            var locObj = this.getUniformLocationForName(location);
            gl.uniform3i(locObj, i1, i2, i3);
          }
        } else gl.uniform3i(location, i1, i2, i3);
      },
      setUniformLocationWith4i: function(location, i1, i2, i3, i4) {
        var gl = this._glContext;
        if ("string" === typeof location) {
          var updated = this._updateUniformLocation(location, i1, i2, i3, i4);
          if (updated) {
            var locObj = this.getUniformLocationForName(location);
            gl.uniform4i(locObj, i1, i2, i3, i4);
          }
        } else gl.uniform4i(location, i1, i2, i3, i4);
      },
      setUniformLocationWith2iv: function(location, intArray) {
        var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
        this._glContext.uniform2iv(locObj, intArray);
      },
      setUniformLocationWith3iv: function(location, intArray) {
        var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
        this._glContext.uniform3iv(locObj, intArray);
      },
      setUniformLocationWith4iv: function(location, intArray) {
        var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
        this._glContext.uniform4iv(locObj, intArray);
      },
      setUniformLocationI32: function(location, i1) {
        this.setUniformLocationWith1i(location, i1);
      },
      setUniformLocationWith1f: function(location, f1) {
        var gl = this._glContext;
        if ("string" === typeof location) {
          var updated = this._updateUniformLocation(location, f1);
          if (updated) {
            var locObj = this.getUniformLocationForName(location);
            gl.uniform1f(locObj, f1);
          }
        } else gl.uniform1f(location, f1);
      },
      setUniformLocationWith2f: function(location, f1, f2) {
        var gl = this._glContext;
        if ("string" === typeof location) {
          var updated = this._updateUniformLocation(location, f1, f2);
          if (updated) {
            var locObj = this.getUniformLocationForName(location);
            gl.uniform2f(locObj, f1, f2);
          }
        } else gl.uniform2f(location, f1, f2);
      },
      setUniformLocationWith3f: function(location, f1, f2, f3) {
        var gl = this._glContext;
        if ("string" === typeof location) {
          var updated = this._updateUniformLocation(location, f1, f2, f3);
          if (updated) {
            var locObj = this.getUniformLocationForName(location);
            gl.uniform3f(locObj, f1, f2, f3);
          }
        } else gl.uniform3f(location, f1, f2, f3);
      },
      setUniformLocationWith4f: function(location, f1, f2, f3, f4) {
        var gl = this._glContext;
        if ("string" === typeof location) {
          var updated = this._updateUniformLocation(location, f1, f2, f3, f4);
          if (updated) {
            var locObj = this.getUniformLocationForName(location);
            gl.uniform4f(locObj, f1, f2, f3, f4);
          }
        } else gl.uniform4f(location, f1, f2, f3, f4);
      },
      setUniformLocationWith2fv: function(location, floatArray) {
        var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
        this._glContext.uniform2fv(locObj, floatArray);
      },
      setUniformLocationWith3fv: function(location, floatArray) {
        var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
        this._glContext.uniform3fv(locObj, floatArray);
      },
      setUniformLocationWith4fv: function(location, floatArray) {
        var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
        this._glContext.uniform4fv(locObj, floatArray);
      },
      setUniformLocationWithMatrix3fv: function(location, matrixArray) {
        var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
        this._glContext.uniformMatrix3fv(locObj, false, matrixArray);
      },
      setUniformLocationWithMatrix4fv: function(location, matrixArray) {
        var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
        this._glContext.uniformMatrix4fv(locObj, false, matrixArray);
      },
      setUniformLocationF32: function(p1, p2, p3, p4, p5) {
        "use strict";
        switch (arguments.length) {
         case 0:
         case 1:
          return;

         case 2:
          this.setUniformLocationWith1f(p1, p2);
          break;

         case 3:
          this.setUniformLocationWith2f(p1, p2, p3);
          break;

         case 4:
          this.setUniformLocationWith3f(p1, p2, p3, p4);
          break;

         case 5:
          this.setUniformLocationWith4f(p1, p2, p3, p4, p5);
        }
      },
      setUniformsForBuiltins: function() {
        var matrixP = new math.Matrix4();
        var matrixMV = new math.Matrix4();
        var matrixMVP = new math.Matrix4();
        math.glGetMatrix(math.KM_GL_PROJECTION, matrixP);
        math.glGetMatrix(math.KM_GL_MODELVIEW, matrixMV);
        math.mat4Multiply(matrixMVP, matrixP, matrixMV);
        this.setUniformLocationWithMatrix4fv(this._uniforms[macro.UNIFORM_PMATRIX], matrixP.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[macro.UNIFORM_MVMATRIX], matrixMV.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[macro.UNIFORM_MVPMATRIX], matrixMVP.mat, 1);
        if (this._usesTime) {
          var director = cc.director;
          var time = director.getTotalFrames() * director.getAnimationInterval();
          this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_TIME], time / 10, time, 2 * time, 4 * time);
          this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_SINTIME], time / 8, time / 4, time / 2, Math.sin(time));
          this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_COSTIME], time / 8, time / 4, time / 2, Math.cos(time));
        }
        -1 !== this._uniforms[macro.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random());
      },
      _setUniformsForBuiltinsForRenderer: function(node) {
        if (!node || !node._renderCmd) return;
        var matrixP = new math.Matrix4();
        var matrixMVP = new math.Matrix4();
        math.glGetMatrix(math.KM_GL_PROJECTION, matrixP);
        math.mat4Multiply(matrixMVP, matrixP, node._renderCmd._stackMatrix);
        this.setUniformLocationWithMatrix4fv(this._uniforms[macro.UNIFORM_PMATRIX], matrixP.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[macro.UNIFORM_MVMATRIX], node._renderCmd._stackMatrix.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[macro.UNIFORM_MVPMATRIX], matrixMVP.mat, 1);
        if (this._usesTime) {
          var director = cc.director;
          var time = director.getTotalFrames() * director.getAnimationInterval();
          this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_TIME], time / 10, time, 2 * time, 4 * time);
          this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_SINTIME], time / 8, time / 4, time / 2, Math.sin(time));
          this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_COSTIME], time / 8, time / 4, time / 2, Math.cos(time));
        }
        -1 !== this._uniforms[macro.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random());
      },
      setUniformForModelViewProjectionMatrix: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[macro.UNIFORM_MVPMATRIX], false, math.getMat4MultiplyValue(math.projection_matrix_stack.top, math.modelview_matrix_stack.top));
      },
      setUniformForModelViewProjectionMatrixWithMat4: function(swapMat4) {
        math.mat4Multiply(swapMat4, math.projection_matrix_stack.top, math.modelview_matrix_stack.top);
        this._glContext.uniformMatrix4fv(this._uniforms[macro.UNIFORM_MVPMATRIX], false, swapMat4.mat);
      },
      setUniformForModelViewAndProjectionMatrixWithMat4: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[macro.UNIFORM_MVMATRIX], false, math.modelview_matrix_stack.top.mat);
        this._glContext.uniformMatrix4fv(this._uniforms[macro.UNIFORM_PMATRIX], false, math.projection_matrix_stack.top.mat);
      },
      _setUniformForMVPMatrixWithMat4: function(modelViewMatrix) {
        if (!modelViewMatrix) throw new Error(cc._getError(8109));
        this._glContext.uniformMatrix4fv(this._uniforms[macro.UNIFORM_MVMATRIX], false, modelViewMatrix.mat);
        this._glContext.uniformMatrix4fv(this._uniforms[macro.UNIFORM_PMATRIX], false, math.projection_matrix_stack.top.mat);
      },
      _updateProjectionUniform: function() {
        var stack = math.projection_matrix_stack;
        if (stack.lastUpdated !== this._projectionUpdated) {
          this._glContext.uniformMatrix4fv(this._uniforms[macro.UNIFORM_PMATRIX], false, stack.top.mat);
          this._projectionUpdated = stack.lastUpdated;
        }
      },
      vertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader);
      },
      getVertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader);
      },
      getFragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader);
      },
      fragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._fragShader);
      },
      programLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj);
      },
      getProgramLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj);
      },
      reset: function() {
        this._vertShader = null;
        this._fragShader = null;
        this._uniforms.length = 0;
        this._glContext.deleteProgram(this._programObj);
        this._programObj = null;
        for (var key in this._hashForUniforms) {
          this._hashForUniforms[key].length = 0;
          delete this._hashForUniforms[key];
        }
      },
      getProgram: function() {
        return this._programObj;
      },
      retain: function() {},
      release: function() {}
    });
    cc.GLProgram._highpSupported = null;
    cc.GLProgram._isHighpSupported = function() {
      var ctx = cc._renderContext;
      if (ctx.getShaderPrecisionFormat && null == cc.GLProgram._highpSupported) {
        var highp = ctx.getShaderPrecisionFormat(ctx.FRAGMENT_SHADER, ctx.HIGH_FLOAT);
        cc.GLProgram._highpSupported = 0 !== highp.precision;
      }
      return cc.GLProgram._highpSupported;
    };
  }), {} ],
  167: [ (function(require, module, exports) {
    var _currentProjectionMatrix = -1;
    var macro = cc.macro;
    var ENABLE_GL_STATE_CACHE = macro.ENABLE_GL_STATE_CACHE;
    var MAX_ACTIVETEXTURE = 0, _currentShaderProgram = 0, _currentBoundTexture = null, _blendingSource = 0, _blendingDest = 0, _GLServerState = 0;
    if (ENABLE_GL_STATE_CACHE) {
      MAX_ACTIVETEXTURE = 16;
      _currentShaderProgram = -1;
      _currentBoundTexture = new Array(MAX_ACTIVETEXTURE);
      _blendingSource = -1;
      _blendingDest = -1;
      _GLServerState = 0;
    }
    cc.gl = {};
    cc.gl.invalidateStateCache = function() {
      cc.math.glFreeAll();
      _currentProjectionMatrix = -1;
      if (ENABLE_GL_STATE_CACHE) {
        _currentShaderProgram = -1;
        for (var i = 0; i < MAX_ACTIVETEXTURE; i++) _currentBoundTexture[i] = null;
        _blendingSource = -1;
        _blendingDest = -1;
        _GLServerState = 0;
      }
    };
    cc.gl.useProgram = ENABLE_GL_STATE_CACHE ? function(program) {
      if (program !== _currentShaderProgram) {
        _currentShaderProgram = program;
        cc._renderContext.useProgram(program);
      }
    } : function(program) {
      cc._renderContext.useProgram(program);
    };
    cc.gl.deleteProgram = function(program) {
      ENABLE_GL_STATE_CACHE && program === _currentShaderProgram && (_currentShaderProgram = -1);
      gl.deleteProgram(program);
    };
    cc.gl.setBlending = function(sfactor, dfactor) {
      var gl = cc._renderContext;
      if (sfactor === gl.ONE && dfactor === gl.ZERO) gl.disable(gl.BLEND); else {
        gl.enable(gl.BLEND);
        gl.blendFunc(sfactor, dfactor);
      }
    };
    cc.gl.blendFunc = ENABLE_GL_STATE_CACHE ? function(sfactor, dfactor) {
      if (sfactor !== _blendingSource || dfactor !== _blendingDest) {
        _blendingSource = sfactor;
        _blendingDest = dfactor;
        cc.gl.setBlending(sfactor, dfactor);
      }
    } : cc.gl.setBlending;
    cc.gl.blendFuncForParticle = function(sfactor, dfactor) {
      if (sfactor !== _blendingSource || dfactor !== _blendingDest) {
        _blendingSource = sfactor;
        _blendingDest = dfactor;
        var ctx = cc._renderContext;
        if (sfactor === ctx.ONE && dfactor === ctx.ZERO) ctx.disable(ctx.BLEND); else {
          ctx.enable(ctx.BLEND);
          ctx.blendFuncSeparate(ctx.SRC_ALPHA, dfactor, sfactor, dfactor);
        }
      }
    };
    cc.gl.blendResetToCache = function() {
      var ctx = cc._renderContext;
      ctx.blendEquation(ctx.FUNC_ADD);
      ENABLE_GL_STATE_CACHE ? cc.gl.setBlending(_blendingSource, _blendingDest) : cc.gl.setBlending(ctx.BLEND_SRC, ctx.BLEND_DST);
    };
    cc.gl.setProjectionMatrixDirty = function() {
      _currentProjectionMatrix = -1;
    };
    cc.gl.bindTexture2D = function(texture) {
      cc.gl.bindTexture2DN(0, texture);
    };
    cc.gl.bindTexture2DN = ENABLE_GL_STATE_CACHE ? function(textureUnit, texture) {
      if (_currentBoundTexture[textureUnit] === texture) return;
      _currentBoundTexture[textureUnit] = texture;
      var ctx = cc._renderContext;
      ctx.activeTexture(ctx.TEXTURE0 + textureUnit);
      texture ? ctx.bindTexture(ctx.TEXTURE_2D, texture._glID) : ctx.bindTexture(ctx.TEXTURE_2D, null);
    } : function(textureUnit, texture) {
      var ctx = cc._renderContext;
      ctx.activeTexture(ctx.TEXTURE0 + textureUnit);
      texture ? ctx.bindTexture(ctx.TEXTURE_2D, texture._glID) : ctx.bindTexture(ctx.TEXTURE_2D, null);
    };
    cc.gl.deleteTexture2D = function(texture) {
      cc.gl.deleteTexture2DN(0, texture);
    };
    cc.gl.deleteTexture2DN = function(textureUnit, texture) {
      ENABLE_GL_STATE_CACHE && texture === _currentBoundTexture[textureUnit] && (_currentBoundTexture[textureUnit] = null);
      cc._renderContext.deleteTexture(texture._glID);
    };
    cc.gl.enable = function(flags) {
      ENABLE_GL_STATE_CACHE;
    };
  }), {} ],
  168: [ (function(require, module, exports) {
    var shaders = cc.PresetShaders;
    var macro = cc.macro;
    cc.shaderCache = {
      TYPE_POSITION_TEXTURECOLOR: 0,
      TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1,
      TYPE_POSITION_COLOR: 2,
      TYPE_POSITION_TEXTURE: 3,
      TYPE_POSITION_TEXTURE_UCOLOR: 4,
      TYPE_POSITION_TEXTURE_A8COLOR: 5,
      TYPE_POSITION_UCOLOR: 6,
      TYPE_POSITION_LENGTH_TEXTURECOLOR: 7,
      TYPE_SPRITE_POSITION_TEXTURECOLOR: 8,
      TYPE_SPRITE_POSITION_TEXTURECOLOR_ALPHATEST: 9,
      TYPE_SPRITE_POSITION_COLOR: 10,
      TYPE_MAX: 10,
      _programs: {},
      _init: function() {
        this.loadDefaultShaders();
        return true;
      },
      _loadDefaultShader: function(program, type) {
        switch (type) {
         case macro.SHADER_POSITION_TEXTURECOLOR:
          program.initWithVertexShaderByteArray(shaders.POSITION_TEXTURE_COLOR_VERT, shaders.POSITION_TEXTURE_COLOR_FRAG);
          program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
          program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
          program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
          break;

         case macro.SHADER_SPRITE_POSITION_TEXTURECOLOR:
          program.initWithVertexShaderByteArray(shaders.SPRITE_POSITION_TEXTURE_COLOR_VERT, shaders.POSITION_TEXTURE_COLOR_FRAG);
          program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
          program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
          program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
          break;

         case macro.SHADER_POSITION_TEXTURECOLORALPHATEST:
          program.initWithVertexShaderByteArray(shaders.POSITION_TEXTURE_COLOR_VERT, shaders.POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
          program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
          program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
          program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
          break;

         case macro.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST:
          program.initWithVertexShaderByteArray(shaders.SPRITE_POSITION_TEXTURE_COLOR_VERT, shaders.POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
          program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
          program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
          program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
          break;

         case macro.SHADER_POSITION_COLOR:
          program.initWithVertexShaderByteArray(shaders.POSITION_COLOR_VERT, shaders.POSITION_COLOR_FRAG);
          program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
          program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
          break;

         case macro.SHADER_SPRITE_POSITION_COLOR:
          program.initWithVertexShaderByteArray(shaders.SPRITE_POSITION_COLOR_VERT, shaders.POSITION_COLOR_FRAG);
          program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
          program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
          break;

         case macro.SHADER_POSITION_TEXTURE:
          program.initWithVertexShaderByteArray(shaders.POSITION_TEXTURE_VERT, shaders.POSITION_TEXTURE_FRAG);
          program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
          program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
          break;

         case macro.SHADER_POSITION_TEXTURE_UCOLOR:
          program.initWithVertexShaderByteArray(shaders.POSITION_TEXTURE_UCOLOR_VERT, shaders.POSITION_TEXTURE_UCOLOR_FRAG);
          program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
          program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
          break;

         case macro.SHADER_POSITION_TEXTUREA8COLOR:
          program.initWithVertexShaderByteArray(shaders.POSITION_TEXTURE_A8COLOR_VERT, shaders.POSITION_TEXTURE_A8COLOR_FRAG);
          program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
          program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
          program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
          break;

         case macro.SHADER_POSITION_UCOLOR:
          program.initWithVertexShaderByteArray(shaders.POSITION_UCOLOR_VERT, shaders.POSITION_UCOLOR_FRAG);
          program.addAttribute("aVertex", macro.VERTEX_ATTRIB_POSITION);
          break;

         case macro.SHADER_POSITION_LENGTHTEXTURECOLOR:
          program.initWithVertexShaderByteArray(shaders.POSITION_COLOR_LENGTH_TEXTURE_VERT, shaders.POSITION_COLOR_LENGTH_TEXTURE_FRAG);
          program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
          program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
          program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
          break;

         default:
          cc.logID(8105);
          return;
        }
        program.link();
        program.updateUniforms();
      },
      _reloadShader: function(type) {
        var program = this.programForKey(type);
        program.reset();
        this._loadDefaultShader(program, type);
      },
      loadDefaultShaders: function() {},
      reloadDefaultShaders: function() {
        this._reloadShader(macro.SHADER_POSITION_TEXTURECOLOR);
        this._reloadShader(macro.SHADER_SPRITE_POSITION_TEXTURECOLOR);
        this._reloadShader(macro.SHADER_POSITION_TEXTURECOLORALPHATEST);
        this._reloadShader(macro.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST);
        this._reloadShader(macro.SHADER_POSITION_COLOR);
        this._reloadShader(macro.SHADER_POSITION_TEXTURE);
        this._reloadShader(macro.SHADER_POSITION_TEXTURE_UCOLOR);
        this._reloadShader(macro.SHADER_POSITION_TEXTUREA8COLOR);
        this._reloadShader(macro.SHADER_POSITION_UCOLOR);
      },
      programForKey: function(key) {
        if (!this._programs[key]) {
          var program = new cc.GLProgram();
          this._loadDefaultShader(program, key);
          this._programs[key] = program;
        }
        return this._programs[key];
      },
      getProgram: function(shaderName) {
        return this.programForKey(shaderName);
      },
      addProgram: function(program, key) {
        this._programs[key] = program;
      }
    };
  }), {} ],
  169: [ (function(require, module, exports) {
    cc.PresetShaders = {
      POSITION_UCOLOR_FRAG: "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()\n{\ngl_FragColor = v_fragmentColor;\n}",
      POSITION_UCOLOR_VERT: "attribute vec4 a_position;\nuniform vec4 u_color;\nuniform float u_pointSize;\nvarying lowp vec4 v_fragmentColor;\nvoid main(void)\n{\ngl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;\ngl_PointSize = u_pointSize;\nv_fragmentColor = u_color;\n}",
      POSITION_COLOR_FRAG: "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()\n{\ngl_FragColor = v_fragmentColor;\n}",
      POSITION_COLOR_VERT: "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\ngl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;\nv_fragmentColor = a_color;\n}",
      SPRITE_POSITION_COLOR_VERT: "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\ngl_Position = CC_PMatrix * a_position;\nv_fragmentColor = a_color;\n}",
      POSITION_COLOR_LENGTH_TEXTURE_FRAG: "//#extension GL_OES_standard_derivatives : enable\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()\n{\n//#if defined GL_OES_standard_derivatives\n//gl_FragColor=v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0-length(v_texcoord));\n//#else\ngl_FragColor = v_color * step(0.0, 1.0 - length(v_texcoord));\n//#endif\n}",
      POSITION_COLOR_LENGTH_TEXTURE_VERT: "attribute mediump vec4 a_position;\nattribute mediump vec2 a_texcoord;\nattribute mediump vec4 a_color;\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()\n{\nv_color = a_color;\nv_texcoord = a_texcoord;\ngl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;\n}",
      POSITION_TEXTURE_FRAG: "precision lowp float;\nvarying vec2 v_texCoord;\nvoid main()\n{\ngl_FragColor = texture2D(CC_Texture0, v_texCoord);\n}",
      POSITION_TEXTURE_VERT: "attribute vec4 a_position;\nattribute vec2 a_texCoord;\nvarying mediump vec2 v_texCoord;\nvoid main()\n{\ngl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;\nv_texCoord = a_texCoord;\n}",
      POSITION_TEXTURE_UCOLOR_FRAG: "precision lowp float;\nuniform vec4 u_color;\nvarying vec2 v_texCoord;\nvoid main()\n{\ngl_FragColor=texture2D(CC_Texture0, v_texCoord) * u_color;\n}",
      POSITION_TEXTURE_UCOLOR_VERT: "attribute vec4 a_position;\nattribute vec2 a_texCoord;\nvarying mediump vec2 v_texCoord;\nvoid main()\n{\ngl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;\nv_texCoord = a_texCoord;\n}",
      POSITION_TEXTURE_A8COLOR_FRAG: "precision lowp float;\nvarying vec4 v_fragmentColor;\nvarying vec2 v_texCoord;\nvoid main()\n{\ngl_FragColor = vec4(v_fragmentColor.rgb,\nv_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a);\n}",
      POSITION_TEXTURE_A8COLOR_VERT: "attribute vec4 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvarying mediump vec2 v_texCoord;\nvoid main()\n{\ngl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;\nv_fragmentColor = a_color;\nv_texCoord = a_texCoord;\n}",
      POSITION_TEXTURE_COLOR_FRAG: "precision lowp float;\nvarying vec4 v_fragmentColor;\nvarying vec2 v_texCoord;\nvoid main()\n{\ngl_FragColor = v_fragmentColor * texture2D(CC_Texture0, v_texCoord);\n}",
      POSITION_TEXTURE_COLOR_VERT: "attribute vec4 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvarying mediump vec2 v_texCoord;\nvoid main()\n{\ngl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;\nv_fragmentColor = a_color;\nv_texCoord = a_texCoord;\n}",
      SPRITE_POSITION_TEXTURE_COLOR_VERT: "attribute vec4 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvarying mediump vec2 v_texCoord;\nvoid main()\n{\ngl_Position = CC_PMatrix * a_position;\nv_fragmentColor = a_color;\nv_texCoord = a_texCoord;\n}",
      POSITION_TEXTURE_COLOR_ALPHATEST_FRAG: "precision lowp float;\nvarying vec4 v_fragmentColor;\nvarying vec2 v_texCoord;\nuniform float CC_alpha_value;\nvoid main()\n{\nvec4 texColor=texture2D(CC_Texture0, v_texCoord);\nif(texColor.a <= CC_alpha_value)\n discard; \ngl_FragColor=texColor*v_fragmentColor;\n}",
      EX_SWITCHMASK_FRAG: "precision lowp float;\nvarying vec4 v_fragmentColor;\nvarying vec2 v_texCoord;\nuniform sampler2D u_texture;\nuniform sampler2D u_mask;\nvoid main()\n{\nvec4 texColorc=texture2D(u_texture, v_texCoord);\nvec4 maskColor=texture2D(u_mask, v_texCoord);\nvec4 finalColor=vec4(texColor.r, texColor.g, texColor.b, maskColor.a*texColor.a);\ngl_FragColor=v_fragmentColor*finalColor;\n}"
    };
  }), {} ],
  170: [ (function(require, module, exports) {
    require("./CCShaders");
    require("./CCShaderCache");
    require("./CCGLProgram");
    require("./CCGLStateCache");
  }), {
    "./CCGLProgram": 166,
    "./CCGLStateCache": 167,
    "./CCShaderCache": 168,
    "./CCShaders": 169
  } ],
  171: [ (function(require, module, exports) {
    var __t = function(v) {
      return {
        u: v.x,
        v: v.y
      };
    };
    cc.DrawNode = _ccsg.Node.extend({
      _buffer: null,
      _blendFunc: null,
      _lineWidth: 1,
      _drawColor: null,
      getBlendFunc: function() {
        return this._blendFunc;
      },
      setBlendFunc: function(blendFunc, dst) {
        if (void 0 === dst) {
          this._blendFunc.src = blendFunc.src;
          this._blendFunc.dst = blendFunc.dst;
        } else {
          this._blendFunc.src = blendFunc;
          this._blendFunc.dst = dst;
        }
      },
      setLineWidth: function(width) {
        this._lineWidth = width;
      },
      getLineWidth: function() {
        return this._lineWidth;
      },
      setDrawColor: function(color) {
        var locDrawColor = this._drawColor;
        locDrawColor.r = color.r;
        locDrawColor.g = color.g;
        locDrawColor.b = color.b;
        locDrawColor.a = null == color.a ? 255 : color.a;
      },
      getDrawColor: function() {
        return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a);
      }
    });
    cc.DrawNode.TYPE_DOT = 0;
    cc.DrawNode.TYPE_SEGMENT = 1;
    cc.DrawNode.TYPE_POLY = 2;
    cc.game.once(cc.game.EVENT_RENDERER_INITED, (function() {
      var proto = cc.DrawNode.prototype;
      if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
        cc._DrawNodeElement = function(type, verts, fillColor, lineWidth, lineColor, lineCap, isClosePolygon, isFill, isStroke) {
          var _t = this;
          _t.type = type;
          _t.verts = verts || null;
          _t.fillColor = fillColor || null;
          _t.lineWidth = lineWidth || 0;
          _t.lineColor = lineColor || null;
          _t.lineCap = lineCap || "butt";
          _t.isClosePolygon = isClosePolygon || false;
          _t.isFill = isFill || false;
          _t.isStroke = isStroke || false;
        };
        proto._className = "DrawNodeCanvas";
        proto.ctor = function() {
          _ccsg.Node.prototype.ctor.call(this);
          var locCmd = this._renderCmd;
          locCmd._buffer = this._buffer = [];
          locCmd._drawColor = this._drawColor = cc.color(255, 255, 255, 255);
          locCmd._blendFunc = this._blendFunc = new cc.BlendFunc(cc.macro.SRC_ALPHA, cc.macro.ONE_MINUS_SRC_ALPHA);
          this.init();
        };
        proto.drawRect = function(origin, destination, fillColor, lineWidth, lineColor) {
          lineWidth = null == lineWidth ? this._lineWidth : lineWidth;
          lineColor = lineColor || this.getDrawColor();
          null == lineColor.a && (lineColor.a = 255);
          var vertices = [ origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y) ];
          var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
          element.verts = vertices;
          element.lineWidth = lineWidth;
          element.lineColor = lineColor;
          element.isClosePolygon = true;
          element.isStroke = true;
          element.lineCap = "butt";
          element.fillColor = fillColor;
          if (fillColor) {
            null == fillColor.a && (fillColor.a = 255);
            element.isFill = true;
          }
          this._buffer.push(element);
        };
        proto.drawCircle = function(center, radius, angle, segments, drawLineToCenter, lineWidth, color) {
          lineWidth = lineWidth || this._lineWidth;
          color = color || this.getDrawColor();
          null == color.a && (color.a = 255);
          var coef = 2 * Math.PI / segments;
          var vertices = [];
          for (var i = 0; i <= segments; i++) {
            var rads = i * coef;
            var j = radius * Math.cos(rads + angle) + center.x;
            var k = radius * Math.sin(rads + angle) + center.y;
            vertices.push(cc.p(j, k));
          }
          drawLineToCenter && vertices.push(cc.p(center.x, center.y));
          var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
          element.verts = vertices;
          element.lineWidth = lineWidth;
          element.lineColor = color;
          element.isClosePolygon = true;
          element.isStroke = true;
          this._buffer.push(element);
        };
        proto.drawQuadBezier = function(origin, control, destination, segments, lineWidth, color) {
          lineWidth = lineWidth || this._lineWidth;
          color = color || this.getDrawColor();
          null == color.a && (color.a = 255);
          var vertices = [], t = 0;
          for (var i = 0; i < segments; i++) {
            var x = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
            var y = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
            vertices.push(cc.p(x, y));
            t += 1 / segments;
          }
          vertices.push(cc.p(destination.x, destination.y));
          var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
          element.verts = vertices;
          element.lineWidth = lineWidth;
          element.lineColor = color;
          element.isStroke = true;
          element.lineCap = "round";
          this._buffer.push(element);
        };
        proto.drawCubicBezier = function(origin, control1, control2, destination, segments, lineWidth, color) {
          lineWidth = lineWidth || this._lineWidth;
          color = color || this.getDrawColor();
          null == color.a && (color.a = 255);
          var vertices = [], t = 0;
          for (var i = 0; i < segments; i++) {
            var x = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
            var y = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
            vertices.push(cc.p(x, y));
            t += 1 / segments;
          }
          vertices.push(cc.p(destination.x, destination.y));
          var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
          element.verts = vertices;
          element.lineWidth = lineWidth;
          element.lineColor = color;
          element.isStroke = true;
          element.lineCap = "round";
          this._buffer.push(element);
        };
        proto.drawCatmullRom = function(points, segments, lineWidth, color) {
          this.drawCardinalSpline(points, .5, segments, lineWidth, color);
        };
        proto.drawCardinalSpline = function(config, tension, segments, lineWidth, color) {
          lineWidth = lineWidth || this._lineWidth;
          color = color || this.getDrawColor();
          null == color.a && (color.a = 255);
          var vertices = [], p, lt, deltaT = 1 / config.length;
          for (var i = 0; i < segments + 1; i++) {
            var dt = i / segments;
            if (1 === dt) {
              p = config.length - 1;
              lt = 1;
            } else {
              p = 0 | dt / deltaT;
              lt = (dt - deltaT * p) / deltaT;
            }
            var newPos = cc.cardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p - 0), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
            vertices.push(newPos);
          }
          var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
          element.verts = vertices;
          element.lineWidth = lineWidth;
          element.lineColor = color;
          element.isStroke = true;
          element.lineCap = "round";
          this._buffer.push(element);
        };
        proto.drawDot = function(pos, radius, color) {
          color = color || this.getDrawColor();
          null == color.a && (color.a = 255);
          var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
          element.verts = [ pos ];
          element.lineWidth = radius;
          element.fillColor = color;
          this._buffer.push(element);
        };
        proto.drawDots = function(points, radius, color) {
          if (!points || 0 == points.length) return;
          color = color || this.getDrawColor();
          null == color.a && (color.a = 255);
          for (var i = 0, len = points.length; i < len; i++) this.drawDot(points[i], radius, color);
        };
        proto.drawSegment = function(from, to, lineWidth, color) {
          lineWidth = lineWidth || this._lineWidth;
          color = color || this.getDrawColor();
          null == color.a && (color.a = 255);
          var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
          element.verts = [ from, to ];
          element.lineWidth = 2 * lineWidth;
          element.lineColor = color;
          element.isStroke = true;
          element.lineCap = "round";
          this._buffer.push(element);
        };
        proto.drawPoly_ = function(verts, fillColor, lineWidth, color, notClosePoly) {
          lineWidth = null == lineWidth ? this._lineWidth : lineWidth;
          color = color || this.getDrawColor();
          null == color.a && (color.a = 255);
          var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
          element.verts = verts;
          element.fillColor = fillColor;
          element.lineWidth = lineWidth;
          element.lineColor = color;
          element.isClosePolygon = !notClosePoly;
          element.isStroke = true;
          element.lineCap = "round";
          fillColor && (element.isFill = true);
          this._buffer.push(element);
        };
        proto.drawPoly = function(verts, fillColor, lineWidth, color, notClosePoly) {
          var vertsCopy = [];
          for (var i = 0; i < verts.length; i++) vertsCopy.push(cc.p(verts[i].x, verts[i].y));
          return this.drawPoly_(vertsCopy, fillColor, lineWidth, color, notClosePoly);
        };
        proto.clear = function() {
          this._buffer.length = 0;
        };
        require("./CCDrawNodeCanvasRenderCmd");
        proto._createRenderCmd = function() {
          return new cc.DrawNode.CanvasRenderCmd(this);
        };
      } else if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
        proto._bufferCapacity = 0;
        proto._trianglesArrayBuffer = null;
        proto._trianglesWebBuffer = null;
        proto._trianglesReader = null;
        proto._dirty = false;
        proto._className = "DrawNodeWebGL";
        proto.ctor = function() {
          _ccsg.Node.prototype.ctor.call(this);
          this._buffer = [];
          this._blendFunc = new cc.BlendFunc(cc.macro.SRC_ALPHA, cc.macro.ONE_MINUS_SRC_ALPHA);
          this._drawColor = cc.color(255, 255, 255, 255);
          this.init();
        };
        proto.init = function() {
          if (_ccsg.Node.prototype.init.call(this)) {
            this.shaderProgram = cc.shaderCache.programForKey(cc.macro.SHADER_POSITION_LENGTHTEXTURECOLOR);
            this._ensureCapacity(64);
            this._trianglesWebBuffer = cc._renderContext.createBuffer();
            this._dirty = true;
            return true;
          }
          return false;
        };
        proto.drawRect = function(origin, destination, fillColor, lineWidth, lineColor) {
          lineWidth = null == lineWidth ? this._lineWidth : lineWidth;
          lineColor = lineColor || this.getDrawColor();
          null == lineColor.a && (lineColor.a = 255);
          var vertices = [ origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y) ];
          null == fillColor ? this._drawSegments(vertices, lineWidth, lineColor, true) : this.drawPoly(vertices, fillColor, lineWidth, lineColor);
        };
        proto.drawCircle = function(center, radius, angle, segments, drawLineToCenter, lineWidth, color) {
          lineWidth = lineWidth || this._lineWidth;
          color = color || this.getDrawColor();
          null == color.a && (color.a = 255);
          var coef = 2 * Math.PI / segments, vertices = [], i, len;
          for (i = 0; i <= segments; i++) {
            var rads = i * coef;
            var j = radius * Math.cos(rads + angle) + center.x;
            var k = radius * Math.sin(rads + angle) + center.y;
            vertices.push(cc.p(j, k));
          }
          drawLineToCenter && vertices.push(cc.p(center.x, center.y));
          lineWidth *= .5;
          for (i = 0, len = vertices.length; i < len - 1; i++) this.drawSegment(vertices[i], vertices[i + 1], lineWidth, color);
        };
        proto.drawQuadBezier = function(origin, control, destination, segments, lineWidth, color) {
          lineWidth = lineWidth || this._lineWidth;
          color = color || this.getDrawColor();
          null == color.a && (color.a = 255);
          var vertices = [], t = 0;
          for (var i = 0; i < segments; i++) {
            var x = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
            var y = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
            vertices.push(cc.p(x, y));
            t += 1 / segments;
          }
          vertices.push(cc.p(destination.x, destination.y));
          this._drawSegments(vertices, lineWidth, color, false);
        };
        proto.drawCubicBezier = function(origin, control1, control2, destination, segments, lineWidth, color) {
          lineWidth = lineWidth || this._lineWidth;
          color = color || this.getDrawColor();
          null == color.a && (color.a = 255);
          var vertices = [], t = 0;
          for (var i = 0; i < segments; i++) {
            var x = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
            var y = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
            vertices.push(cc.p(x, y));
            t += 1 / segments;
          }
          vertices.push(cc.p(destination.x, destination.y));
          this._drawSegments(vertices, lineWidth, color, false);
        };
        proto.drawCatmullRom = function(points, segments, lineWidth, color) {
          this.drawCardinalSpline(points, .5, segments, lineWidth, color);
        };
        proto.drawCardinalSpline = function(config, tension, segments, lineWidth, color) {
          lineWidth = lineWidth || this._lineWidth;
          color = color || this.getDrawColor();
          null == color.a && (color.a = 255);
          var vertices = [], p, lt, deltaT = 1 / config.length;
          for (var i = 0; i < segments + 1; i++) {
            var dt = i / segments;
            if (1 === dt) {
              p = config.length - 1;
              lt = 1;
            } else {
              p = 0 | dt / deltaT;
              lt = (dt - deltaT * p) / deltaT;
            }
            var newPos = cc.cardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p - 0), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
            vertices.push(newPos);
          }
          lineWidth *= .5;
          for (var j = 0, len = vertices.length; j < len - 1; j++) this.drawSegment(vertices[j], vertices[j + 1], lineWidth, color);
        };
        proto._render = function() {
          var gl = cc._renderContext;
          gl.bindBuffer(gl.ARRAY_BUFFER, this._trianglesWebBuffer);
          if (this._dirty) {
            gl.bufferData(gl.ARRAY_BUFFER, this._trianglesArrayBuffer, gl.STREAM_DRAW);
            this._dirty = false;
          }
          var triangleSize = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
          gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_POSITION);
          gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_COLOR);
          gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_TEX_COORDS);
          gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_POSITION, 2, gl.FLOAT, false, triangleSize, 0);
          gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, triangleSize, 8);
          gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, triangleSize, 12);
          gl.drawArrays(gl.TRIANGLES, 0, 3 * this._buffer.length);
          cc.incrementGLDraws(1);
        };
        proto._ensureCapacity = function(count) {
          var _t = this;
          var locBuffer = _t._buffer;
          if (locBuffer.length + count > _t._bufferCapacity) {
            var TriangleLength = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
            _t._bufferCapacity += Math.max(_t._bufferCapacity, count);
            if (null == locBuffer || 0 === locBuffer.length) {
              _t._buffer = [];
              _t._trianglesArrayBuffer = new ArrayBuffer(TriangleLength * _t._bufferCapacity);
              _t._trianglesReader = new Uint8Array(_t._trianglesArrayBuffer);
            } else {
              var newTriangles = [];
              var newArrayBuffer = new ArrayBuffer(TriangleLength * _t._bufferCapacity);
              for (var i = 0; i < locBuffer.length; i++) newTriangles[i] = new cc.V2F_C4B_T2F_Triangle(locBuffer[i].a, locBuffer[i].b, locBuffer[i].c, newArrayBuffer, i * TriangleLength);
              _t._trianglesReader = new Uint8Array(newArrayBuffer);
              _t._trianglesArrayBuffer = newArrayBuffer;
              _t._buffer = newTriangles;
            }
          }
        };
        proto.drawDot = function(pos, radius, color) {
          color = color || this.getDrawColor();
          null == color.a && (color.a = 255);
          var c4bColor = {
            r: 0 | color.r,
            g: 0 | color.g,
            b: 0 | color.b,
            a: 0 | color.a
          };
          var a = {
            vertices: {
              x: pos.x - radius,
              y: pos.y - radius
            },
            colors: c4bColor,
            texCoords: {
              u: -1,
              v: -1
            }
          };
          var b = {
            vertices: {
              x: pos.x - radius,
              y: pos.y + radius
            },
            colors: c4bColor,
            texCoords: {
              u: -1,
              v: 1
            }
          };
          var c = {
            vertices: {
              x: pos.x + radius,
              y: pos.y + radius
            },
            colors: c4bColor,
            texCoords: {
              u: 1,
              v: 1
            }
          };
          var d = {
            vertices: {
              x: pos.x + radius,
              y: pos.y - radius
            },
            colors: c4bColor,
            texCoords: {
              u: 1,
              v: -1
            }
          };
          this._ensureCapacity(6);
          this._buffer.push(new cc.V2F_C4B_T2F_Triangle(a, b, c, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
          this._buffer.push(new cc.V2F_C4B_T2F_Triangle(a, c, d, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
          this._dirty = true;
        };
        proto.drawDots = function(points, radius, color) {
          if (!points || 0 === points.length) return;
          color = color || this.getDrawColor();
          null == color.a && (color.a = 255);
          for (var i = 0, len = points.length; i < len; i++) this.drawDot(points[i], radius, color);
        };
        proto.drawSegment = function(from, to, radius, color) {
          color = color || this.getDrawColor();
          null == color.a && (color.a = 255);
          radius = radius || .5 * this._lineWidth;
          var vertexCount = 18;
          this._ensureCapacity(vertexCount);
          var c4bColor = {
            r: 0 | color.r,
            g: 0 | color.g,
            b: 0 | color.b,
            a: 0 | color.a
          };
          var a = cc.v2(from), b = cc.v2(to);
          var n = cc.pNormalize(cc.pPerp(cc.pSub(b, a))), t = cc.pPerp(n);
          var nw = cc.pMult(n, radius), tw = cc.pMult(t, radius);
          var v0 = cc.pSub(b, cc.pAdd(nw, tw));
          var v1 = cc.pAdd(b, cc.pSub(nw, tw));
          var v2 = cc.pSub(b, nw);
          var v3 = cc.pAdd(b, nw);
          var v4 = cc.pSub(a, nw);
          var v5 = cc.pAdd(a, nw);
          var v6 = cc.pSub(a, cc.pSub(nw, tw));
          var v7 = cc.pAdd(a, cc.pAdd(nw, tw));
          var TriangleLength = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, triangleBuffer = this._trianglesArrayBuffer, locBuffer = this._buffer;
          locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: v0,
            colors: c4bColor,
            texCoords: __t(cc.pNeg(cc.pAdd(n, t)))
          }, {
            vertices: v1,
            colors: c4bColor,
            texCoords: __t(cc.pSub(n, t))
          }, {
            vertices: v2,
            colors: c4bColor,
            texCoords: __t(cc.pNeg(n))
          }, triangleBuffer, locBuffer.length * TriangleLength));
          locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: v3,
            colors: c4bColor,
            texCoords: __t(n)
          }, {
            vertices: v1,
            colors: c4bColor,
            texCoords: __t(cc.pSub(n, t))
          }, {
            vertices: v2,
            colors: c4bColor,
            texCoords: __t(cc.pNeg(n))
          }, triangleBuffer, locBuffer.length * TriangleLength));
          locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: v3,
            colors: c4bColor,
            texCoords: __t(n)
          }, {
            vertices: v4,
            colors: c4bColor,
            texCoords: __t(cc.pNeg(n))
          }, {
            vertices: v2,
            colors: c4bColor,
            texCoords: __t(cc.pNeg(n))
          }, triangleBuffer, locBuffer.length * TriangleLength));
          locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: v3,
            colors: c4bColor,
            texCoords: __t(n)
          }, {
            vertices: v4,
            colors: c4bColor,
            texCoords: __t(cc.pNeg(n))
          }, {
            vertices: v5,
            colors: c4bColor,
            texCoords: __t(n)
          }, triangleBuffer, locBuffer.length * TriangleLength));
          locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: v6,
            colors: c4bColor,
            texCoords: __t(cc.pSub(t, n))
          }, {
            vertices: v4,
            colors: c4bColor,
            texCoords: __t(cc.pNeg(n))
          }, {
            vertices: v5,
            colors: c4bColor,
            texCoords: __t(n)
          }, triangleBuffer, locBuffer.length * TriangleLength));
          locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: v6,
            colors: c4bColor,
            texCoords: __t(cc.pSub(t, n))
          }, {
            vertices: v7,
            colors: c4bColor,
            texCoords: __t(cc.pAdd(n, t))
          }, {
            vertices: v5,
            colors: c4bColor,
            texCoords: __t(n)
          }, triangleBuffer, locBuffer.length * TriangleLength));
          this._dirty = true;
        };
        proto.drawPoly = function(verts, fillColor, borderWidth, borderColor, notClosePoly) {
          if (null == fillColor) {
            this._drawSegments(verts, borderWidth, borderColor, !notClosePoly);
            return;
          }
          null == fillColor.a && (fillColor.a = 255);
          null == borderColor.a && (borderColor.a = 255);
          borderWidth = null == borderWidth ? this._lineWidth : borderWidth;
          borderWidth *= .5;
          var c4bFillColor = {
            r: 0 | fillColor.r,
            g: 0 | fillColor.g,
            b: 0 | fillColor.b,
            a: 0 | fillColor.a
          };
          var c4bBorderColor = {
            r: 0 | borderColor.r,
            g: 0 | borderColor.g,
            b: 0 | borderColor.b,
            a: 0 | borderColor.a
          };
          var extrude = [], i, v0, v1, v2, count = verts.length;
          for (i = 0; i < count; i++) {
            v0 = cc.v2(verts[(i - 1 + count) % count]);
            v1 = cc.v2(verts[i]);
            v2 = cc.v2(verts[(i + 1) % count]);
            var n1 = cc.pNormalize(cc.pPerp(cc.pSub(v1, v0)));
            var n2 = cc.pNormalize(cc.pPerp(cc.pSub(v2, v1)));
            var offset = cc.pMult(cc.pAdd(n1, n2), 1 / (cc.pDot(n1, n2) + 1));
            extrude[i] = {
              offset: offset,
              n: n2
            };
          }
          var outline = borderWidth > 0, triangleCount = 3 * count - 2, vertexCount = 3 * triangleCount;
          this._ensureCapacity(vertexCount);
          var triangleBytesLen = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, trianglesBuffer = this._trianglesArrayBuffer;
          var locBuffer = this._buffer;
          var va, vb, vc;
          for (i = 0; i < count - 2; i++) {
            va = {
              vertices: verts[0],
              colors: c4bFillColor,
              texCoords: __t(cc.v2())
            };
            vb = {
              vertices: verts[i + 1],
              colors: c4bFillColor,
              texCoords: __t(cc.v2())
            };
            vc = {
              vertices: verts[i + 2],
              colors: c4bFillColor,
              texCoords: __t(cc.v2())
            };
            locBuffer.push(new cc.V2F_C4B_T2F_Triangle(va, vb, vc, trianglesBuffer, locBuffer.length * triangleBytesLen));
          }
          if (outline) for (i = 0; i < count; i++) {
            var j = (i + 1) % count;
            v0 = cc.v2(verts[i]);
            v1 = cc.v2(verts[j]);
            var n0 = extrude[i].n;
            var offset0 = extrude[i].offset;
            var offset1 = extrude[j].offset;
            var inner0 = cc.pSub(v0, cc.pMult(offset0, borderWidth));
            var inner1 = cc.pSub(v1, cc.pMult(offset1, borderWidth));
            var outer0 = cc.pAdd(v0, cc.pMult(offset0, borderWidth));
            var outer1 = cc.pAdd(v1, cc.pMult(offset1, borderWidth));
            va = {
              vertices: inner0,
              colors: c4bBorderColor,
              texCoords: __t(cc.pNeg(n0))
            };
            vb = {
              vertices: inner1,
              colors: c4bBorderColor,
              texCoords: __t(cc.pNeg(n0))
            };
            vc = {
              vertices: outer1,
              colors: c4bBorderColor,
              texCoords: __t(n0)
            };
            locBuffer.push(new cc.V2F_C4B_T2F_Triangle(va, vb, vc, trianglesBuffer, locBuffer.length * triangleBytesLen));
            va = {
              vertices: inner0,
              colors: c4bBorderColor,
              texCoords: __t(cc.pNeg(n0))
            };
            vb = {
              vertices: outer0,
              colors: c4bBorderColor,
              texCoords: __t(n0)
            };
            vc = {
              vertices: outer1,
              colors: c4bBorderColor,
              texCoords: __t(n0)
            };
            locBuffer.push(new cc.V2F_C4B_T2F_Triangle(va, vb, vc, trianglesBuffer, locBuffer.length * triangleBytesLen));
          }
          extrude = null;
          this._dirty = true;
        };
        proto._drawSegments = function(verts, borderWidth, borderColor, closePoly) {
          borderWidth = null == borderWidth ? this._lineWidth : borderWidth;
          borderColor = borderColor || this._drawColor;
          null == borderColor.a && (borderColor.a = 255);
          borderWidth *= .5;
          if (borderWidth <= 0) return;
          var c4bBorderColor = {
            r: 0 | borderColor.r,
            g: 0 | borderColor.g,
            b: 0 | borderColor.b,
            a: 0 | borderColor.a
          };
          var extrude = [], i, v0, v1, v2, count = verts.length;
          for (i = 0; i < count; i++) {
            v0 = cc.v2(verts[(i - 1 + count) % count]);
            v1 = cc.v2(verts[i]);
            v2 = cc.v2(verts[(i + 1) % count]);
            var n1 = cc.pNormalize(cc.pPerp(cc.pSub(v1, v0)));
            var n2 = cc.pNormalize(cc.pPerp(cc.pSub(v2, v1)));
            var offset = cc.pMult(cc.pAdd(n1, n2), 1 / (cc.pDot(n1, n2) + 1));
            extrude[i] = {
              offset: offset,
              n: n2
            };
          }
          var triangleCount = 3 * count - 2, vertexCount = 3 * triangleCount;
          this._ensureCapacity(vertexCount);
          var triangleBytesLen = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, trianglesBuffer = this._trianglesArrayBuffer;
          var locBuffer = this._buffer;
          var len = closePoly ? count : count - 1;
          for (i = 0; i < len; i++) {
            var j = (i + 1) % count;
            v0 = cc.v2(verts[i]);
            v1 = cc.v2(verts[j]);
            var n0 = extrude[i].n;
            var offset0 = extrude[i].offset;
            var offset1 = extrude[j].offset;
            var inner0 = cc.pSub(v0, cc.pMult(offset0, borderWidth));
            var inner1 = cc.pSub(v1, cc.pMult(offset1, borderWidth));
            var outer0 = cc.pAdd(v0, cc.pMult(offset0, borderWidth));
            var outer1 = cc.pAdd(v1, cc.pMult(offset1, borderWidth));
            locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
              vertices: inner0,
              colors: c4bBorderColor,
              texCoords: __t(cc.pNeg(n0))
            }, {
              vertices: inner1,
              colors: c4bBorderColor,
              texCoords: __t(cc.pNeg(n0))
            }, {
              vertices: outer1,
              colors: c4bBorderColor,
              texCoords: __t(n0)
            }, trianglesBuffer, locBuffer.length * triangleBytesLen));
            locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
              vertices: inner0,
              colors: c4bBorderColor,
              texCoords: __t(cc.pNeg(n0))
            }, {
              vertices: outer0,
              colors: c4bBorderColor,
              texCoords: __t(n0)
            }, {
              vertices: outer1,
              colors: c4bBorderColor,
              texCoords: __t(n0)
            }, trianglesBuffer, locBuffer.length * triangleBytesLen));
          }
          extrude = null;
          this._dirty = true;
        };
        proto.clear = function() {
          this._buffer.length = 0;
          this._dirty = true;
        };
        require("./CCDrawNodeWebGLRenderCmd");
        proto._createRenderCmd = function() {
          return new cc.DrawNode.WebGLRenderCmd(this);
        };
      }
    }));
  }), {
    "./CCDrawNodeCanvasRenderCmd": 172,
    "./CCDrawNodeWebGLRenderCmd": 173
  } ],
  172: [ (function(require, module, exports) {
    cc.DrawNode.CanvasRenderCmd = function(renderableObject) {
      this._rootCtor(renderableObject);
      this._needDraw = true;
      this._buffer = null;
      this._drawColor = null;
      this._blendFunc = null;
    };
    var proto = cc.DrawNode.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
    proto.constructor = cc.DrawNode.CanvasRenderCmd;
    proto.rendering = function(ctx, scaleX, scaleY) {
      var wrapper = ctx || cc._renderContext, context = wrapper.getContext(), node = this._node;
      var alpha = node._displayedOpacity / 255;
      if (0 === alpha) return;
      wrapper.setTransform(this._worldTransform, scaleX, scaleY);
      wrapper.setGlobalAlpha(alpha);
      this._blendFunc && this._blendFunc.src === cc.macro.SRC_ALPHA && this._blendFunc.dst === cc.macro.ONE && wrapper.setCompositeOperation("lighter");
      var locBuffer = this._buffer;
      for (var i = 0, len = locBuffer.length; i < len; i++) {
        var element = locBuffer[i];
        switch (element.type) {
         case cc.DrawNode.TYPE_DOT:
          this._drawDot(wrapper, element, scaleX, scaleY);
          break;

         case cc.DrawNode.TYPE_SEGMENT:
          this._drawSegment(wrapper, element, scaleX, scaleY);
          break;

         case cc.DrawNode.TYPE_POLY:
          this._drawPoly(wrapper, element, scaleX, scaleY);
        }
      }
    };
    proto._drawDot = function(wrapper, element, scaleX, scaleY) {
      var locColor = element.fillColor, locPos = element.verts[0], locRadius = element.lineWidth;
      var ctx = wrapper.getContext();
      wrapper.setFillStyle("rgba(" + (0 | locColor.r) + "," + (0 | locColor.g) + "," + (0 | locColor.b) + "," + locColor.a / 255 + ")");
      ctx.beginPath();
      ctx.arc(locPos.x, -locPos.y, locRadius, 0, 2 * Math.PI, false);
      ctx.closePath();
      ctx.fill();
    };
    proto._drawSegment = function(wrapper, element, scaleX, scaleY) {
      var locColor = element.lineColor;
      var locFrom = element.verts[0], locTo = element.verts[1];
      var locLineWidth = element.lineWidth, locLineCap = element.lineCap;
      var ctx = wrapper.getContext();
      wrapper.setStrokeStyle("rgba(" + (0 | locColor.r) + "," + (0 | locColor.g) + "," + (0 | locColor.b) + "," + locColor.a / 255 + ")");
      ctx.lineWidth = locLineWidth * scaleX;
      ctx.beginPath();
      ctx.lineCap = locLineCap;
      ctx.moveTo(locFrom.x, -locFrom.y);
      ctx.lineTo(locTo.x, -locTo.y);
      ctx.stroke();
    };
    proto._drawPoly = function(wrapper, element, scaleX, scaleY) {
      var locVertices = element.verts, locLineCap = element.lineCap;
      if (null == locVertices) return;
      var locFillColor = element.fillColor, locLineWidth = element.lineWidth;
      var locLineColor = element.lineColor, locIsClosePolygon = element.isClosePolygon;
      var locIsFill = element.isFill, locIsStroke = element.isStroke;
      var ctx = wrapper.getContext();
      var firstPoint = locVertices[0];
      ctx.lineCap = locLineCap;
      locFillColor && wrapper.setFillStyle("rgba(" + (0 | locFillColor.r) + "," + (0 | locFillColor.g) + "," + (0 | locFillColor.b) + "," + locFillColor.a / 255 + ")");
      locLineWidth && (ctx.lineWidth = locLineWidth * scaleX);
      locLineColor && wrapper.setStrokeStyle("rgba(" + (0 | locLineColor.r) + "," + (0 | locLineColor.g) + "," + (0 | locLineColor.b) + "," + locLineColor.a / 255 + ")");
      ctx.beginPath();
      ctx.moveTo(firstPoint.x, -firstPoint.y);
      for (var i = 1, len = locVertices.length; i < len; i++) ctx.lineTo(locVertices[i].x, -locVertices[i].y);
      locIsClosePolygon && ctx.closePath();
      locIsFill && ctx.fill();
      locIsStroke && ctx.stroke();
    };
  }), {} ],
  173: [ (function(require, module, exports) {
    cc.DrawNode.WebGLRenderCmd = function(renderableObject) {
      this._rootCtor(renderableObject);
      this._needDraw = true;
      this._matrix = new cc.math.Matrix4();
      this._matrix.identity();
    };
    cc.DrawNode.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
    cc.DrawNode.WebGLRenderCmd.prototype.constructor = cc.DrawNode.WebGLRenderCmd;
    cc.DrawNode.WebGLRenderCmd.prototype.rendering = function(ctx) {
      var node = this._node;
      if (node._buffer.length > 0) {
        var wt = this._worldTransform, mat = this._matrix.mat;
        mat[0] = wt.a;
        mat[4] = wt.c;
        mat[12] = wt.tx;
        mat[1] = wt.b;
        mat[5] = wt.d;
        mat[13] = wt.ty;
        cc.gl.blendFunc(node._blendFunc.src, node._blendFunc.dst);
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix);
        node._render();
      }
    };
  }), {} ],
  174: [ (function(require, module, exports) {
    require("./cocos2d/core");
    require("./cocos2d/animation");
    false;
    require("./cocos2d/particle/CCParticleSystem");
    require("./cocos2d/tilemap/CCTiledMap");
    require("./cocos2d/motion-streak/CCMotionStreak");
    require("./cocos2d/core/components/CCStudioComponent");
    require("./extensions/ccpool/CCNodePool");
    require("./extensions/ccpool/CCPool");
    true;
    require("./cocos2d/actions");
    require("./extensions/spine");
    require("./extensions/dragonbones");
    true;
    require("./cocos2d/deprecated");
  }), {
    "./cocos2d/actions": 179,
    "./cocos2d/animation": 179,
    "./cocos2d/core": 64,
    "./cocos2d/core/components/CCStudioComponent": 179,
    "./cocos2d/deprecated": 151,
    "./cocos2d/motion-streak/CCMotionStreak": 179,
    "./cocos2d/particle/CCParticleAsset": 179,
    "./cocos2d/particle/CCParticleSystem": 179,
    "./cocos2d/tilemap/CCTiledMap": 179,
    "./cocos2d/tilemap/CCTiledMapAsset": 179,
    "./extensions/ccpool/CCNodePool": 175,
    "./extensions/ccpool/CCPool": 176,
    "./extensions/dragonbones": 179,
    "./extensions/spine": 179
  } ],
  175: [ (function(require, module, exports) {
    cc.NodePool = function(poolHandlerComp) {
      this.poolHandlerComp = poolHandlerComp;
      this._pool = [];
    };
    cc.NodePool.prototype = {
      constructor: cc.NodePool,
      size: function() {
        return this._pool.length;
      },
      clear: function() {
        var count = this._pool.length;
        for (var i = 0; i < count; ++i) this._pool[i].destroy();
        this._pool.length = 0;
      },
      put: function(obj) {
        if (obj && -1 === this._pool.indexOf(obj)) {
          obj.removeFromParent(false);
          var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
          handler && handler.unuse && handler.unuse();
          this._pool.push(obj);
        }
      },
      get: function() {
        var last = this._pool.length - 1;
        if (last < 0) return null;
        var obj = this._pool[last];
        this._pool.length = last;
        var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
        handler && handler.reuse && handler.reuse.apply(handler, arguments);
        return obj;
      }
    };
    module.exports = cc.NodePool;
  }), {} ],
  176: [ (function(require, module, exports) {
    var _args = [];
    cc.pool = {
      _pool: {},
      _releaseCB: function() {
        this.release();
      },
      _autoRelease: function(obj) {
        var running = void 0 !== obj._running && !obj._running;
        cc.director.getScheduler().schedule(this._releaseCB, obj, 0, 0, 0, running);
      },
      putInPool: function(obj) {
        var cid = cc.js._getClassId(obj.constructor);
        if (!cid) return;
        this._pool[cid] || (this._pool[cid] = []);
        obj.unuse && obj.unuse();
        this._pool[cid].push(obj);
      },
      hasObject: function(objClass) {
        var cid = cc.js._getClassId(objClass);
        var list = this._pool[cid];
        if (!list || 0 === list.length) return false;
        return true;
      },
      removeObject: function(obj) {
        var cid = cc.js._getClassId(obj.constructor);
        if (cid) {
          var list = this._pool[cid];
          if (list) for (var i = 0; i < list.length; i++) obj === list[i] && list.splice(i, 1);
        }
      },
      getFromPool: function(objClass) {
        if (this.hasObject(objClass)) {
          var cid = cc.js._getClassId(objClass);
          var list = this._pool[cid];
          _args.length = arguments.length - 1;
          for (var i = 0; i < _args.length; i++) _args[i] = arguments[i + 1];
          var obj = list.pop();
          obj.reuse && obj.reuse.apply(obj, _args);
          _args.length = 0;
          return obj;
        }
      },
      drainAllPools: function() {
        var i;
        var j;
        var obj;
        false;
        this._pool = {};
      }
    };
  }), {} ],
  177: [ (function(require, module, exports) {
    module.exports = (function() {
      "use strict";
      function t() {
        "undefined" === typeof window.performance && (window.performance = {});
        if (!window.performance.now) {
          var t = Date.now();
          performance.timing && performance.timing.navigationStart && (t = performance.timing.navigationStart);
          window.performance.now = function e() {
            return Date.now() - t;
          };
        }
        window.performance.mark || (window.performance.mark = function() {});
        window.performance.measure || (window.performance.measure = function() {});
        window.performance.memory || (window.performance.memory = {
          usedJSHeapSize: 0,
          totalJSHeapSize: 0
        });
      }
      var e = Math.round(window.devicePixelRatio || 1);
      var i = function t(e, i) {
        this._color = i || "#666";
        this._canvas = document.createElement("canvas");
        this._ctx = this._canvas.getContext("2d");
        this._canvas.className = "pstats-canvas";
        e.appendChild(this._canvas);
      };
      i.prototype.init = function t(i, a) {
        var n = i * e;
        var s = a * e;
        this._canvas.width = n;
        this._canvas.height = s;
        this._canvas.style.width = i + "px";
        this._canvas.style.height = a + "px";
        this._ctx.globalAlpha = 1;
        this._ctx.fillStyle = "#444";
        this._ctx.fillRect(0, 0, n, s);
      };
      var a = Math.round(window.devicePixelRatio || 1);
      var n = (function(t) {
        function e(e, i) {
          t.call(this, e, i);
          this._current = 0;
          this._max = 0;
        }
        t && (e.__proto__ = t);
        e.prototype = Object.create(t && t.prototype);
        e.prototype.constructor = e;
        e.prototype.draw = function t(e, i) {
          var n = this._canvas.width;
          var s = this._canvas.height;
          this._current += .1 * (e - this._current);
          this._max *= .99;
          this._current > this._max && (this._max = this._current);
          var o = Math.round((1 - this._current / this._max) * s);
          this._ctx.globalAlpha = 1;
          this._ctx.drawImage(this._canvas, a, 0, n - a, s, 0, 0, n - a, s);
          if (i) {
            this._ctx.fillStyle = "#444";
            this._ctx.fillRect(n - a, 0, a, s);
            this._ctx.fillStyle = "#b70000";
            this._ctx.fillRect(n - a, o, a, s - o);
            this._ctx.globalAlpha = .5;
            this._ctx.fillStyle = "#fff";
            this._ctx.fillRect(n - a, o, a, a);
          } else {
            this._ctx.fillStyle = "#444";
            this._ctx.fillRect(n - a, 0, a, s);
            this._ctx.fillStyle = this._color;
            this._ctx.fillRect(n - a, o, a, s - o);
            this._ctx.globalAlpha = .5;
            this._ctx.fillStyle = "#fff";
            this._ctx.fillRect(n - a, o, a, a);
          }
        };
        return e;
      })(i);
      var s = Math.round(window.devicePixelRatio || 1);
      var o = (function(t) {
        function e(e, i) {
          t.call(this, e, i);
          this._threshold = 0;
          this._canvas2 = document.createElement("canvas");
          this._ctx2 = this._canvas2.getContext("2d");
        }
        t && (e.__proto__ = t);
        e.prototype = Object.create(t && t.prototype);
        e.prototype.constructor = e;
        e.prototype.init = function e(i, a) {
          t.prototype.init.call(this, i, a);
          var n = i * s;
          var o = a * s;
          this._canvas2.width = n;
          this._canvas2.height = o;
          this._canvas2.style.width = i + "px";
          this._canvas2.style.height = a + "px";
          this._ctx2.globalAlpha = 1;
          this._ctx2.fillStyle = "#444";
          this._ctx2.fillRect(0, 0, n, o);
        };
        e.prototype.draw = function t(e, i) {
          var a = this._canvas.width;
          var n = this._canvas.height;
          this._ctx.globalAlpha = 1;
          this._ctx2.globalAlpha = 1;
          if (e > this._threshold) {
            var o = (e - e % n) / n;
            var r = n * (o + 1);
            var l = this._threshold;
            this._threshold = r;
            var c = l / r;
            this._ctx2.drawImage(this._canvas, 0, 0);
            this._ctx.fillStyle = "#444";
            this._ctx.fillRect(0, 0, a, n);
            this._ctx.drawImage(this._canvas2, s, 0, a - s, n, 0, Math.round((1 - c) * n), a - s, n);
          } else this._ctx.drawImage(this._canvas, s, 0, a - s, n, 0, 0, a - s, n);
          var h = Math.round(n * (1 - e / this._threshold));
          if (i) {
            this._ctx.fillStyle = "#444";
            this._ctx.fillRect(a - s, 0, s, n);
            this._ctx.fillStyle = "#b70000";
            this._ctx.fillRect(a - s, h, s, n - h);
            this._ctx.globalAlpha = .5;
            this._ctx.fillStyle = "#fff";
            this._ctx.fillRect(a - s, h, s, s);
          } else {
            this._ctx.fillStyle = "#444";
            this._ctx.fillRect(a - s, 0, s, n);
            this._ctx.fillStyle = this._color;
            this._ctx.fillRect(a - s, h, s, n - h);
            this._ctx.globalAlpha = .5;
            this._ctx.fillStyle = "#fff";
            this._ctx.fillRect(a - s, h, s, s);
          }
        };
        return e;
      })(i);
      var r = Math.round(window.devicePixelRatio || 1);
      var l = (function(t) {
        function e(e, i, a, n) {
          t.call(this, e, i);
          this._min = a;
          this._max = n;
        }
        t && (e.__proto__ = t);
        e.prototype = Object.create(t && t.prototype);
        e.prototype.constructor = e;
        e.prototype.draw = function t(e, i) {
          var a = this._canvas.width;
          var n = this._canvas.height;
          var s = (e - this._min) / (this._max - this._min);
          var o = Math.round((1 - s) * n);
          this._ctx.globalAlpha = 1;
          this._ctx.drawImage(this._canvas, r, 0, a - r, n, 0, 0, a - r, n);
          if (i) {
            this._ctx.fillStyle = "#444";
            this._ctx.fillRect(a - r, 0, r, n);
            this._ctx.fillStyle = "#b70000";
            this._ctx.fillRect(a - r, o, r, n - o);
            this._ctx.globalAlpha = .5;
            this._ctx.fillStyle = "#fff";
            this._ctx.fillRect(a - r, o, r, r);
          } else {
            this._ctx.fillStyle = "#444";
            this._ctx.fillRect(a - r, 0, r, n);
            this._ctx.fillStyle = this._color;
            this._ctx.fillRect(a - r, o, r, n - o);
            this._ctx.globalAlpha = .5;
            this._ctx.fillStyle = "#fff";
            this._ctx.fillRect(a - r, o, r, r);
          }
        };
        return e;
      })(i);
      var c = Math.round(window.devicePixelRatio || 1);
      var h = function t(e, i) {
        this._colors = i;
        this._canvas = document.createElement("canvas");
        this._ctx = this._canvas.getContext("2d");
        this._canvas.className = "pstats-canvas";
        e.appendChild(this._canvas);
      };
      h.prototype.init = function t(e, i, a) {
        var n = e * c;
        var s = i * c;
        this._canvas.width = n;
        this._canvas.height = s * a;
        this._canvas.style.width = e + "px";
        this._canvas.style.height = i * a + "px";
        this._ctx.globalAlpha = 1;
        this._ctx.fillStyle = "#444";
        this._ctx.fillRect(0, 0, n, s * a);
      };
      h.prototype.draw = function t(e) {
        var i = this;
        var a = this._canvas.width;
        var n = this._canvas.height;
        this._ctx.globalAlpha = 1;
        this._ctx.drawImage(this._canvas, c, 0, a - c, n, 0, 0, a - c, n);
        var s = 0;
        for (var o = 0; o < e.length; ++o) {
          var r = e[o] * n;
          i._ctx.fillStyle = i._colors[o];
          i._ctx.fillRect(a - c, s, c, r);
          s += r;
        }
      };
      var p = function t(e, i) {
        this._id = e;
        this._opts = i || {};
        this._value = 0;
        this._total = 0;
        this._averageValue = 0;
        this._accumValue = 0;
        this._accumSamples = 0;
        this._accumStart = window.performance.now();
      };
      var _ = {
        value: {}
      };
      p.prototype._average = function t(e) {
        if (this._opts.average) {
          this._accumValue += e;
          ++this._accumSamples;
          var i = performance.now();
          if (i - this._accumStart >= this._opts.average) {
            this._averageValue = this._accumValue / this._accumSamples;
            this._accumValue = 0;
            this._accumStart = i;
            this._accumSamples = 0;
          }
        }
      };
      _.value.get = function() {
        return this._value;
      };
      _.value.set = function(t) {
        this._value = t;
      };
      p.prototype.sample = function t() {
        this._average(this._value);
      };
      p.prototype.human = function t() {
        var e = this._opts.average ? this._averageValue : this._value;
        return Math.round(100 * e) / 100;
      };
      p.prototype.alarm = function t() {
        return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over;
      };
      Object.defineProperties(p.prototype, _);
      var f = (function(t) {
        function e(e, i) {
          t.call(this, e, i);
          this._time = window.performance.now();
        }
        t && (e.__proto__ = t);
        e.prototype = Object.create(t && t.prototype);
        e.prototype.constructor = e;
        e.prototype.start = function t() {
          this._time = window.performance.now();
        };
        e.prototype.end = function t() {
          this._value = window.performance.now() - this._time;
          this._average(this._value);
        };
        e.prototype.tick = function t() {
          this.end();
          this.start();
        };
        e.prototype.frame = function t() {
          var e = window.performance.now();
          var i = e - this._time;
          this._total++;
          var a = this._opts.average || 1e3;
          if (i > a) {
            this._value = 1e3 * this._total / i;
            this._total = 0;
            this._time = e;
            this._average(this._value);
          }
        };
        return e;
      })(p);
      var u = Math.log(1024);
      var v = [ "Bytes", "KB", "MB", "GB", "TB" ];
      function d(t) {
        var e = 100;
        var i = Math.floor(Math.log(t) / u);
        if (0 === t) return "n/a";
        return Math.round(t * e / Math.pow(1024, i)) / e + " " + v[i];
      }
      var m = (function(t) {
        function e(e, i, a) {
          t.call(this, i, a);
          this._stats = e;
          this._start = 0;
          0 === a.extension.indexOf("memory.") && (this._field = a.extension.substring(7));
        }
        t && (e.__proto__ = t);
        e.prototype = Object.create(t && t.prototype);
        e.prototype.constructor = e;
        e.prototype.snapshot = function t() {
          this._value = this._stats[this._field];
        };
        e.prototype.start = function t() {
          this._start = this._stats[this._field];
        };
        e.prototype.end = function t() {
          this._value = this._stats[this._field] - this._start;
        };
        e.prototype.human = function e() {
          return d(t.prototype.human.call(this));
        };
        return e;
      })(p);
      var x = function t() {
        var e = window.performance.memory;
        0 === e.totalJSHeapSize && console.warn("totalJSHeapSize === 0, performance.memory is only available in Chrome.");
        this._used = 0;
        this._total = 0;
        this._lastUsed = 0;
      };
      var w = {
        alarm: {},
        used: {},
        total: {}
      };
      x.prototype.tick = function t() {
        this._lastUsed = this._used;
        this._used = window.performance.memory.usedJSHeapSize;
        this._total = window.performance.memory.totalJSHeapSize;
      };
      w.alarm.get = function() {
        return this._used - this._lastUsed < 0;
      };
      w.used.get = function() {
        return window.performance.memory.usedJSHeapSize;
      };
      w.total.get = function() {
        return this._total;
      };
      x.prototype.counter = function t(e, i) {
        return new m(this, e, i);
      };
      Object.defineProperties(x.prototype, w);
      var y = {
        memory: x
      };
      var g = 100;
      var b = 10;
      var S = "\n  .pstats {\n    position: fixed;\n    z-index: 9999;\n\n    padding: 5px;\n    width: " + (g + 150) + "px;\n    right: 5px;\n    bottom: 5px;\n\n    font-size: 10px;\n    font-family: 'Roboto Condensed', tahoma, sans-serif;\n    overflow: hidden;\n    user-select: none;\n    cursor: default;\n\n    background: #222;\n    border-radius: 3px;\n  }\n\n  .pstats-container {\n    display: block;\n    position: relative;\n    color: #888;\n    white-space: nowrap;\n  }\n\n  .pstats-item {\n    position: absolute;\n    width: 250px;\n    height: 12px;\n    left: 0px;\n  }\n\n  .pstats-label {\n    position: absolute;\n    width: 150px;\n    height: 12px;\n    text-align: left;\n    transition: background 0.3s;\n  }\n\n  .pstats-label.alarm {\n    color: #ccc;\n    background: #800;\n\n    transition: background 0s;\n  }\n\n  .pstats-counter-id {\n    position: absolute;\n    width: 90px;\n    left: 0px;\n  }\n\n  .pstats-counter-value {\n    position: absolute;\n    width: 60px;\n    left: 90px;\n    text-align: right;\n  }\n\n  .pstats-canvas {\n    display: block;\n    position: absolute;\n    right: 0px;\n    top: 1px;\n  }\n\n  .pstats-fraction {\n    position: absolute;\n    width: 250px;\n    left: 0px;\n  }\n\n  .pstats-legend {\n    position: absolute;\n    width: 150px;\n\n    text-align: right;\n  }\n\n  .pstats-legend > span {\n    position: absolute;\n    right: 0px;\n  }\n";
      var R = document.createElement("style");
      R.type = "text/css";
      R.textContent = S;
      document.head.appendChild(R);
      var C = function t(e, i) {
        var a = this;
        i = i || {};
        this._showGraph = void 0 === i.showGraph || i._showGraph;
        this._values = i.values || {};
        this._fractions = i.fractions || [];
        this._id2counter = {};
        this._id2item = {};
        this._name2extStats = {};
        if (i.css) {
          var s = document.createElement("style");
          s.type = "text/css";
          s.textContent = i.css;
          document.head.appendChild(s);
        }
        if (i.extensions) for (var r = 0; r < i.extensions.length; ++r) {
          var c = i.extensions[r];
          var p = y[c];
          if (!p) {
            console.warn("Can not find extensions " + c + ", please register your extension via pstats.register().");
            continue;
          }
          a._name2extStats[c] = new p();
        }
        this._root = document.createElement("div");
        this._root.className = "pstats";
        var _ = document.createElement("div");
        _.className = "pstats-container";
        this._root.appendChild(_);
        var f = 0;
        for (var u in a._values) {
          var v = a._values[u];
          var d = document.createElement("div");
          d.className = "pstats-item";
          var m = document.createElement("div");
          m.className = "pstats-label";
          var x = document.createElement("span");
          x.className = "pstats-counter-id";
          x.textContent = v.desc || u;
          var w = document.createElement("div");
          w.className = "pstats-counter-value";
          var S = document.createTextNode("");
          S.nodeValue = "0";
          m.appendChild(x);
          m.appendChild(w);
          w.appendChild(S);
          d.appendChild(m);
          var R = void 0;
          if (a._showGraph) {
            R = void 0 !== v.min || void 0 !== v.max ? new l(d, v.color, v.min || 0, v.max || 9999) : v.threshold ? new o(d, v.color) : new n(d, v.color);
            R.init(g - 5, b);
          }
          a._id2item[u] = {
            label: m,
            valueText: S,
            graph: R
          };
          d.style.top = f + "px";
          _.appendChild(d);
          f += 12;
        }
        if (this._showGraph && i.fractions) for (var C = 0; C < i.fractions.length; ++C) {
          var M = i.fractions[C];
          var A = M.steps;
          var E = A.length * b + 2;
          M.colors = M.colors || [ "#850700", "#c74900", "#fcb300", "#284280", "#4c7c0c" ];
          var k = document.createElement("div");
          k.className = "pstats-fraction";
          var N = document.createElement("div");
          N.className = "pstats-legend";
          N.style.height = E + "px";
          for (var z = 0; z < A.length; ++z) {
            var G = document.createElement("span");
            G.textContent = A[z];
            G.style.color = M.colors[z];
            G.style.top = z * b + "px";
            N.appendChild(G);
          }
          k.appendChild(N);
          k.style.height = E + "px";
          k.style.top = f + "px";
          var O = new h(k, M.colors);
          O.init(g - 5, b, A.length);
          M.graph = O;
          M.values = new Array(A.length);
          _.appendChild(k);
          f += A.length * b + 2;
        }
        _.style.height = f + "px";
        this._root.style.height = f + "px";
        this._showGraph || (this._root.style.width = "150px");
        e.appendChild(this._root);
      };
      C.prototype.item = function t(e) {
        if (!e) return null;
        var i = this._id2counter[e];
        if (i) return i;
        var a = this._values[e];
        if (!a) return null;
        if (a.extension) {
          var n = a.extension.indexOf(".");
          var s = a.extension.substring(0, n);
          var o = this._name2extStats[s];
          if (!o) {
            console.error("extension " + s + " not found, make sure you have register and enable it.");
            return null;
          }
          i = o.counter(e, a);
        } else i = new f(e, a);
        this._id2counter[e] = i;
        return i;
      };
      C.prototype.tick = function t() {
        var e = this;
        for (var i in e._name2extStats) {
          var a = e._name2extStats[i];
          a.tick();
        }
        for (var n in e._values) {
          var s = e._id2counter[n];
          if (s) {
            s.sample();
            var o = s.alarm();
            var r = s.human();
            var l = e._id2item[n];
            l.label.classList.toggle("alarm", o > 0);
            l.valueText.nodeValue = r;
            e._showGraph && l.graph.draw(s.value, o);
          }
        }
        if (this._showGraph) for (var c = 0; c < this._fractions.length; ++c) {
          var h = e._fractions[c];
          var p = e._id2counter[h.base];
          if (p) {
            var _ = h.steps;
            for (var f = 0; f < _.length; ++f) {
              var u = _[f];
              var v = e._id2counter[u];
              v && (h.values[f] = v.value / p.value);
            }
            h.graph.draw(h.values);
          }
        }
      };
      t();
      var M = {
        new: function t(e, i) {
          var a = new C(e, i);
          return function(t) {
            if (!t) return a;
            return a.item(t);
          };
        },
        register: function t(e, i) {
          y[e] = i;
        }
      };
      return M;
    })();
  }), {} ],
  178: [ (function(require, module, exports) {
    cc = {};
    _ccsg = {};
    _cc = {};
    require("./predefine");
    require("./CCDebugger");
    require("./polyfill/string");
    require("./polyfill/misc");
    require("./polyfill/array");
    true;
    require("./polyfill/typescript");
    require("./cocos2d/kazmath");
    require("./cocos2d/core/predefine");
    true;
    require("./cocos2d/shaders");
    require("./CCBoot");
    require("./cocos2d");
    require("./extends");
    false;
    module.exports = cc;
  }), {
    "./CCBoot": 1,
    "./CCDebugger": 2,
    "./cocos2d": 152,
    "./cocos2d/core/predefine": 114,
    "./cocos2d/kazmath": 156,
    "./cocos2d/shaders": 170,
    "./extends": 174,
    "./package.json": void 0,
    "./polyfill/array": 180,
    "./polyfill/misc": 181,
    "./polyfill/string": 182,
    "./polyfill/typescript": 183,
    "./predefine": 184
  } ],
  179: [ (function(require, module, exports) {}), {} ],
  180: [ (function(require, module, exports) {
    Array.isArray || (Array.isArray = function(arg) {
      return "[object Array]" === Object.prototype.toString.call(arg);
    });
  }), {} ],
  181: [ (function(require, module, exports) {
    Math.sign || (Math.sign = function(x) {
      x = +x;
      if (0 === x || isNaN(x)) return x;
      return x > 0 ? 1 : -1;
    });
    Number.isInteger || (Number.isInteger = function(value) {
      return "number" === typeof value && isFinite(value) && Math.floor(value) === value;
    });
    if (false, !console.time) {
      var Timer = window.performance || Date;
      var _timerTable = Object.create(null);
      console.time = function(label) {
        _timerTable[label] = Timer.now();
      };
      console.timeEnd = function(label) {
        var startTime = _timerTable[label];
        var duration = Timer.now() - startTime;
        console.log(label + ": " + duration + "ms");
      };
    }
  }), {} ],
  182: [ (function(require, module, exports) {
    String.prototype.startsWith || (String.prototype.startsWith = function(searchString, position) {
      position = position || 0;
      return this.lastIndexOf(searchString, position) === position;
    });
    String.prototype.endsWith || (String.prototype.endsWith = function(searchString, position) {
      ("undefined" === typeof position || position > this.length) && (position = this.length);
      position -= searchString.length;
      var lastIndex = this.indexOf(searchString, position);
      return -1 !== lastIndex && lastIndex === position;
    });
  }), {} ],
  183: [ (function(require, module, exports) {
    var extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
    };
    window.__extends = function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    window.__assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
      }
      return t;
    };
    window.__rest = function(s, e) {
      var t = {};
      for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
      if (null != s && "function" === typeof Object.getOwnPropertySymbols) for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && (t[p[i]] = s[p[i]]);
      return t;
    };
    window.__decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    window.__param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    window.__metadata = function(metadataKey, metadataValue) {
      if ("object" === typeof Reflect && "function" === typeof Reflect.metadata) return Reflect.metadata(metadataKey, metadataValue);
    };
    window.__awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : new P(function(resolve) {
            resolve(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    window.__generator = function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = y[2 & op[0] ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 0, t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    window.__exportStar = function(m, exports) {
      for (var p in m) exports.hasOwnProperty(p) || (exports[p] = m[p]);
    };
    window.__values = function(o) {
      var m = "function" === typeof Symbol && o[Symbol.iterator], i = 0;
      if (m) return m.call(o);
      return {
        next: function() {
          o && i >= o.length && (o = void 0);
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
    };
    window.__read = function(o, n) {
      var m = "function" === typeof Symbol && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((void 0 === n || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          r && !r.done && (m = i["return"]) && m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    window.__spread = function() {
      for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    window.__await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    window.__asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        g[n] && (i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([ n, v, a, b ]) > 1 || resume(n, v);
          });
        });
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        (f(v), q.shift(), q.length) && resume(q[0][0], q[0][1]);
      }
    };
    window.__asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", (function(e) {
        throw e;
      })), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        o[n] && (i[n] = function(v) {
          return (p = !p) ? {
            value: __await(o[n](v)),
            done: "return" === n
          } : f ? f(v) : v;
        });
      }
    };
    window.__asyncValues = function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator];
      return m ? m.call(o) : "function" === typeof __values ? __values(o) : o[Symbol.iterator]();
    };
  }), {} ],
  184: [ (function(require, module, exports) {
    var _global = "undefined" === typeof window ? global : window;
    function defineMacro(name, defaultValue) {
      "undefined" === typeof _global[name] && (_global[name] = defaultValue);
    }
    function defined(name) {
      return "object" === typeof _global[name];
    }
    defineMacro("CC_TEST", defined("tap") || defined("QUnit"));
    defineMacro("CC_EDITOR", defined("Editor") && defined("process") && "electron" in process.versions);
    defineMacro("CC_PREVIEW", true);
    defineMacro("CC_DEV", true);
    defineMacro("CC_DEBUG", true);
    defineMacro("CC_JSB", defined("jsb"));
    defineMacro("CC_BUILD", false);
    defineMacro("CC_WECHATGAME", defined("wx") && wx.getSystemInfoSync);
    defineMacro("CC_QQPLAY", defined("bk"));
    defineMacro("CC_SUPPORT_JIT", false);
    false;
    var engineVersion = "1.10.1";
    _global["CocosEngine"] = cc.ENGINE_VERSION = engineVersion;
  }), {} ]
}, {}, [ 178 ]);